
; Prologue
; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

; use TmpType for helpers where the type doesn't matter
; these shouldn't appear in values in the program, only intermediate terms (such as in ivt.egg permutations)
(constructor TmpType () Type)

(constructor TNil () TypeList)
(constructor TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Assumptions
; =================================

(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf bool Expr Expr)
)



; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(constructor Arg (Type Assumption) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool)
  (Float f64))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(constructor Const (Constant Type Assumption) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(constructor Empty (Type Assumption) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write)
  (Select))
(datatype BinaryOp
  ;; Bitwise operators
  (Bitand)
  ;; integer operators
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (Smin)
  (Smax)
  (Shl)
  (Shr)
  ;; float operators 
  (FAdd)
  (FSub)
  (FDiv)
  (FMul)
  (FLessThan)
  (FGreaterThan) 
  (FLessEq)
  (FGreaterEq)
  (FEq)
  (Fmin)
  (Fmax)
  ;; logical operators
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Neg)
  (Abs)
  (Not))

; Operators
(constructor Top   (TernaryOp Expr Expr Expr) Expr)
(constructor Bop   (BinaryOp Expr Expr) Expr)
(constructor Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(constructor Get   (Expr i64) Expr)
; (Alloc id amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns (pointer to the allocated memory, state edge)
(constructor Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(constructor Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(constructor Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 expr1       expr2
(constructor Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; pred must be an integer
;                 pred  inputs   branches     chosen
(constructor Switch (Expr  Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred inputs   then else
(constructor If (Expr Expr     Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple 
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(constructor DoWhile (Expr    Expr)                   Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(constructor Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(constructor Function (String Type      Type       Expr)      Expr)

; to get the type of a funciton, look in this table
; since we might not be optimizing the entire program
(relation FunctionHasType (String Type Type))

; Rulesets
(ruleset always-run)
(ruleset is-resolved)
(ruleset error-checking)
(ruleset memory)
(ruleset memory-helpers)
(ruleset smem)

;; Initliazation
(relation bop->string (BinaryOp String))
(relation uop->string (UnaryOp String))
(relation top->string (TernaryOp String))
(bop->string (Add) "Add")
(bop->string (Sub) "Sub")
(bop->string (Div) "Div")
(bop->string (Mul) "Mul")
(bop->string (LessThan) "LessThan")
(bop->string (GreaterThan) "GreaterThan")
(bop->string (LessEq) "LessEq")
(bop->string (GreaterEq) "GreaterEq")
(bop->string (Eq) "Eq")
(bop->string (FAdd) "FAdd")
(bop->string (FSub) "FSub")
(bop->string (FDiv) "FDiv")
(bop->string (FMul) "FMul")
(bop->string (FLessThan) "FLessThan")
(bop->string (FGreaterThan) "FGreaterThan")
(bop->string (FLessEq) "FLessEq")
(bop->string (FGreaterEq) "FGreaterEq")
(bop->string (FEq) "FEq")
(bop->string (And) "And")
(bop->string (Or) "Or")
(bop->string (Load) "Load")
(bop->string (PtrAdd) "PtrAdd")
(bop->string (Print) "Print")
(bop->string (Free) "Free")

;; If anything is put in the DebugExpr relation, we'll extract them instead of the original program.
;; These can then be visualized using the `optimized-rvsdg` run mode
(relation DebugExpr (Expr))

; TERMS
(datatype Term)
(datatype ListTerm (TermCons Term ListTerm) (TermNil))

; TODO: Will probably need ctx so that we can resubstitute?
; (datatype TermAssumption
;   ; Assume nothing
;   (InFunc String)
;   ; The term is in a loop with `input` and `pred_output`.
;   ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
;   ;      input    pred_output
;   (InLoop Term     Term)
;   ; Branch of the switch, and what the predicate is, and what the input is
;   (InSwitch i64 Term Term)
;   ; If the predicate was true, and what the predicate is, and what the input is
;   (InIf bool Term Term)
; )

(constructor TermArg () Term)

(constructor TermConst (Constant) Term)

(constructor TermEmpty () Term)

; Term Operators
(constructor TermTop (TernaryOp Term Term Term) Term)
(constructor TermBop (BinaryOp Term Term) Term)
(constructor TermUop (UnaryOp Term) Term)
(constructor TermGet (Term i64) Term)
(constructor TermAlloc (i64 Term Term BaseType) Term)
(constructor TermCall (String Term) Term)

; Tuple Operators
(constructor TermSingle (Term) Term)
(constructor TermConcat (Term Term) Term)

; Control Flow (TODO? Not sure if needed)
; (constructor TermSwitch (Term Term ListTerm) Term)
; (constructor TermIf (Term Term Term Term) Term)

; (constructor TermDoWhile (Term Term) Term)


(ruleset never)
(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(constructor TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64 :no-merge)
(constructor TypeList-ith (TypeList i64) BaseType :unextractable)
;; Don't match on TypeList-ith because it is now lazily instantiated!
(rule () ((set (TypeList-length (TNil)) 0)) :ruleset type-helpers)
(rule ((= lst (TCons hd tl))
       (= len (TypeList-length tl)))
      ((set (TypeList-length lst) (+ 1 len))) :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) 0) hd :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) i) (TypeList-ith tl (- i 1)) 
      :when ((> i 0)) 
      :ruleset type-helpers)

(rule ((TypeList-ith list i)
       (= (TypeList-length list) n)
       (>= i n))
      ((panic "TypeList-ith out of bounds")) :ruleset type-helpers)

(relation HasType (Expr Type))


;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      (
       (panic "type mismatch- check RUST_LOG=info for expressions that mismatched"))
      :ruleset error-checking)


(rule ((= (Const c1 ty1 ctx1) (Const c2 ty2 ctx2))
       (= ctx1 (InFunc name))
       (!= c1 c2))
      ((panic "Unsoundness detected: const values differ at top level"))
      :ruleset error-checking)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1 ctx) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset error-checking)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset error-checking)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType branch ty)
       (HasType inputs ty2)
       (!= ty ty2))
      ((panic "switch branches then branch has incorrect input type"))
      :ruleset error-checking)
;; demand with one fewer branches
(rule ((= lhs (Switch pred inputs (Cons branch rest))))
      ((Switch pred inputs rest))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType t ty2)
       (!= ty ty2))
      ((panic "if branches then branch has incorrect input type"))
      :ruleset error-checking)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType e ty2)
       (!= ty ty2))
      ((panic "if branches else branch has incorrect input type"))
      :ruleset error-checking)


(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty ctx)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty ctx)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Float b) ty ctx)))
      ((HasType lhs (Base (FloatT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty ctx)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not)"))
      :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
      (HasType e (Base (IntT)))
) (
      (HasType lhs (Base (IntT)))
) :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
) (
      (ExpectType e (Base (IntT)) "(Neg)")
) :ruleset type-analysis)

(rule (
        (= lhs (Uop (Abs) e))
        (HasType e (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Abs) e)))
      ((ExpectType e (Base (IntT)) "(Abs)"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset error-checking)

(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset error-checking)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset error-checking)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Top (Select) pred v1 v2))
      )
      ((ExpectType pred (Base (BoolT)) "(Select)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty)
        (HasType v2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty1)
        (HasType v2 ty2)
        (!= ty1 ty2)
      )
      ((panic "(Select) branches had different types"))
      :ruleset error-checking)


; Binary ops

;; Operators that have type Type -> Type -> Type
;; Note we only do this generic matching for binary
;; operator since there's a lot of them.
;; In the future we can also extend to other constructs.
(relation bop-of-type (BinaryOp Type))
(bop-of-type (Bitand) (Base (IntT)))
(bop-of-type (Add) (Base (IntT)))
(bop-of-type (Sub) (Base (IntT)))
(bop-of-type (Div) (Base (IntT)))
(bop-of-type (Mul) (Base (IntT)))
(bop-of-type (FAdd) (Base (FloatT)))
(bop-of-type (FSub) (Base (FloatT)))
(bop-of-type (FDiv) (Base (FloatT)))
(bop-of-type (FMul) (Base (FloatT)))

(rule (
        (= lhs (Bop op e1 e2))
        (bop-of-type op ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop op e1 e2))
       (bop-of-type op ty)
       (bop->string op op-str))
      (
        (ExpectType e1 ty op-str)
        (ExpectType e2 ty op-str)
      )
      :ruleset type-analysis)  

;; Operators that have type Float -> Float -> Bool
(relation bpred-of-type (BinaryOp Type))
(bpred-of-type (FLessThan) (Base (FloatT)))
(bpred-of-type (FLessEq) (Base (FloatT)))
(bpred-of-type (FGreaterThan) (Base (FloatT)))
(bpred-of-type (FGreaterEq) (Base (FloatT)))
(bpred-of-type (FEq) (Base (FloatT)))
(bpred-of-type (LessThan) (Base (IntT)))
(bpred-of-type (LessEq) (Base (IntT)))
(bpred-of-type (GreaterThan) (Base (IntT)))
(bpred-of-type (GreaterEq) (Base (IntT)))
(bpred-of-type (Eq) (Base (IntT)))
(bpred-of-type (And) (Base (BoolT)))
(bpred-of-type (Or) (Base (BoolT)))

(rule (
        (= lhs (Bop pred e1 e2))
        (bpred-of-type pred ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop pred e1 e2))
       (bpred-of-type pred ty)
       (bop->string pred pred-str))
      (
        (ExpectType e1 ty pred-str)
        (ExpectType e2 ty pred-str)
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base ty)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write)"))
      :ruleset type-analysis)
      
       

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i)))) 
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset error-checking)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset error-checking)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset error-checking)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred inputs then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset error-checking)



(rule ((= lhs (Switch pred inputs branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred inputs (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred inputs (Cons branch rest)))
      ((Switch pred inputs rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred inputs rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred inputs rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset error-checking)

(rule ((Arg ty ctx))
      (
        (HasType (Arg ty ctx) ty)
        (HasArgType (Arg ty ctx) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset error-checking)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; find which types are pure
(relation PureBaseType (BaseType))
(relation PureType (Type))
(relation PureTypeList (TypeList))

(PureBaseType (IntT))
(PureBaseType (BoolT))
(rule ((Base ty)
       (PureBaseType ty))
      ((PureType (Base ty)))
      :ruleset type-analysis)
(rule ((TupleT tylist)
       (PureTypeList tylist))
      ((PureType (TupleT tylist)))
      :ruleset type-analysis)
(rule ((TNil))
      ((PureTypeList (TNil)))
      :ruleset type-analysis)
(rule ((TCons hd tl)
       (PureBaseType hd)
       (PureTypeList tl))
      ((PureTypeList (TCons hd tl)))
      :ruleset type-analysis)

(function ListExpr-length (ListExpr) i64 :no-merge)
(constructor ListExpr-ith (ListExpr i64) Expr :unextractable)
(constructor ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(constructor Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred inputs branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :no-merge)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)


;; Leading expressions are tuples that are used as a whole
;; during optimization and are matched in the query.
(relation leading-Expr (Expr))
(relation leading-Expr-list (ListExpr))

(rule ((= e (DoWhile inputs pred_out)))
      ((leading-Expr e)
       (leading-Expr inputs)
       (leading-Expr pred_out))
      :ruleset always-run)
(rule ((= e (If cond inputs thn els)))
       ((leading-Expr e)
        (leading-Expr inputs)
        (leading-Expr thn)
        (leading-Expr els))
       :ruleset always-run)
(rule ((= e (Switch pred inputs branch)))
      ((leading-Expr e)
       (leading-Expr-list branch)
       (leading-Expr inputs))
       :ruleset always-run)
(rule ((leading-Expr-list (Cons hd tl)))
      ((leading-Expr hd)
       (leading-Expr-list tl))
      :ruleset always-run)
(rule ((= e (Arg t a)))
      ((leading-Expr e))
      :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((leading-Expr tuple)
       (> (tuple-length tuple) 0))
      ((Get tuple 0))
      :ruleset always-run)
;; next get
(rule ((leading-Expr tuple)
       (= len (tuple-length tuple))
       (= ith (Get tuple i))
       (< (+ i 1) len)
       )
       ((Get tuple (+ 1 i)))
       :ruleset always-run)

(constructor List-suffix (Expr i64) Expr)
(rule ((Get x i))
      ((union (List-suffix x 0) x))
      :ruleset always-run)
(rule ((= (List-suffix x n) (Concat (Single hd) tl)))
      ((union (List-suffix x (+ n 1)) tl))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Concat (Single e) rest)))
      ((union lhs e))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Single e)))
      ((union lhs e))
      :ruleset always-run)

;; A temporary context.
;; Be sure to delete at the end of all actions or else!!!
;; This is safer than using a persistant context, since we may miss an important part of the query.
(constructor TmpCtx () Assumption)

(rule ((TmpCtx))
  ((panic "TmpCtx should not exist outside rule body"))
  :ruleset always-run)


(ruleset subsume-after-helpers)
;; After running the `saturating` ruleset, these if statements can be subsumed
(relation ToSubsumeIf (Expr Expr Expr Expr))
;; Workaround of https://github.com/egraphs-good/egglog/issues/462
;; Make sure the if we are subsuming is present
(rule ((ToSubsumeIf a b c d)
       (If a b c d))
      ((subsume (If a b c d)))
      :ruleset subsume-after-helpers)

(ruleset add-to-debug-expr)

(ruleset terms)
;; helpers keeps track of the new best extracted terms
(ruleset terms-helpers)
;; helpers-helpers runs `Smaller` rules, resolving the merge function for helpers
(ruleset terms-helpers-helpers)

(sort TermAndCost)
(constructor Smaller (TermAndCost TermAndCost) TermAndCost)

(function ExtractedExpr (Expr) TermAndCost
  :merge (Smaller old new))
;; potential extractions- use so that when the costs are equal, we don't change the term
;; this preserves egglog's timestamp of when the last time ExtractedExpr was changed, fixing a big performance problem
(relation PotentialExtractedExpr (Expr TermAndCost))

(constructor TCPair (Term i64) TermAndCost)

(constructor NoTerm () Term)

;; set extracted expr to default value
(rule ((PotentialExtractedExpr expr termandcost))
      ((set (ExtractedExpr expr) (TCPair (NoTerm) 10000000000000000)))
      :ruleset terms-helpers)

;; set extracted expr to new value as long as not equal
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (= (ExtractedExpr expr) (TCPair oldterm oldcost))
       (< cost oldcost))
      ((set (ExtractedExpr expr) (TCPair term cost)))
      :ruleset terms-helpers)

;; if the cost is negative panic, terms got too big
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (< cost 0))
      ((panic "Negative cost"))
      :ruleset terms-helpers)

;; Resolve Smaller
(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (< cost1 cost2)
      )
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)

(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (> cost1 cost2) 
      )
      ((union lhs (TCPair t2 cost2)))
      :ruleset terms-helpers-helpers)


(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (= cost1 cost2) 
      )
      ;; arbitrarily pick first one
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)


; Compute smallest Expr bottom-up
(rule ((= lhs (Const c ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermConst c) 1)))
      :ruleset terms)

(rule ((= lhs (Arg ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermArg) 1)))
      :ruleset terms)

(rule (
        (= lhs (Bop o e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermBop o t1 t2) (+ 1 (+ c1 c2)))))
      :ruleset terms)

(rule (
        (= lhs (Top o e1 e2 e3))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (= (TCPair t3 c3) (ExtractedExpr e3))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermTop o t1 t2 t3) (+ (+ 1 c1) (+ c2 c3)))))
      :ruleset terms)

(rule (
        (= lhs (Uop o e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermUop o t1) (+ 1 c1))))
      :ruleset terms)

(rule (
        (= lhs (Get tup i))
        (= (TCPair t1 c1) (ExtractedExpr tup))
      )
      ; cost of the get is the same as the  cost of the whole tuple
      ((PotentialExtractedExpr lhs (TCPair (TermGet t1 i) c1)))
      :ruleset terms)

; todo Alloc

; todo Call

(rule (
        (= lhs (Single e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ; cost of single is same as cost of the element
      ((PotentialExtractedExpr lhs (TCPair (TermSingle t1) c1)))
      :ruleset terms)

(rule (
        (= lhs (Concat e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ; cost of concat is sum of the costs
      ((PotentialExtractedExpr lhs (TCPair (TermConcat t1 t2) (+ c1 c2))))
      :ruleset terms)


; todo Control flow - not sure if needed
; (rule (
;         (= lhs (If pred inputs thn els))
;         (= (TCPair t1 c1) (ExtractedExpr pred))
;         (= (TCPair t2 c2) (ExtractedExpr inputs))
;         (= (TCPair t3 c3) (ExtractedExpr thn))
;         (= (TCPair t4 c4) (ExtractedExpr els))
;       )
;       ; cost of if is 10 + cost of pred + cost of input + max of branch costs
;       ((PotentialExtractedExpr lhs (TCPair (TermIf t1 t2 t3 t4) (+ 10 (+ (+ c1 c2) (max c3 c4))))))
;       :ruleset terms)

(sort Node)
;; store a particular if node for later
;; stored as the if eclass, pred, inputs, then, else
(constructor IfNode (Expr Expr Expr Expr Expr) Node)

(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Function _name _tyin _tyout _out))) ((ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Top _op _x _y _z))) ((ExprIsValid _x)
(ExprIsValid _y)
(ExprIsValid _z)) :ruleset always-run)
(rule ((ExprIsValid (Bop _op _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Uop _op _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Concat _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Single _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _inputs _branches))) ((ExprIsValid _pred)
(ExprIsValid _inputs)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (If _pred _input _then _else))) ((ExprIsValid _pred)
(ExprIsValid _input)
(ExprIsValid _then)
(ExprIsValid _else)) :ruleset always-run)
(rule ((ExprIsValid (DoWhile _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Call _func _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(rule ((ExprIsValid (Alloc _id _e _state _ty))) ((ExprIsValid _e)
(ExprIsValid _state)) :ruleset always-run)
(relation ExprIsResolved (Expr))
(relation ListExprIsResolved (ListExpr))
(rule ((= lhs (Function _name _tyin _tyout _out)) (ExprIsResolved _out)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Const _n _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Top _op _x _y _z)) (ExprIsResolved _x)
(ExprIsResolved _y)
(ExprIsResolved _z)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Bop _op _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Uop _op _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Get _tup _i)) (ExprIsResolved _tup)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Concat _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Single _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Switch _pred _inputs _branches)) (ExprIsResolved _pred)
(ExprIsResolved _inputs)
(ListExprIsResolved _branches)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (If _pred _input _then _else)) (ExprIsResolved _pred)
(ExprIsResolved _input)
(ExprIsResolved _then)
(ExprIsResolved _else)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (DoWhile _in _pred-and-output)) (ExprIsResolved _in)
(ExprIsResolved _pred-and-output)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Arg _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Call _func _arg)) (ExprIsResolved _arg)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Empty _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Cons _hd _tl)) (ExprIsResolved _hd)
(ListExprIsResolved _tl)) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Nil)) ) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Alloc _id _e _state _ty)) (ExprIsResolved _e)
(ExprIsResolved _state)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(relation BodyContainsExpr (Expr Expr))
(relation BodyContainsListExpr (Expr ListExpr))
(rule ((Function _name _tyin _tyout _out)) ((BodyContainsExpr (Function _name _tyin _tyout _out) _out)) :ruleset always-run)
(rule ((If _pred _input _then _else)) ((BodyContainsExpr (If _pred _input _then _else) _then) (BodyContainsExpr (If _pred _input _then _else) _else)) :ruleset always-run)
(rule ((DoWhile _in _pred-and-output)) ((BodyContainsExpr (DoWhile _in _pred-and-output) _pred-and-output)) :ruleset always-run)
(rule ((BodyContainsExpr body (Top _op _x _y _z))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y) (BodyContainsExpr body _z)) :ruleset always-run)
(rule ((BodyContainsExpr body (Bop _op _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Uop _op _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Get _tup _i))) ((BodyContainsExpr body _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body (Concat _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Single _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Switch _pred _inputs _branches))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _inputs)) :ruleset always-run)
(rule ((BodyContainsExpr body (If _pred _input _then _else))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _input)) :ruleset always-run)
(rule ((BodyContainsExpr body (DoWhile _in _pred-and-output))) ((BodyContainsExpr body _in)) :ruleset always-run)
(rule ((BodyContainsExpr body (Call _func _arg))) ((BodyContainsExpr body _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body (Cons _hd _tl))) ((BodyContainsExpr body _hd)) :ruleset always-run)
(rule ((BodyContainsExpr body (Alloc _id _e _state _ty))) ((BodyContainsExpr body _e) (BodyContainsExpr body _state)) :ruleset always-run)
(relation ExprIsPure (Expr))
(relation ListExprIsPure (ListExpr))
(relation BinaryOpIsPure (BinaryOp))
(relation UnaryOpIsPure (UnaryOp))
(relation TernaryOpIsPure (TernaryOp))
(TernaryOpIsPure (Select))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (Smax))
(BinaryOpIsPure (Smin))
(BinaryOpIsPure (Shl))
(BinaryOpIsPure (Shr))
(BinaryOpIsPure (FAdd))
(BinaryOpIsPure (FSub))
(BinaryOpIsPure (FMul))
(BinaryOpIsPure (FDiv))
(BinaryOpIsPure (FEq))
(BinaryOpIsPure (FLessThan))
(BinaryOpIsPure (FGreaterThan))
(BinaryOpIsPure (FLessEq))
(BinaryOpIsPure (FGreaterEq))
(BinaryOpIsPure (Fmax))
(BinaryOpIsPure (Fmin))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(BinaryOpIsPure (Bitand))
(UnaryOpIsPure (Not))
(UnaryOpIsPure (Abs))
(UnaryOpIsPure (Neg))

(rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
        ((ExprIsPure (Function _name _tyin _tyout _out)))
        :ruleset always-run)

(rule ((Const _n _ty _ctx))
        ((ExprIsPure (Const _n _ty _ctx)))
        :ruleset always-run)

(rule ((Top _op _x _y _z) (TernaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
        ((ExprIsPure (Top _op _x _y _z)))
        :ruleset always-run)

(rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Bop _op _x _y)))
        :ruleset always-run)

(rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
        ((ExprIsPure (Uop _op _x)))
        :ruleset always-run)

(rule ((Get _tup _i) (ExprIsPure _tup))
        ((ExprIsPure (Get _tup _i)))
        :ruleset always-run)

(rule (
        (= lhs (Get (Arg (TupleT tylist) _ctx) i))
        (!= (TypeList-ith tylist i) (StateT))
      )
      ((ExprIsPure lhs))
      :ruleset always-run)

(rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Concat _x _y)))
        :ruleset always-run)

(rule ((Single _x) (ExprIsPure _x))
        ((ExprIsPure (Single _x)))
        :ruleset always-run)

(rule ((Switch _pred _inputs _branches) (ExprIsPure _pred) (ExprIsPure _inputs) (ListExprIsPure _branches))
        ((ExprIsPure (Switch _pred _inputs _branches)))
        :ruleset always-run)

(rule ((If _pred _input _then _else) (ExprIsPure _pred) (ExprIsPure _input) (ExprIsPure _then) (ExprIsPure _else))
        ((ExprIsPure (If _pred _input _then _else)))
        :ruleset always-run)

(rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
        ((ExprIsPure (DoWhile _in _pred-and-output)))
        :ruleset always-run)

; state edge is not pure!
; (rule ((Arg _ty _ctx))
;         ((ExprIsPure (Arg _ty _ctx)))
;         :ruleset always-run)

(rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
        ((ExprIsPure (Call _f _arg)))
        :ruleset always-run)

(rule ((Empty _ty _ctx))
        ((ExprIsPure (Empty _ty _ctx)))
        :ruleset always-run)

(rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
        ((ListExprIsPure (Cons _hd _tl)))
        :ruleset always-run)

(rule ((Nil))
        ((ListExprIsPure (Nil)))
        :ruleset always-run)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)

(constructor AddContext (Assumption Expr) Expr :unextractable)
(constructor AddContextList (Assumption ListExpr) ListExpr :unextractable)

;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (AddContext ctx inner))
   (= inner (AddContext ctx expr)))
  ((union lhs inner))
  :ruleset context)


;; ############################## Base cases- leaf nodes

;; replace existing contexts that are around leaf nodes
;; AddContext assumes the new context is more specific than the old one
(rule ((= lhs (AddContext ctx (Arg ty oldctx))))
      ((union lhs (Arg ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Const c ty oldctx))))
      ((union lhs (Const c ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Empty ty oldctx))))
      ((union lhs (Empty ty ctx)))
      :ruleset context)




;; ######################################### Operators
(rewrite (AddContext ctx (Top op c1 c2 c3))
         (Top op
           (AddContext ctx c1)
           (AddContext ctx c2)
           (AddContext ctx c3))
               :ruleset context)
(rewrite (AddContext ctx (Bop op c1 c2))
         (Bop op
           (AddContext ctx c1)
           (AddContext ctx c2))
               :ruleset context)
(rewrite (AddContext ctx (Uop op c1))
         (Uop op (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Get c1 index))
         (Get (AddContext ctx c1) index)
               :ruleset context)
(rewrite (AddContext ctx (Alloc id c1 state ty))
         (Alloc id (AddContext ctx c1) (AddContext ctx state) ty)
         :ruleset context)
(rewrite (AddContext ctx (Call name c1))
         (Call name (AddContext ctx c1))
         :ruleset context)

(rewrite (AddContext ctx (Single c1))
         (Single (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Concat c1 c2))
         (Concat
           (AddContext ctx c1)
           (AddContext ctx c2))
         :ruleset context)

;; ################################### List operators

(rewrite (AddContextList ctx (Nil))
         (Nil)
         :ruleset context)

(rewrite (AddContextList ctx (Cons c1 rest))
         (Cons (AddContext ctx c1)
               (AddContextList ctx rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (AddContext ctx (Switch pred inputs branches))
         (Switch (AddContext ctx pred)
                 (AddContext ctx inputs)
                 branches)
         :ruleset context)

;; For stop at region, still add context to inputs
(rule ((= lhs (AddContext ctx (If pred inputs c1 c2))))
      ((union lhs
         (If (AddContext ctx pred)
             (AddContext ctx inputs)
             c1
             c2)))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (AddContext ctx (DoWhile inputs outputs))))
      ((union lhs
        (DoWhile
          (AddContext ctx inputs)
          outputs)))
       :ruleset context)


(ruleset term-subst)


; Instantiate the term as an Expr in the provided context
; where references to (Arg) in the term are replaced by Expr
(constructor TermSubst (Assumption Expr Term) Expr :unextractable)

; type rule to get the arg type of a substitution
(rule (
        (= lhs (TermSubst ctx e1 term))
        (HasArgType e1 ty)       
      )
      ((HasArgType lhs ty))
      :ruleset term-subst)


; leaf node
; replace the context
(rule ((= lhs (TermSubst ctx e (TermArg))))
      ((union lhs (AddContext ctx e)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConst c)))
       (HasArgType e newty))
      ((union lhs (Const c newty ctx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermEmpty)))
       (HasArgType e newty))
      ((union lhs (Empty newty ctx)))
      :ruleset term-subst)

; Operators
(rule ((= lhs (TermSubst ctx e (TermTop op t1 t2 t3))))
      ((union lhs (Top op (TermSubst ctx e t1)
                          (TermSubst ctx e t2)
                          (TermSubst ctx e t3))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermBop op t1 t2))))
      ((union lhs (Bop op (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermUop op t1))))
      ((union lhs (Uop op (TermSubst ctx e t1))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermGet t idx))))
      ((union lhs (Get (TermSubst ctx e t) idx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermAlloc id t1 t2 ty))))
      ((union lhs (Alloc id (TermSubst ctx e t1)
                            (TermSubst ctx e t2)
                            ty)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermCall name t))))
      ((union lhs (Call name (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermSingle t))))
      ((union lhs (Single (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConcat t1 t2))))
      ((union lhs (Concat (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

; Control Flow
; TODO
;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(constructor Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(constructor DelayedSubstUnion (Expr Expr) Expr :unextractable)

;; add a type rule to get the arg type of a substitution
;; this enables nested substitutions
(rule ((= lhs (Subst assum to in))
       (HasArgType to ty))
      ((HasArgType lhs ty))
      :ruleset subst)

;; Substitution typechecks only when the type of the
;; argument matches the type of the substitution.
(rule ((Subst assum to in)
       (HasArgType in ty)
       (HasType to ty2)
       (!= ty ty2)
       ;; tmptype disables typechecking
       (!= ty (TmpType))
       (!= ty2 (TmpType)))
      (
       (panic "Substitution type mismatch! Argument type must match type of substituted term"))
       :ruleset subst)


;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to e))
       (= e (Arg _ty _oldctx))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Const c _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Const c newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Empty _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Empty newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)

;; Operators
(rule ((= e (Top op c1 c2 c3))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Top op (Subst assum to c1)
                 (Subst assum to c2)
                 (Subst assum to c3)))
       (subsume (Subst assum to e)))
         :ruleset subst)

(rule ((= e (Bop op c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Bop op (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Uop op c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Uop op (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)    

(rule ((= e (Get c1 index))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Get (Subst assum to c1) index))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Alloc id c1 c2 ty))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Alloc id (Subst assum to c1)
                   (Subst assum to c2)
                   ty))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Call name c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Call name (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)


;; Tuple operators
(rule ((= e (Single c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Single (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Concat c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Concat (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)

;; Control flow
(rule ((= lhs (Subst assum to inner))
       (= inner (Switch pred inputs c1))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 c1))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= lhs (Subst assum to inner))
       (= inner (If pred inputs c1 c2))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= e (DoWhile in out))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (DoWhile (Subst assum to in)
                  out))
       (subsume (Subst assum to e)))
      :ruleset subst)

;; substitute into function (convenience for testing)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :when ((ExprIsResolved body))
         :ruleset subst)



;; ########################### Apply subst unions

(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)

; We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

(rule ((Arg ty ctx))
      ((ContextOf (Arg ty ctx) ctx))
      :ruleset always-run)
(rule ((Const c ty ctx))
      ((ContextOf (Const c ty ctx) ctx))
      :ruleset always-run)
(rule ((Empty ty ctx))
      ((ContextOf (Empty ty ctx) ctx))
        :ruleset always-run)

; Error checking - each expr should only have a single context
(rule ((ContextOf x ctx1)
       (ContextOf x ctx2)
       (!= ctx1 ctx2))
     (
         (panic "Equivalent expressions have nonequivalent context, breaking the single context invariant.")
     )
     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred inputs branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred inputs branches) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf pred ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((If pred inputs then else) (ContextOf inputs ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(ruleset canon)

; Commutativity
(rewrite (Bop (Add) x y) (Bop (Add) y x) :ruleset canon)
(rewrite (Bop (Mul) x y) (Bop (Mul) y x) :ruleset canon)
(rewrite (Bop (Eq) x y) (Bop (Eq) y x) :ruleset canon)
(rewrite (Bop (And) x y) (Bop (And) y x) :ruleset canon)
(rewrite (Bop (Or) x y) (Bop (Or) y x) :ruleset canon)

; Canonicalize to <
; x > y ==> y < x
(rewrite (Bop (GreaterThan) x y) (Bop (LessThan) y x) :ruleset canon)

; x >= y ==> y < x + 1
; x >= y ==> y - 1 < x
(rule (
        (= lhs (Bop (GreaterEq) x y))
        (HasArgType x ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) y (Bop (Add) x (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) y (Const (Int 1) ty ctx)) x))
      )
      :ruleset canon)

; x <= y ==> x < y + 1
; x <= y ==> x - 1 < y
(rule (
        (= lhs (Bop (LessEq) x y))
        (HasArgType y ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) x (Bop (Add) y (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) x (Const (Int 1) ty ctx)) y))
      )
      :ruleset canon)


; Make Concats right-deep
(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)
; Simplify Concat's with empty
(rewrite (Concat (Empty ty ctx) x)
         x
         :ruleset always-run)
(rewrite (Concat x (Empty ty ctx))
         x
         :ruleset always-run)

; Make a tuple that is a sub-range of another tuple
;                   tuple start len
(constructor SubTuple (Expr  i64   i64) Expr :unextractable)

(rewrite (SubTuple expr x 0)
         (Empty ty ctx)
         :when ((HasArgType expr ty) (ContextOf expr ctx))
         :ruleset always-run)

(rewrite (SubTuple expr x 1)
         (Single (Get expr x))
         :ruleset always-run)

(rewrite (SubTuple expr a b)
         (Concat (Single (Get expr a)) (SubTuple expr (+ a 1) (- b 1)))
         :when ((> b 1))
         :ruleset always-run)

; Some of our rules (like ivt.egg) match on `Concat`.
; These may be missing if a tuple is used directly (i.e. (DoWhile inputs (If pred thn else))).
; So add these concats for every region in the database
(rule ((= lhs (DoWhile inputs body))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (If pred inputs thn els))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Switch pred inputs bodies))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Arg ty ctx))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)

; Also figure out what existing expressions are subtuples of other things
; this helps remove concat layers
(rule ((Get expr i))
      ((union (Single (Get expr i))
              (SubTuple expr i 1)))
      :ruleset always-run)

(rewrite (Concat (SubTuple expr a b)
                 (SubTuple expr (+ a b) c))
         (SubTuple expr a (+ b c))
         :ruleset always-run)
;; a subtuple which is the entire tuple is the tuple itself
;; this removes unecessary layers of concat
(rewrite (SubTuple expr 0 len)
         expr
         :when ((= len (tuple-length expr)))
         :ruleset always-run)

; Helper functions to remove one element from a tuple or type list
;                           tuple    idx
(constructor TupleRemoveAt    (Expr     i64) Expr     :unextractable)
(rewrite (TupleRemoveAt tuple idx)
         (Concat (SubTuple tuple 0 idx)
                 (SubTuple tuple (+ idx 1) (- len (+ idx 1))))
         :when ((= len (tuple-length tuple)))
         :ruleset always-run)
(rule ((TupleRemoveAt tuple idx)
       (= len (tuple-length tuple))
       (>= idx len))
      ((panic "Index out of bounds for TupleRemoveAt")) :ruleset always-run)

(constructor TypeListRemoveAt (TypeList i64) TypeList :unextractable)
(rule ((TypeListRemoveAt (TNil) _idx))
      ((panic "Index out of bounds for TypeListRemoveAt.")) :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) 0)
         xs
         :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) idx)
         (TCons x (TypeListRemoveAt xs (- idx 1)))
         :when ((> idx 0))
         :ruleset type-helpers)

;; Compute the tree size of program, not dag size
(function Expr-size (Expr) i64 :merge (min old new) )
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(rule ((= expr (Function name tyin tyout out)) 
       (= sum (Expr-size out))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty assum))) 
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Top op x y z))
       (= sum (+ (Expr-size z) (+ (Expr-size y) (Expr-size x)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Bop op x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i)) 
       (= sum (Expr-size tup))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred inputs branches)) 
       (= sum  (+ (Expr-size inputs) (+ (ListExpr-size branches) (Expr-size pred)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred inputs then else)) 
       (= sum (+ (Expr-size inputs) (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output)) 
       (= sum (+ (Expr-size pred-and-output) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty assum))) 
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg)) 
       (= sum (Expr-size arg))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty assum)) ((set (Expr-size (Empty ty assum)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl)) 
       (= sum (+ (ListExpr-size tl) (Expr-size hd)))) 
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil)) 
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc id e state ty)) ;; do state edge's expr should be counted?
        (= sum (Expr-size e))) 
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

;; Like Subst but for dropping inputs to a region
;; See subst.egg for more implementation documentation

(ruleset drop)
(ruleset apply-drop-unions)
(ruleset cleanup-drop)

;; (DropAt ctx idx in) removes all references to `(Get (Arg ...) idx)` in `in`.
;; It also replaces the leaf contexts with `ctx` and fixes up argument types,
;; as well as updating `(Get (Arg ...) j)` to `(Get (Arg ...) (- j 1))` for j > idx.
(constructor DropAt (Assumption i64 Expr) Expr :unextractable)
(constructor DelayedDropUnion (Expr Expr) Expr :unextractable)

;; Helper that precomputes the arg type that we need
(constructor DropAtInternal (Type Assumption i64 Expr) Expr :unextractable)
(rule ((= lhs (DropAt ctx idx in))
       (HasArgType in (TupleT oldty)))

      ((let newty (TupleT (TypeListRemoveAt oldty idx)))
       (union lhs (DropAtInternal newty ctx idx in)))
      :ruleset drop)

;; Leaves
(rule ((= lhs (DropAtInternal newty newctx idx (Const c oldty oldctx))))
      ((DelayedDropUnion lhs (Const c newty newctx)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Empty oldty oldctx))))
      ((DelayedDropUnion lhs (Empty newty newctx)))
      :ruleset drop)
; get stuck on purpose if `i = idx` or if we find a bare `Arg`
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (< i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) i)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (> i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) (- i 1))))
      :ruleset drop)

;; Operators
(rule ((= lhs (DropAtInternal newty newctx idx (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedDropUnion lhs (Top op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            (DropAtInternal newty newctx idx c3))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedDropUnion lhs (Bop op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedDropUnion lhs (Uop op
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; this is okay because we get stuck at `Arg`s
(rule ((= lhs (DropAtInternal newty newctx idx (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedDropUnion lhs (Get
            (DropAtInternal newty newctx idx c1)
            index)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedDropUnion lhs (Alloc id
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            ty)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedDropUnion lhs (Call name
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; Tuple operators
(rule ((= lhs (DropAtInternal newty newctx idx (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedDropUnion lhs (Single
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedDropUnion lhs (Concat
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

;; Control flow
(rule ((= lhs (DropAtInternal newty newctx idx (Switch pred inputs c1)))
       (ExprIsResolved (Switch pred inputs c1)))
      ((DelayedDropUnion lhs (Switch
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (If pred inputs c1 c2)))
       (ExprIsResolved (If pred inputs c1 c2)))
      ((DelayedDropUnion lhs (If
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1
            c2)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedDropUnion lhs (DoWhile
            (DropAtInternal newty newctx idx in)
            out)))
      :ruleset drop)

(rewrite (DropAtInternal newty newctx idx (Function name inty outty body))
         (Function name inty outty (DropAtInternal newty newctx idx body))
         :when ((ExprIsResolved body))
         :ruleset drop)



;; ########################### Apply drop unions

(rule ((DelayedDropUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-drop-unions)

;; ########################### Cleanup Dropat, DropAtInternal and DelayedDropUnion

(rule ((ExprIsResolved (DropAt newctx idx in)))
      ((subsume (DropAt newctx idx in)))
      :ruleset cleanup-drop)

(rule ((ExprIsResolved (DropAtInternal newty newctx idx in)))
      ((subsume (DropAtInternal newty newctx idx in)))
      :ruleset cleanup-drop)

(rule ((DelayedDropUnion lhs rhs))
      ((subsume (DelayedDropUnion lhs rhs)))
      :ruleset cleanup-drop)

(ruleset interval-analysis)
(ruleset interval-rewrite)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (Dead) ;; a bound on dead code, so any value can be chosen
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :merge (bound-max old new))
(function hi-bound (Expr) Bound :merge (bound-min old new))

; if lo > hi, we have proven that this code is dead (as long as all our rules are sound)
; In this case, interval analysis might start going crazy and fail to saturate
; So we immediately set the bounds to (Dead)
(rule (
         (= (IntB lo) (lo-bound expr))
         (= (IntB hi) (hi-bound expr))
         (> lo hi)
       ) 
       ((set (lo-bound expr) (Dead))
        (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)
(rule (
      (= (BoolB true) (lo-bound expr))
      (= (BoolB false) (hi-bound expr))
      ) 
      ((set (lo-bound expr) (Dead))
       (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)
(rewrite (bound-max (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-max anything (Dead))
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min anything (Dead))
         (Dead)
         :ruleset interval-analysis)

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (lo-bound lhs) (IntB (+ la lb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (IntB (+ ha hb))))
      :ruleset interval-analysis)

; - a b interval is (- la hb) (- ha lb)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (lo-bound lhs) (IntB (- la hb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (hi-bound lhs) (IntB (- ha lb))))
      :ruleset interval-analysis)

; Multiplication for two constants
; TODO: Make fancier interval analysis
(rule (
       (= lhs (Bop (Mul) a b))
       (= (IntB x) (lo-bound a))
       (= (IntB x) (hi-bound a))
       (= (IntB y) (lo-bound b))
       (= (IntB y) (hi-bound b))
      )
      (
       (set (lo-bound lhs) (IntB (* x y)))
       (set (hi-bound lhs) (IntB (* x y)))
      )
      :ruleset interval-analysis)

; negative * negative is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (< hi-x 0)
        (< hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; negative * positive is negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (< hi-x 0) ; x < 0 (x is negative)
        (> lo-y 0) ; y > 0 (y is positive)
      )
      ((set (hi-bound lhs) (IntB -1)))
      :ruleset interval-analysis)

; positive * positive is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (> lo-x 0)
        (> lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; non-positive * non-positive is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (<= hi-x 0)
        (<= hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-positive * non-negative is non-positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (<= hi-x 0) ; x <= 0 (x is non-positive)
        (>= lo-y 0) ; y >= 0 (y is non-negative)
      )
      ((set (hi-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-negative * non-negative is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (>= lo-x 0)
        (>= lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      (
       (set (lo-bound lhs) (BoolB (bool-< ha lb)))
      )
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (BoolB (bool-< la hb))))
      :ruleset interval-analysis)

; Abs
; abs(x) = x if x >= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB lx) (lo-bound x))
        (>= lx 0)
      )
      ((union lhs x))
      :ruleset interval-rewrite)

; abs(x) = -x if x <= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB hx) (hi-bound x))
        (<= hx 0)
        (HasArgType lhs ty)
        (ContextOf lhs ctx)
      )
      ((union lhs (Bop (Sub) (Const (Int 0) ty ctx) x)))
      :ruleset interval-rewrite)

; =================================
; Conditionals
; =================================
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-rewrite)

; if the predicate is false, merge with else branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB false) (hi-bound cond))
      )
      ((union lhs (Subst if_ctx inputs els)))
      :ruleset interval-rewrite)

; lo-bound of If is the min of the lower bounds
; hi-bound of If is the max of the upper bounds
(rule (
        (= lhs (If cond inputs thn els))
        (= lo-thn (lo-bound thn))
        (= lo-els (lo-bound els))
      )
      ((set (lo-bound lhs) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound thn))
       (= hi-els (hi-bound els))
      )
      ((set (hi-bound lhs) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; If the If takes a tuple
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was true, so we know expr is at most (hi-bound value) - 1
      ((set (hi-bound (Get ctx i)) (IntB (- v 1))))
      :ruleset interval-analysis)
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was false, so we know expr is at least (lo-bound value)
      ((set (lo-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was true, so we know expr is at least (lo-bound value) + 1
      ((set (lo-bound (Get ctx i)) (IntB (+ v 1)))) 
      :ruleset interval-analysis)
(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was false, so we know expr is at most (hi-bound value)
      ((set (hi-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)

; (if (a == b) thn els)
; in the thn branch, we know that a has the same bounds as b
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx  (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB lo) (lo-bound val))
      )
      ((set (lo-bound (Get ctx i)) (IntB lo)))
      :ruleset interval-analysis)
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB hi) (hi-bound val))
      )
      ((set (hi-bound (Get ctx i)) (IntB hi)))
      :ruleset interval-analysis)


(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)


(ruleset switch_rewrite)
(ruleset always-switch-rewrite)

; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)

; if a < b then b else a ~~> (max a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then b else a
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) j))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) i))
      )
      ((union (Get if_e k) (Bop (Smax) a b)))
      :ruleset switch_rewrite) 

; if pred then a else b ~~> (select pred a b)
; where a and b are inputs to the region
(rule (
       (= if_e (If pred inputs thn els))
       (= a (Get inputs i))
       (= b (Get inputs j))

       ; if pred then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))

       ; If i = j, then the arg is just passed through the if, and we
       ; don't need a select. This will get handled by the passthrough rules.
       (!= i j)
       )
       (
       (union (Get if_e k) (Top (Select) pred a b))
       )
       :ruleset switch_rewrite)

(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)
       (= (Get thn i) (Const x _ty (InIf true pred inputs)))
       (= (Get els i) (Const y _ty (InIf false pred inputs)))
      )
      ((union (Get if_e i) (Top (Select) pred (Const x ty ctx) (Const y ty ctx))))
      :ruleset switch_rewrite)

; if pred then A else Const -> select pred A Const
; where A is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       ; input to the if
       (= a (Get inputs i))
       (= (Get thn k) (Get (Arg _ty (InIf true pred inputs)) i))

       (= els_out (Get els k))
       (= (IntB y) (lo-bound els_out))
       (= (IntB y) (hi-bound els_out))
       )
       (
       (union (Get if_e k) (Top (Select) pred a (Const (Int y) ty ctx)))
       )
       :ruleset switch_rewrite
)

; if pred then Const else B -> select pred Const B
; where B is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       (= thn_out (Get thn k))
       (= (IntB y) (lo-bound thn_out))
       (= (IntB y) (hi-bound thn_out))

       ; input to the if
       (= b (Get inputs i))
       (= (Get els k) (Get (Arg _ty (InIf false pred inputs)) i))
      )
      (
       (union (Get if_e k) (Top (Select) pred (Const (Int y) ty ctx) b))
      )
      :ruleset switch_rewrite
)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf true  a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let inner_X (AddContext (InIf true  inner_pred sub_arg_true) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_true) Y))
       (let outer_Y (Subst      (InIf false a          outer_ins) sub_arg_false Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

; if (a or b) X Y ~~> if a X (if b X Y)
(rule ((= lhs (If (Bop (Or) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf false a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let outer_X (Subst      (InIf true  a          outer_ins) sub_arg_true X))
       (let inner_X (AddContext (InIf true  inner_pred sub_arg_false) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_false) Y))

       (let inner (If inner_pred sub_arg_false inner_X inner_Y))
       (union lhs (If a          outer_ins     outer_X inner  )))

       :ruleset switch_rewrite)

(rewrite (If (Const (Bool true)  ty ctx) ins thn els)
         (Subst ctx ins thn)
         :ruleset always-switch-rewrite)

(rewrite (If (Const (Bool false) ty ctx) ins thn els)
         (Subst ctx ins els)
         :ruleset always-switch-rewrite)

(ruleset select_opt)


;; inlined (Get thn i) makes the query faster ):
(rule
       (
        (= if_e (If pred inputs thn els))

        (ExprIsPure (Get thn i))
        (ExprIsPure (Get els i))
        
        (> 10 (Expr-size (Get thn i))) ; TODO: Tune these size limits
        (> 10 (Expr-size (Get els i)))
        (= (TCPair t1 c1) (ExtractedExpr (Get thn i)))
        (= (TCPair t2 c2) (ExtractedExpr (Get els i)))

        (ContextOf if_e ctx)
       )
       (
        (union (Get if_e i)
               (Top (Select) pred (TermSubst ctx inputs t1) (TermSubst ctx inputs t2)))
       )
       :ruleset select_opt
)
; Simple rewrites that don't do a ton with control flow.

(ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 0) ty ctx)) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) (Const (Int 1) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 1) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int 0) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Add) e (Const (Int 0) ty ctx) ) e :ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (* i j)) ty ctx) :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (+ i j)) ty ctx) :ruleset peepholes)

(rewrite (Bop (And) (Const (Bool true) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool true) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (And) (Const (Bool false) ty ctx) e) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool false) ty ctx)) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool false) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool false) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool true) ty ctx) e) (Const (Bool true) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool true) ty ctx)) (Const (Bool true) ty ctx) :ruleset peepholes)

(rule (
        (= expr (Bop (Sub) x x))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Const (Int 0) ty ctx)))
      :ruleset peepholes)

; (x - y) + z => x + (z - y)
(rewrite (Bop (Add) (Bop (Sub) x y) z) (Bop (Add) x (Bop (Sub) z y)) :ruleset peepholes)

; (a + b) - c => a + (b - c)
(rewrite (Bop (Sub) (Bop (Add) a b) c) (Bop (Add) a (Bop (Sub) b c)) :ruleset peepholes)

; (a * x) + a => a * (x + 1)
(rule (
        (= expr (Bop (Add) (Bop (Mul) a x) a))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Bop (Mul) a (Bop (Add) x (Const (Int 1) ty ctx)))))
      :ruleset peepholes)

(rewrite (Top (Select) pred x x) x :ruleset peepholes)

; constant fold `(x + const1) + const2` even when x is not constant
(rewrite (Bop (Add) (Bop (Add) x (Const (Int i) ty ctx)) (Const (Int j) ty ctx))
         (Bop (Add) x (Const (Int (+ i j)) ty ctx))
         :ruleset peepholes)

; ptradd(ptradd(p, x), y) => ptradd(p, x + y)
(rewrite (Bop (PtrAdd) (Bop (PtrAdd) p x) y)
         (Bop (PtrAdd) p (Bop (Add) x y))
         :ruleset peepholes)

(datatype IntOrInfinity
    (Infinity)
    (NegInfinity)
    (I i64))

(constructor MaxIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MaxIntOrInfinity (Infinity) _) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity _ (Infinity)) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity (NegInfinity) x) x :ruleset always-run)
(rewrite (MaxIntOrInfinity x (NegInfinity)) x :ruleset always-run)
(rewrite (MaxIntOrInfinity (I x) (I y)) (I (max x y)) :ruleset always-run)

(constructor MinIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MinIntOrInfinity (NegInfinity) _) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity _ (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity (Infinity) x) x :ruleset always-run)
(rewrite (MinIntOrInfinity x (Infinity)) x :ruleset always-run)
(rewrite (MinIntOrInfinity (I x) (I y)) (I (min x y)) :ruleset always-run)

(constructor AddIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (AddIntOrInfinity (Infinity) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (Infinity) (I _)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (I _)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I x) (I y)) (I (+ x y)) :ruleset always-run)

(datatype IntInterval (MkIntInterval IntOrInfinity IntOrInfinity))

(constructor UnionIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (UnionIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MinIntOrInfinity lo1 lo2) (MaxIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor IntersectIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (IntersectIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MaxIntOrInfinity lo1 lo2) (MinIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor AddIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (AddIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (AddIntOrInfinity lo1 lo2)
                        (AddIntOrInfinity hi1 hi2))
         :ruleset always-run)


(datatype List<i64+IntInterval> 
  (Nil-List<i64+IntInterval>)
  (Cons-List<i64+IntInterval> i64 IntInterval List<i64+IntInterval>))

(function Length-List<i64+IntInterval> (List<i64+IntInterval>) i64 :no-merge)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((IsEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(relation IsNonEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((IsNonEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(constructor RevConcat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (RevConcat-List<i64+IntInterval> (Nil-List<i64+IntInterval>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<i64+IntInterval> (Cons-List<i64+IntInterval> hd0 hd1 tl) l)
         (RevConcat-List<i64+IntInterval> tl (Cons-List<i64+IntInterval> hd0 hd1 l))
         :ruleset always-run)

(constructor Rev-List<i64+IntInterval> (List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Rev-List<i64+IntInterval> m)
         (RevConcat-List<i64+IntInterval> m (Nil-List<i64+IntInterval>))
         :ruleset always-run)

(constructor Concat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Concat-List<i64+IntInterval> x y)
         (RevConcat-List<i64+IntInterval> (Rev-List<i64+IntInterval> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<i64+IntInterval> (List<i64+IntInterval>))
(relation SuffixAt-List<i64+IntInterval> (List<i64+IntInterval> i64 List<i64+IntInterval>))
(relation At-List<i64+IntInterval> (List<i64+IntInterval> i64 i64 IntInterval))
(rule ((DemandAt-List<i64+IntInterval> x))
      ((SuffixAt-List<i64+IntInterval> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<i64+IntInterval> x i (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((SuffixAt-List<i64+IntInterval> x (+ i 1) tl)
       (At-List<i64+IntInterval> x i hd0 hd1))
      :ruleset always-run)

(constructor Union-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor UnionHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Union-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (UnionHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; both m1 and m2 empty
  (rewrite (UnionHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)
  ; take from m1 when m2 empty and vice versa
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      res)
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      tl
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      (Nil-List<i64+IntInterval>)
      res)
    (UnionHelper-List<i64+IntInterval>
      tl
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)

  ; when both nonempty and smallest key different, take smaller key
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 l2 (Cons-List<i64+IntInterval> k1 a1 res))))
        :ruleset always-run)
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f
           (UnionHelper-List<i64+IntInterval> l1 tl2 (Cons-List<i64+IntInterval> k2 b1 res))))
        :ruleset always-run)

  ; when shared smallest key, union interval
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 tl2
             (Cons-List<i64+IntInterval> k (UnionIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor Intersect-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor IntersectHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Intersect-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (IntersectHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; m1 or m2 empty
  (rewrite (IntersectHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) m2 res)
           res
           :ruleset always-run)
  (rewrite (IntersectHelper-List<i64+IntInterval> m1 (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)

  ; when both nonempty and smallest key different, drop smaller key
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)

(datatype MyBool (MyTrue) (MyFalse))

(constructor IntIntervalValid (IntInterval) MyBool)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyTrue)
         :when ((<= lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyFalse)
         :when ((> lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (NegInfinity) _))
         (MyTrue)
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval _ (Infinity)))
         (MyTrue)
         :ruleset always-run)

(constructor ConsIfNonEmpty (i64 IntInterval List<i64+IntInterval>)
          List<i64+IntInterval>
          :cost 100)
(rule ((ConsIfNonEmpty k v tl))
      ((IntIntervalValid v))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyTrue) (IntIntervalValid v)))
      ((union f (Cons-List<i64+IntInterval> k v tl)))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyFalse) (IntIntervalValid v)))
      ((union f tl))
      :ruleset always-run)

  ; when shared smallest key, intersect interval
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (IntersectHelper-List<i64+IntInterval> tl1 tl2
             (ConsIfNonEmpty k (IntersectIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor AddIntIntervalToAll (IntInterval List<i64+IntInterval>)
                              List<i64+IntInterval>)
(rewrite (AddIntIntervalToAll _ (Nil-List<i64+IntInterval>))
         (Nil-List<i64+IntInterval>)
         :ruleset always-run)
(rewrite (AddIntIntervalToAll x (Cons-List<i64+IntInterval> allocid offset tl))
         (Cons-List<i64+IntInterval> allocid (AddIntInterval x offset)
           (AddIntIntervalToAll x tl))
         :ruleset always-run)

(datatype PtrPointees
  (PointsTo List<i64+IntInterval>)
  (PointsAnywhere))

(constructor AddIntIntervalToPtrPointees (IntInterval PtrPointees) PtrPointees)
(rewrite (AddIntIntervalToPtrPointees interval (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (AddIntIntervalToPtrPointees interval (PointsTo l))
         (PointsTo (AddIntIntervalToAll interval l))
         :ruleset always-run)

(constructor Union-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Union-PtrPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Union-List<i64+IntInterval> x y))
         :ruleset always-run)
(constructor Intersect-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Intersect-PtrPointees (PointsAnywhere) x)
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees x (PointsAnywhere))
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Intersect-List<i64+IntInterval> x y))
         :ruleset always-run)

(relation PointsNowhere-PtrPointees (PtrPointees))
(rule ((= f (PointsTo x))
       (IsEmpty-List<i64+IntInterval> x))
      ((PointsNowhere-PtrPointees f))
      :ruleset always-run)


(datatype List<PtrPointees> 
  (Nil-List<PtrPointees>)
  (Cons-List<PtrPointees> PtrPointees List<PtrPointees>))

(function Length-List<PtrPointees> (List<PtrPointees>) i64 :no-merge)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((IsEmpty-List<PtrPointees> x))
      :ruleset always-run)

(relation IsNonEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Cons-List<PtrPointees> hd0 tl)))
      ((IsNonEmpty-List<PtrPointees> x))
      :ruleset always-run)

(constructor RevConcat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (RevConcat-List<PtrPointees> (Nil-List<PtrPointees>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<PtrPointees> (Cons-List<PtrPointees> hd0 tl) l)
         (RevConcat-List<PtrPointees> tl (Cons-List<PtrPointees> hd0 l))
         :ruleset always-run)

(constructor Rev-List<PtrPointees> (List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Rev-List<PtrPointees> m)
         (RevConcat-List<PtrPointees> m (Nil-List<PtrPointees>))
         :ruleset always-run)

(constructor Concat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Concat-List<PtrPointees> x y)
         (RevConcat-List<PtrPointees> (Rev-List<PtrPointees> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<PtrPointees> (List<PtrPointees>))
(relation SuffixAt-List<PtrPointees> (List<PtrPointees> i64 List<PtrPointees>))
(relation At-List<PtrPointees> (List<PtrPointees> i64 PtrPointees))
(rule ((DemandAt-List<PtrPointees> x))
      ((SuffixAt-List<PtrPointees> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<PtrPointees> x i (Cons-List<PtrPointees> hd0 tl)))
      ((SuffixAt-List<PtrPointees> x (+ i 1) tl)
       (At-List<PtrPointees> x i hd0))
      :ruleset always-run)

(relation All<PointsNowhere-PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (PointsNowhere-PtrPointees hd0)
       (All<PointsNowhere-PtrPointees> tl))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
        


(constructor Zip<Union-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Union-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Union-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Union-PtrPointees x0 y0)
            (Zip<Union-PtrPointees> tl1 tl2))
         :when ((= (Length-List<PtrPointees> tl1) (Length-List<PtrPointees> tl2)))
         :ruleset always-run)

(constructor Zip<Intersect-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Intersect-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Intersect-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Intersect-PtrPointees x0 y0)
            (Zip<Intersect-PtrPointees> tl1 tl2))
         :ruleset always-run)


(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(constructor ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset memory-helpers)
(constructor ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset memory-helpers)
(relation ExprSet-contains (ExprSet Expr))
(constructor ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset memory-helpers)
(function ExprSet-length (ExprSet) i64 :no-merge)


; ============================
; Pointees
; ============================


; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))

(constructor UnwrapPtrPointsTo (Pointees) PtrPointees)
(rewrite (UnwrapPtrPointsTo (PtrPointsTo x))
         x
         :ruleset memory-helpers)
(constructor UnwrapTuplePointsTo (Pointees) List<PtrPointees>)
(rewrite (UnwrapTuplePointsTo (TuplePointsTo x))
         x
         :ruleset memory-helpers)

(relation PointsNowhere (Pointees))
(rule ((= f (PtrPointsTo x))
       (PointsNowhere-PtrPointees x))
      ((PointsNowhere f))
      :ruleset memory-helpers)
(rule ((= f (TuplePointsTo l))
       (All<PointsNowhere-PtrPointees> l))
      ((PointsNowhere f))
      :ruleset memory-helpers)

(constructor UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Union-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (UnionPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Union-PtrPointees> x y))
         :when ((= (Length-List<PtrPointees> x) (Length-List<PtrPointees> y)))
         :ruleset memory-helpers)
(constructor IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Intersect-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (IntersectPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Intersect-PtrPointees> x y))
         :ruleset memory-helpers)

(constructor GetPointees (Pointees i64) Pointees)
(rule ((= f (GetPointees (TuplePointsTo l) i))
       (At-List<PtrPointees> l i x))
      ((union f (PtrPointsTo x)))
      :ruleset memory-helpers)

(constructor PointeesDropFirst (Pointees) Pointees)
(rewrite (PointeesDropFirst (TuplePointsTo (Cons-List<PtrPointees> hd tl)))
         (TuplePointsTo tl)
         :ruleset memory-helpers)

; ============================
; Resolved
; ============================

; Resolved checks if an e-class contains a term containing only constructors and
; primitives; i.e. whether equality is decideable
(relation Resolved-IntOrInfinity (IntOrInfinity))
(rule ((= f (I _)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (Infinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (NegInfinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)

(relation Resolved-IntInterval (IntInterval))
(rule ((= f (MkIntInterval lo hi))
       (Resolved-IntOrInfinity lo)
       (Resolved-IntOrInfinity hi))
      ((Resolved-IntInterval f))
      :ruleset memory-helpers)

(relation Resolved-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= f (Nil-List<i64+IntInterval>)))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<i64+IntInterval> allocid offsets tl))
       (Resolved-List<i64+IntInterval> tl)
       (Resolved-IntInterval offsets))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)

(relation Resolved-PtrPointees (PtrPointees))
(rule ((= f (PointsAnywhere)))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)
(rule ((= f (PointsTo x))
       (Resolved-List<i64+IntInterval> x))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)

(relation Resolved-List<PtrPointees> (List<PtrPointees>))
(rule ((= f (Nil-List<PtrPointees>)))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<PtrPointees> hd tl))
       (Resolved-List<PtrPointees> tl)
       (Resolved-PtrPointees hd))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)

(relation Resolved-Pointees (Pointees))
(rule ((= f (TuplePointsTo x))
       (Resolved-List<PtrPointees> x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)
(rule ((= f (PtrPointsTo x))
       (Resolved-PtrPointees x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)


;;;;;

(constructor BaseTypeToPtrPointees (BaseType) PtrPointees :cost 100)
(rewrite (BaseTypeToPtrPointees (PointerT _))
         (PointsAnywhere)
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (IntT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (StateT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (BoolT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)

(constructor TypeListToList<PtrPointees> (TypeList) List<PtrPointees> :cost 1000)
(rewrite (TypeListToList<PtrPointees> (TNil))
         (Nil-List<PtrPointees>)
         :ruleset memory-helpers)
(rewrite (TypeListToList<PtrPointees> (TCons hd tl))
         (Cons-List<PtrPointees>
            (BaseTypeToPtrPointees hd)
            (TypeListToList<PtrPointees> tl))
         :ruleset memory-helpers)

(constructor TypeToPointees (Type) Pointees :cost 1000)
(rewrite (TypeToPointees (TupleT tylist))
         (TuplePointsTo (TypeListToList<PtrPointees> tylist))
         :ruleset memory-helpers)
(rewrite (TypeToPointees (Base basety))
         (PtrPointsTo (BaseTypeToPtrPointees basety))
         :ruleset memory-helpers)

; ============================
; Update PointerishType
; ============================

(relation PointerishType (Type))
(relation PointerishTypeList (TypeList))

(rule ((= f (Base (PointerT ty))))
      ((PointerishType f))
      :ruleset always-run)

(rule ((= f (TCons (PointerT ty) tl)))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TCons hd tl))
       (PointerishTypeList tl))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TupleT l))
       (PointerishTypeList l))
      ((PointerishType f))
      :ruleset always-run)

; ============================
; Update PointsToCells
; ============================

;                             arg pointees  result pointees
(constructor PointsToCells (Expr Pointees)     Pointees :unextractable) 

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (TypeToPointees in-ty)))
      :ruleset memory-helpers)

; Demand PointsToCells along state edge and pointer-typed values
(rule ((PointsToCells (Bop (Print) e state) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Top (Write) ptr val state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Alloc id sz state ty) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Free) ptr state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Get x i) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Concat x y) ap))
      ((PointsToCells x ap)
       (PointsToCells y ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Single x) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)

; Compute and propagate PointsToCells
(rewrite (PointsToCells concat-x-y aps)
         (TuplePointsTo (Concat-List<PtrPointees>
           (UnwrapTuplePointsTo (PointsToCells x aps))
           (UnwrapTuplePointsTo (PointsToCells y aps))))
         :when ((= concat-x-y (Concat x y))
                (HasType concat-x-y ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells get-x-i aps)
         (GetPointees (PointsToCells x aps) i)
         :when ((= get-x-i (Get x i))
                (HasType get-x-i ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Single x) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (UnwrapPtrPointsTo (PointsToCells x aps))
             (Nil-List<PtrPointees>)))
         :when ((HasType (Single x) ty) (PointerishType ty))
         :ruleset memory-helpers) 

(rewrite (PointsToCells (Arg ty_ ctx) aps)
         aps
         :when ((HasType (Arg ty_ ctx) ty) (PointerishType ty))
         :ruleset memory-helpers)

; Allow non-pointer types to resolve
(rule ((PointsToCells x aps)
       (HasType x ty))
      ((TypeToPointees ty))
      :ruleset memory-helpers)
(rule ((= f (PointsToCells x aps))
       (HasType x ty)
       (= pointees (TypeToPointees ty))
       (PointsNowhere pointees))
      ((union f pointees))
      :ruleset memory-helpers)

(rewrite (PointsToCells (Bop (PtrAdd) x e) aps)
         (PtrPointsTo
           (AddIntIntervalToPtrPointees
             (MkIntInterval (I lo) (I hi))
             (UnwrapPtrPointsTo (PointsToCells x aps))))
         :when ((= (IntB lo) (lo-bound e))
                (= (IntB hi) (hi-bound e)))
         :ruleset memory-helpers)

(rewrite (PointsToCells (If c inputs t e) aps)
         (UnionPointees
           (PointsToCells t (PointsToCells inputs aps))
           (PointsToCells e (PointsToCells inputs aps)))
         :when ((HasType (If c inputs t e) ty) (PointerishType ty))
         :ruleset memory)

(rewrite (PointsToCells (Alloc id sz state ty) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (PointsTo
               (Cons-List<i64+IntInterval>
                 id
                 (MkIntInterval (I 0) (I 0))
                 (Nil-List<i64+IntInterval>)))
             (Cons-List<PtrPointees>
               (PointsTo (Nil-List<i64+IntInterval>)) ; state output points to nothing
               (Nil-List<PtrPointees>))))
         :ruleset memory-helpers)

; arg pointees * loop in * loop out * i64 -> result pointees
(constructor PointsToCellsAtIter (Pointees Expr Expr i64) Pointees)

; compute first two
(rule ((= e (DoWhile inputs pred-body))
       (PointsToCells e aps))
      ((set (PointsToCellsAtIter aps inputs pred-body 0)
            (PointsToCells inputs aps))
       (set (PointsToCellsAtIter aps inputs pred-body 1)
            (UnionPointees
              (PointsToCellsAtIter aps inputs pred-body 0)
              (PointeesDropFirst
                (PointsToCells pred-body (PointsToCellsAtIter aps inputs pred-body 0))))))
      :ruleset memory-helpers)

; avoid quadratic query
(function succ (i64) i64 :no-merge)
(rule ((PointsToCellsAtIter aps inputs pred-body i))
      ((set (succ i) (+ i 1)))
      :ruleset memory-helpers)

; Note that this rule is bounded by ruleset memory
(rule ((= pointees0 (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees1 (PointsToCellsAtIter aps inputs pred-body (succ i)))
       (Resolved-Pointees pointees0)
       (Resolved-Pointees pointees1)
       (!= pointees0 pointees1))
      ((set (PointsToCellsAtIter aps inputs pred-body (+ i 2))
            (UnionPointees
              pointees1
              (PointeesDropFirst
                (PointsToCells pred-body pointees1)))))
      :ruleset memory)

(rule ((= pointees (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees (PointsToCellsAtIter aps inputs pred-body (succ i))))
      ((set (PointsToCells (DoWhile inputs pred-body) aps)
            pointees))
      :ruleset memory)

(rule ((PtrPointsTo (PointsTo l)))
      ((DemandAt-List<i64+IntInterval> l))
      :ruleset memory-helpers)
(rule ((TuplePointsTo l))
      ((DemandAt-List<PtrPointees> l))
      :ruleset memory-helpers)

; ============================
; Update DontAlias
; ============================

(relation DemandDontAlias (Expr Expr Pointees))
;                    pointer, pointer, arg pointees
(relation DontAlias (Expr Expr Pointees))


(rule ((DemandDontAlias ptr1 ptr2 arg-pointees)
       (BodyContainsExpr body ptr1)
       (BodyContainsExpr body ptr2)
       (HasType ptr1 (Base (PointerT ty)))
       (HasType ptr2 (Base (PointerT ty)))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset memory-helpers)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((DontAlias ptr1 ptr2 arg-pointees))
      :ruleset memory-helpers)

; ============================
; Update PointsToExpr
; ============================

;                       program point, pointer
(constructor PointsToExpr (Expr           Expr) Expr :unextractable)

; After a load, the ptr points to the loaded value
(rule ((= f (Bop (Load) ptr state)))
      ((set (PointsToExpr (Get f 1) ptr) (Get f 0)))
      :ruleset memory-helpers)

; If we load and we already know what the pointer points to
; TODO this rule breaks the weakly linear invariant
; when a previous load may not be on the path
;(rule ((= e (Bop (Load) addr state))
;       (= v (PointsToExpr state addr)))
;      ((union (Get e 0) v)
;       (union (Get e 1) state))
;       :ruleset memory-helpers)

; Loads and prints don't affect what what pointers already point to
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Load) any-addr state)))
      ((let new-state (Get e 1))
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Print) any-val state)))
      ((let new-state e)
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)

; Writes don't affect what a pointer points to if it writes to another pointer
; guaranteed to not alias.
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr)))
      ((DemandDontAlias addr otheraddr (TypeToPointees argty)))
      :ruleset memory-helpers)
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr))
       (DontAlias addr otheraddr (TypeToPointees argty)))
      ((set (PointsToExpr e otheraddr) otherdata))
      :ruleset memory-helpers)

; For a write, mark the given expression as containing `data`.
(rule ((= e (Top (Write) addr data state)))
      ((union (PointsToExpr e addr) data))
      :ruleset memory-helpers)

; ============================
; Update CellHasValues (currently unused)
; ============================

; ;                       program point, cell
; (constructor CellHasValues (Expr i64) ExprSet :merge (ExprSet-intersect old new))

; ; At the time of an alloc, a cell doesn't contain any values
; (rule ((= f (Alloc id amt state ty)))
      ; ((set (CellHasValues (Get f 1) id) (ES (set-empty))))
      ; :ruleset memory-helpers)

; ; These two rules find (Write ptr val state) where 
; ; ptr points to cells given no assumptions about where (Arg) points.
; ; TODO: make sensitive to offsets
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty))
      ; ((TypeToPointees argty))
      ; :ruleset memory-helpers)
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty)
       ; (= (PtrPointsTo (PointsTo cells)) (PointsToCells ptr (TypeToPointees argty)))
       ; (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       ; (= vals (CellHasValues state cell)))
      ; ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      ; :ruleset memory-helpers)


(ruleset mem-simple)

; ============================
; NoAlias analysis
; ============================

(relation NoAlias (Expr Expr))

; Push NoAlias into if
(rule ((= if (If pred inputs thn els))
       (= (Get inputs i) inputs-i)
       (= (Get inputs j) inputs-j)
       (NoAlias inputs-i inputs-j)
       (= arg-i (Get (Arg ty (InIf which pred inputs)) i))
       (= arg-j (Get (Arg ty (InIf which pred inputs)) j)))
      ((NoAlias arg-i arg-j))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (lo-bound i) (IntB lo))
       (> lo 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (hi-bound i) (IntB hi))
       (< hi 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((NoAlias x y))
      ((NoAlias y x))
      :ruleset mem-simple)

; ============================
; Memory optimizations
; ============================

(relation DidMemOptimization (String))

; A write then a load to different addresses can be swapped
(rule ((NoAlias write-addr load-addr)
       (= write (Top (Write) write-addr write-val state))
       (= load (Bop (Load) load-addr write)))
      ((let new-load (Bop (Load) load-addr state))
       (union
          (Get load 1)
          (Top (Write) write-addr write-val (Get new-load 1)))
       (union (Get load 0) (Get new-load 0))
       (DidMemOptimization "commute write then load")
      )
      :ruleset mem-simple)

; A load then a write to different addresses can be swapped
; Actually, does this break WeaklyLinear if the stored value depends on the
; loaded value? Commenting this out for now.
; (rule ((NoAlias load-addr write-addr)
;        (= load (Bop (Load) load-addr state))
;        (= write (Top (Write) write-addr write-val (Get load 1))))
;       ((let new-write (Top (Write) write-addr write-val state))
;        (let new-load (Bop (Load) load-addr new-write))
;        (union write (Get new-load 1))
;        (union (Get load 0) (Get new-load 0))
;        (DidMemOptimization "commute load then write")
;        )
;       :ruleset mem-simple)

; Two loads to the same address can be compressed
(rule ((= first-load (Bop (Load) addr state))
       (= second-load (Bop (Load) addr first-load)))
      ((union (Get first-load 0) (Get second-load 0))
       (union (Get first-load 1) (Get second-load 1))
       (DidMemOptimization "duplicate load")
       )
      :ruleset mem-simple)

; A write and a load to the same address can be forwarded
(rule ((= write (Top (Write) addr write-val state))
       (= load (Bop (Load) addr write)))
      ((union (Get load 0) write-val)
       (union (Get load 1) write)
       (DidMemOptimization "store forward")
       )
      :ruleset mem-simple)

; Two writes of the same value to the same address can be compressed
(rule ((= first-write (Top (Write) addr write-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union first-write second-write)
       (DidMemOptimization "duplicate write"))
      :ruleset mem-simple)

; A write shadows a previous write to the same address
(rule ((= first-write (Top (Write) addr shadowed-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union second-write (Top (Write) addr write-val state))
       (DidMemOptimization "shadowed write"))
      :ruleset mem-simple)

; A load doesn't change the state
; TODO: why does this break weaklylinear?
; (rule ((= load (Bop (Load) addr state)))
;       ((union (Get load 1) state))
;       :ruleset mem-simple)

; (rule ((DidMemOptimization _))
;       ((panic "DidMemOptimization"))
;       :ruleset mem-simple)

;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)


(function hoisted-loop (Expr Expr) bool :merge (or old new) )
(rule ((= loop (DoWhile in pred_out)))
      ((set (hoisted-loop in pred_out) false)) :ruleset always-run)

(constructor InExtendedLoop (Expr Expr Expr) Assumption)

;; mock function
(ruleset loop-inv-motion)

(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in pred_out))
       ;; the outter assumption of the loop 
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= false (hoisted-loop in pred_out))
       (= len (tuple-length in)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))

       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (InExtendedLoop in pred_out new_input))
       (let new_out_branch (Get (Arg new_input_type assum) len))

       ;; this two subst only change arg to arg with new type
       (let substed_pred_out
         (Subst assum
               (SubTuple (Arg new_input_type assum) 0 len) pred_out))
       (let inv_in_new_loop
            (Subst assum (SubTuple (Arg new_input_type assum) 0 len) inv))
       (let new_pred_out (Concat substed_pred_out (Single new_out_branch)))
       
       (let new_loop (DoWhile new_input new_pred_out))
       (union assum (InLoop new_input new_pred_out))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in pred_out)) 
       ;; don't hoist same loop again
       (set (hoisted-loop in pred_out) true)
      )
       :ruleset loop-inv-motion)


(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Const _n _ty _ctx)))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get (Arg ty ctx) i)) 
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out (+ i 1)))) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Function _name _tyin _tyout _out))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Top _op _x _y _z))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) (= true (is-inv-Expr loop _z)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Bop _op _x _y)) (BinaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Uop _op _x)) (UnaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get _tup _i))  
       (= true (is-inv-Expr loop _tup)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Concat _x _y))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Single _x))  
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Switch _pred _inputs _branches))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _inputs)) (= true (is-inv-ListExpr loop _branches)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (If _pred _input _then _else))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _input)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (DoWhile _in _pred-and-output))  
       (= true (is-inv-Expr loop _in)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Call _func _arg))  
       (= true (is-inv-Expr loop _arg)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Empty _ty _ctx))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _z)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Uop _op _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Single _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _inputs)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _input)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (DoWhile _in _pred-and-output)) 
       (= expr1 _in)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Call _func _arg)) 
       (= expr1 _arg)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _e)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _state)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty ctx)
  (Concat (Single (Const (Bool false) ty ctx2))
    (Single (Const constant ty ctx2))))
 (Single (Const constant ty ctx))
 :ruleset loop-simplify)
;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)

;;                      inputs, outputs -> number of iterations
;; The minimum possible guess is 1 because of do-while loops
;; TODO: dead loop deletion can turn loops with a false condition to a body
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset loop-iters-analysis)

;; For a loop that is false, its num iters is 1
(rule 
  ((= loop (DoWhile inputs outputs))
   (= (Const (Bool false) ty ctx) (Get outputs 0)))
  ((set (LoopNumItersGuess inputs outputs) 1))
:ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated before checking pred
;; TODO: we could make it work for decrementing loops
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by some constant each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while next_counter less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (/ (- end_constant start_const) increment))
  )
  :ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated after checking pred
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   (= body-arg (Get (Arg _ty _ctx) counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by a constant each loop
   (= next_counter (Bop (Add) body-arg
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while this counter less than end_constant
   (= pred (Bop (LessThan) body-arg
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (+ (/ (- end_constant start_const) increment) 1))
  )
  :ruleset loop-iters-analysis)

;; loop peeling rule
;; Only peel loops that we know iterate < 3 times
(constructor LoopPeeledPlaceholder (Expr) Assumption :unextractable)
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs))
  (< old_cost 3)
  )
 (
  (let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))

  (let new-loop-arg
    (Arg inputs-ty then-ctx))
  (let new-loop-body
    (Subst (LoopPeeledPlaceholder lhs) new-loop-arg outputs))
  (union (InLoop new-loop-arg new-loop-body) (LoopPeeledPlaceholder lhs))

  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
      executed-once-body ;; inputs are the body executed once
      (DoWhile new-loop-arg new-loop-body)
      (Arg inputs-ty else-ctx)))

  (set (LoopNumItersGuess new-loop-arg new-loop-body) (- old_cost 1))
  )
 :ruleset loop-peel)

(constructor TmpCtxUnroll (Expr Expr) Assumption)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let tmp-ctx (TmpCtxUnroll inputs outputs))
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst tmp-ctx one-iter
          (Subst tmp-ctx one-iter
            (Subst tmp-ctx one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union tmp-ctx actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
  )
  :ruleset loop-unroll)



(ruleset swap-if)

;; swaps the order of the then and else branches
;; in an if using Not

(rule
  ((= lhs (If pred inputs then else)))
  (
    (union lhs (If (Uop (Not) pred) inputs else then))
  )
  :ruleset swap-if)


;; for if statements with two outputs, swaps the order
;; of the outputs
(rule
  ((= lhs (If pred inputs then else))
   (= (tuple-length then) 2)
   (= (tuple-length else) 2))
  (
    (union
      (Concat (Single (Get lhs 1)) (Single (Get lhs 0)))
      (If pred inputs
          (Concat (Single (Get then 1)) (Single (Get then 0)))
          (Concat (Single (Get else 1)) (Single (Get else 0)))))
  )
  :ruleset swap-if)
;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;      } while (start[0]);
;;    }
;;    ret base_case(start);
;; }
;; for example, printBinary sums the results of recursive calls

(constructor TmpCtxRecToLoop (String Type Type Expr) Assumption)
(rule
  ((Function name in out body)
   (= body (If pred always-runs (Call name rec_case) base-case))
   (HasType always-runs start-ty)
   (HasType body func-ty))
  ((let tmp-ctx (TmpCtxRecToLoop name in out body))
   (let loop-inputs (Arg start-ty (InIf true pred always-runs)))
   (let loop-outputs
     (Concat
         (Single (Subst tmp-ctx rec_case pred))
         (Subst tmp-ctx rec_case always-runs)))
   (union tmp-ctx (InLoop loop-inputs loop-outputs))

   (let loop
     (DoWhile loop-inputs loop-outputs))
    
    
  ;; initial start value
   (let outer-if
     (If pred always-runs
         loop
         (Arg start-ty (InIf false pred always-runs))))
   (union body (Subst (InFunc name) outer-if base-case)))
  :ruleset rec-to-loop)


;; Stores information about how to use a binary
;; operator to accumulate values
;; (bop start-val base-case-op)
(relation Accum-Bop (BinaryOp i64 BinaryOp))

;; addition is easy, it starts at 0 and adds the result of the recursive call
(Accum-Bop (Add) 0 (Add))

;; subtraction starts at zero, but adds the base case at the end
(Accum-Bop (Sub) 0 (Add))

;; multiplication starts at 1, and multiplies the result of the recursive call
(Accum-Bop (Mul) 1 (Mul))

;; It seems like integers have these properties based on: https://stackoverflow.com/questions/69480173/which-arithmetic-properties-do-twos-complement-integers-have


;; same as above rule, but with an accumulator
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start)) + f(start);
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    let acc = 0;
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;         acc = acc + extra(start);
;;      } while (start[0]);
;;    }
;;    ret base_case(start) + acc;
;; }
(constructor TmpCtxRecToLoop2 (String Expr Expr Expr) Assumption)
(rule
  ((Function name in out body)
   (= body (If pred always-runs then-case base-case))
   (= call (Call name rec-case))
   (= then-case
      (Concat (Single (Bop acc-op (Get call 0) extra))
              (Single (Get call 1))))
   (Accum-Bop acc-op initial-int base-case-op)
   (HasType always-runs start-ty)
   (= always-runs-len (tuple-length always-runs))
   (= start-ty (TupleT start-ty-list))
   (HasType body func-ty))
  ((let tmp-ctx (TmpCtxRecToLoop2 name pred then-case base-case))
   (let loop-ty
     (TupleT (TLConcat start-ty-list (TCons (IntT) (TNil)))))
   ;; recursive case in the loop
   (let new-rec-case
    (Subst tmp-ctx
           (SubTuple (Arg loop-ty tmp-ctx) 0 always-runs-len) rec-case))
   ;; extra computation in the loop
   (let new-extra
    (Subst tmp-ctx
           (SubTuple (Arg loop-ty tmp-ctx) 0 always-runs-len) extra))
   ;; acc starts at 0
   (let loop-inputs
     (Concat (Arg start-ty (InIf true pred always-runs)) (Single (Const (Int initial-int) start-ty (InIf true pred always-runs)))))
   (let loop-outputs
     (Concat
         (Single (Subst tmp-ctx new-rec-case pred))
         (Concat
           (Subst tmp-ctx new-rec-case always-runs)
           ;; add extra to acc
           (Single (Bop acc-op (Get (Arg loop-ty tmp-ctx) always-runs-len) new-extra)))))
   ;; loop starts at zero, adds extra each iteration
   (let loop
     (DoWhile loop-inputs loop-outputs))
   ;; union tmpctx
   (union tmp-ctx (InLoop loop-inputs loop-outputs))
  
   (let outer-if
     (If pred always-runs
         loop
         (Concat
           (Arg start-ty (InIf false pred always-runs))
           ;; otherwise acc is 0
           (Single (Const (Int 0) start-ty (InIf false pred always-runs))))))
   ;; base case over latest start value
   (let new-base-case
     (Subst (InFunc name) (SubTuple outer-if 0 always-runs-len) base-case))
   ;; add base case to acc
   (let res
     (Concat
      (Single (Bop base-case-op (Get new-base-case 0) (Get outer-if always-runs-len)))
      (Single (Get new-base-case 1))))
   (union body res))
  :ruleset rec-to-loop)

(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union lhs passed-through))
      :ruleset passthrough)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset passthrough)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(ruleset state-edge-passthrough)

(rule ((= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg arg_ty then_ctx) j))
       (= (Get else_ i) (Get (Arg arg_ty else_ctx) j))

       (HasType (Get then_ i) (Base (StateT))))

      ((let lhs (Get outputs i))
       (let new_inputs (TupleRemoveAt inputs j))

       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let old_then (TupleRemoveAt then_ i))
       (let old_else (TupleRemoveAt else_ i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleRemoveAt outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs (Get inputs j))
       ;; Be careful not to subsume the original if statement immediately,
       ;;  since TupleRemoveAt still needs to match on it
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset state-edge-passthrough)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) pred)
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; Pass through inverted if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool false) _ _thenctx))
       (= (Get else_ i) (Const (Bool true) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) (Uop (Not) pred))
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(ruleset loop-strength-reduction)

; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs
;; Get the input and output value of an invariant, or constant int, within the loop
;;             loop in   out
(relation lsr-inv (Expr Expr Expr))

; TODO: there may be a bug with finding the invariant, or it just may not be extracted.
; Can make this work on loop_with_mul_by_inv and a rust test later.
; (rule (
;     (= loop (DoWhile inputs pred-and-body))
;     (= (Get outputs (+ i 1)) (Get (Arg arg-type assm) i)))
;     ((inv loop (Get inputs i) (Get (Arg arg-type assm) i))) :ruleset always-run)
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf inputs loop-input-ctx)
    (ContextOf pred-and-body loop-output-ctx)
    (= constant (Const c out-type loop-output-ctx))
    (HasArgType inputs in-type)
    )
    ((lsr-inv loop (Const c in-type loop-input-ctx) constant)) :ruleset always-run)
(constructor TmpCtxLSR (Expr Expr) Assumption)
(rule 
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))
        (ContextOf pred-and-outputs loop-ctx)

        ; Find loop variable (argument that gets incremented with an invariant)
        (lsr-inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type assm) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (lsr-inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type assm) i)))
        (ContextOf old-mul loop-ctx)

        (= arg-type (TupleT ty-list))
        ; n is index of our new, temporary variable d
        (= n (tuple-length inputs))
    )
    (
        (let tmp-ctx (TmpCtxLSR inputs pred-and-outputs))
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Construct optimized theta
        ; new-inputs already has the correct context
        (let new-inputs (Concat inputs (Single d-init)))

        ; We need to create a new type, with one more input
        (let new-arg-ty (TupleT (TLConcat ty-list (TCons (IntT) (TNil)))))
        (let replace-arg (SubTuple (Arg new-arg-ty tmp-ctx) 0 n))

        ; Value of d in loop. Add context to addend
        (let d-out (Bop (Add) (Get (Arg new-arg-ty tmp-ctx) n)
                   (Subst tmp-ctx replace-arg addend)))

        ; build the old body, making sure to set the correct arg type and context
        (let new-body
          (Concat
            (Subst tmp-ctx replace-arg pred-and-outputs)
            (Single d-out)))

        (let new-loop (DoWhile new-inputs new-body))

        (let new-c (Subst tmp-ctx replace-arg c-out))

        ; Now that we have the new loop, union the temporary context with the actual ctx
        (union tmp-ctx (InLoop new-inputs new-body))

        ; Substitute d for the *i expression
        (let new-mul
            (Bop (Mul) new-c (Get replace-arg i)))
        (union (Get (Arg new-arg-ty tmp-ctx) n) new-mul)

        ; Subsume the multiplication in the new loop to prevent
        ; from firing loop strength reduction again on the new loop
        ; Workaround of egglog issue: https://github.com/egraphs-good/egglog/issues/462
        ; add the expression we are about to subsume
        (let before
          (Bop (Mul) new-c (Get replace-arg i)))
        ; now subsume it
        (subsume
          (Bop (Mul) new-c (Get replace-arg i)))

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
    )
    :ruleset loop-strength-reduction
)
(relation IVTNewInputsAnalysisDemand (Expr))

(ruleset ivt-analysis)

(sort IVTRes)
;;                              perm passthrough-perm passthrough-type passthrough-type-len
(constructor IVTAnalysisRes (Expr Expr             TypeList         i64) IVTRes)
(constructor IVTMin (IVTRes IVTRes) IVTRes)

(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (<= len1 len2))
      ((union lhs (IVTAnalysisRes _a _b _c len1)))
        :ruleset ivt-analysis)
(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (> len1 len2))
      ((union lhs (IVTAnalysisRes _d _e _f len2)))
        :ruleset ivt-analysis)


;; use an analysis to avoid exploring all combinations of passthrough vs not passed through values. Always prefer not passed through
;;                                  expr1 curr  if  result
(function IVTNewInputsAnalysisImpl (Expr  Expr  Node) IVTRes :merge (IVTMin old new))

;; IVTNewInputsAnalysis computes a permutation perm which corresponds to accessing elements of an if region.
;; It also makes accesses of passthrough arguments access new indices after the length of the if region.
;; For example, if expr1 is: [get(if, 1), get(arg, 1), get(if, 0), get(arg, 3)]
;; It produces a new permutation: [get(arg, 1), get(arg, 2), get(arg, 0), get(arg, 3)]
;; The accesses of the if statement remain unchanged, and the accesses of the passthrough arguments are moved to the end.
;; This new permutation is intended to be used with a substitution argument (Concat if-statement passthrough-args)
;; Also produced is a passthrough-perm, which selects all of the passthrough arguments and puts them in a single tuple
;;                              expr1 if result
(function IVTNewInputsAnalysis (Expr  Node) IVTRes :merge (IVTMin old new))


(rule (
    (DoWhile inpW outW)
) (
    (IVTNewInputsAnalysisDemand outW)
) :ruleset ivt-analysis)

(rule (
    (IVTNewInputsAnalysisDemand loop-body)
    ;; first input is a predicate
    (= loop-body (Concat (Single pred) rest))
    ;; another input is an if statement with shared predicate
    (= if-eclass (If pred inputs thn else))
    (= (Get loop-body i) (Get if-eclass j))
    (!= i 0)
) (
    (let perm (Empty (TmpType) (InFunc "no-ctx")))
    (set
     (IVTNewInputsAnalysisImpl loop-body rest (IfNode if-eclass pred inputs thn else))
     (IVTAnalysisRes perm perm (TNil) 0))
) :ruleset ivt-analysis)

;; recursive case for accessing the if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get if-eclass ith)) rest))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm  pperm passthrough-tys len))
) :ruleset ivt-analysis)

;; recursive case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get (Arg ty ctx) ith)) rest))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)

; base case for accessing if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body (Single last) ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= last (Get if-eclass ith))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm pperm passthrough-tys len))
) :ruleset ivt-analysis)

; base case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Single (Get (Arg ty ctx) ith)))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)


(ruleset loop-inversion)

(constructor TmpCtxLoopInversion (Expr Expr) Assumption)
(rule (
    (= loop (DoWhile inpW outW))
    (= (IVTNewInputsAnalysis outW ifnode) (IVTAnalysisRes perm pperm passthrough-tys _len))
    (= ifnode (IfNode if if-cond if-inputs then else))
    (= if-inputs-len (tuple-length if-inputs))
    (= passthrough-len (TypeList-length passthrough-tys))

    (ContextOf inpW outer-ctx)
    (ContextOf if-inputs if-ctx)
    (HasType if-inputs inputs-ty)
    (= inputs-ty (TupleT inputs-ty-list))
) (
    (let tmp-ctx (TmpCtxLoopInversion inpW outW))
    ;; new peeled condition, checks the if's condition before the first iteration
    (let new-if-cond (Subst outer-ctx inpW if-cond))

    ;; new inputs to the if are 1) the inputs run once unconditionally concatted with
    ;; 2) the passthrough values
    (let new-if-inp
        (Concat (Subst outer-ctx inpW if-inputs)
                (Subst outer-ctx inpW pperm)))
    ;; if contexts
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-arg-ty (TupleT (TLConcat inputs-ty-list passthrough-tys)))
    (let new-loop-arg (Arg new-loop-arg-ty tmp-ctx))
    (let new-loop-context tmp-ctx)

    ;; body
    ;; loop begins by running the then branch of the if statement, which uses the first if-inputs-length elements of arg
    (let then-arg (SubTuple new-loop-arg 0 if-inputs-len))
    (let new-then-branch
        (Subst new-loop-context then-arg then))
    ;; the inputs are then run on the combination of
    ;; the then branch and the passthrough values
    (let then-branch-and-passthrough
      (Concat new-then-branch (SubTuple new-loop-arg if-inputs-len passthrough-len)))
    ;; permute them to move passthrough and if outputs back
    ;; to where if-inputs and if-cond expect them to be
    (let permuted-then-branch-and-passthrough
      (Subst new-loop-context then-branch-and-passthrough perm))
    ;; substitute into inputs and condi
    (let new-inputs-after-then-branch 
        (Subst new-loop-context permuted-then-branch-and-passthrough
            (Concat (Single if-cond) if-inputs)))
    (let new-loop-outputs
        (Concat new-inputs-after-then-branch
           (SubTuple new-loop-arg if-inputs-len passthrough-len)))

    (let new-loop (DoWhile (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg new-loop-arg-ty new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let final-if-inputs
       (SubTuple new-if 0 if-inputs-len))
    (let else-branch-end
        (Subst outer-ctx final-if-inputs else))
    (let else-branch-end-and-passthrough
        (Concat else-branch-end
               (SubTuple new-if if-inputs-len passthrough-len)))
    (let final-permuted
        (Subst outer-ctx else-branch-end-and-passthrough perm))

    (union final-permuted loop)
    (union new-loop-context (InLoop (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))

    (subsume (DoWhile inpW outW))
) :ruleset loop-inversion)

(ruleset cicm)
(ruleset cicm-index)

(relation InvCodeMotionCandidate (Expr Expr))

(rule (
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t1 c2) (ExtractedExpr e2))
        (ContextOf e1 (InIf true pred1 orig_ins3))
        (ContextOf e2 (InIf false pred2 orig_ins4))
        (!= e1 e2)
     )
     ((InvCodeMotionCandidate e1 e2))
     :ruleset cicm-index)


(rule (
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (= e1 (Uop o x))
        (HasType e1 (Base ty))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (ContextOf e1 (InIf true pred orig_ins))

        (= e2 (Uop o y))
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)
        (ContextOf e2 (InIf false pred orig_ins))

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Uop o (Subst if_tr st_tr x))
        (Uop o (Subst if_fa st_fa y))
        ; Now subsume:
        (subsume (Uop o (Subst if_tr st_tr x)))
        (subsume (Uop o (Subst if_fa st_fa y)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)

       

(rule (
        (InvCodeMotionCandidate e1 e2)
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (ContextOf e1 (InIf true pred orig_ins))
        (ContextOf e2 (InIf false pred orig_ins))
        (= e1 (Bop o x1 y1))
        
        (= e2 (Bop o x2 y2))
        
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (HasType e1 (Base ty))
        

        
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1))
        (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2))
        ; Now subsume:
        (subsume (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1)))
        (subsume (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)


(ruleset push-in)

; new version of the rule where one side of bop is constant
(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o (Const c ty outer_ctx) x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(c, x) in the new regions
        (union (Get arg_tr i) (Bop o (Const c new_ins_ty if_tr) (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Bop o (Const c new_ins_ty if_fa) (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o x (Const c ty outer_ctx)) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(x, c) in the new regions
        (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Const c new_ins_ty if_tr)))
        (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Const c new_ins_ty if_fa)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Uop o x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Uop(x) in the new regions
        (union (Get arg_tr i) (Uop o (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Uop o (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

; OLD VERSION - Too slow for now
; ; push bop input into region
; (rule (
;         (= if_e (If pred orig_inputs thn els))
;         (ContextOf if_e outer_ctx)
;         (= (Bop o x y) (Get orig_inputs i))
;         (HasArgType thn (TupleT tylist))
;         (HasArgType els (TupleT tylist))
;         (HasType x (Base x_ty))
;         (HasType y (Base y_ty))
;       )
;       (
;         ; New inputs
;         (let new_ins (Concat orig_inputs (Concat (Single x) (Single y))))
;         (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TCons y_ty (TNil))))))

;         ; New contexts
;         (let if_tr (InIf true  pred new_ins))
;         (let if_fa (InIf false pred new_ins))
        
;         ; New args
;         (let arg_tr (Arg new_ins_ty if_tr))
;         (let arg_fa (Arg new_ins_ty if_fa))

;         ; SubTuple
;         (let orig_ins_len (TypeList-length tylist))
;         (let st_tr (SubTuple arg_tr 0 orig_ins_len))
;         (let st_fa (SubTuple arg_fa 0 orig_ins_len))

;         ; New regions
;         (let new_thn (Subst if_tr st_tr thn))
;         (let new_els (Subst if_fa st_fa els))

;         ; Union the original input with Bop(x, y) in the new regions
;         (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Get arg_tr (+ orig_ins_len 1))))
;         (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Get arg_fa (+ orig_ins_len 1))))

;         ; Union the ifs
;         (union if_e (If pred new_ins new_thn new_els))
;       )
;       :ruleset push-in)
;; use these rules to clean up the database, removing helpers
;; this makes the visualization easier to read

(ruleset debug-deletes)

(rule ((HasType a b))
      ((delete (HasType a b)))
      :ruleset debug-deletes)

(rule ((BodyContainsExpr a b))
      ((delete (BodyContainsExpr a b)))
      :ruleset debug-deletes)

(rule ((ExprIsPure e))
      ((delete (ExprIsPure e)))
      :ruleset debug-deletes)

(rule ((HasArgType e ty))
      ((delete (HasArgType e ty)))
      :ruleset debug-deletes)

(rule ((is-inv-Expr e ty))
      ((delete (is-inv-Expr e ty)))
      :ruleset debug-deletes)

(rule ((tuple-length e))
      ((delete (tuple-length e)))
      :ruleset debug-deletes)

(rule ((BinaryOpIsPure e))
      ((delete (BinaryOpIsPure e)))
      :ruleset debug-deletes)

(rule ((ContextOf e a))
      ((delete (ContextOf e a)))
      :ruleset debug-deletes)

(rule ((ExprIsResolved e))
      ((delete (ExprIsResolved e)))
      :ruleset debug-deletes)

(rule ((bop->string a b))
      ((delete (bop->string a b)))
      :ruleset debug-deletes)

(rule ((bpred-of-type a b))
      ((delete (bpred-of-type a b)))
      :ruleset debug-deletes)

(rule ((PureType e))
      ((delete (PureType e)))
      :ruleset debug-deletes)

(rule ((PointsToCells a b))
      ((delete (PointsToCells a b)))
      :ruleset debug-deletes)

(rule ((TuplePointsTo e))
      ((delete (TuplePointsTo e)))
      :ruleset debug-deletes)

(rule ((Resolved-List<PtrPointees> e))
      ((delete (Resolved-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((TypeListToList<PtrPointees> e))
      ((delete (TypeListToList<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<PtrPointees> a b))
      ((delete (Cons-List<PtrPointees> a b)))
      :ruleset debug-deletes)

(rule ((Nil-List<PtrPointees>))
      ((delete (Nil-List<PtrPointees>)))
      :ruleset debug-deletes)

(rule ((Length-List<PtrPointees> e))
      ((delete (Length-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((At-List<PtrPointees> a b c))
      ((delete (At-List<PtrPointees> a b c)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<PtrPointees> a))
      ((delete (IsNonEmpty-List<PtrPointees> a)))
      :ruleset debug-deletes)

(rule ((Resolved-List<i64+IntInterval> e))
      ((delete (Resolved-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<i64+IntInterval> a b c))
      ((delete (Cons-List<i64+IntInterval> a b c)))
      :ruleset debug-deletes)

(rule ((Nil-List<i64+IntInterval>))
      ((delete (Nil-List<i64+IntInterval>)))
      :ruleset debug-deletes)

(rule ((Length-List<i64+IntInterval> e))
      ((delete (Length-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((At-List<i64+IntInterval> a b c d))
      ((delete (At-List<i64+IntInterval> a b c d)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<i64+IntInterval> a))
      ((delete (IsNonEmpty-List<i64+IntInterval> a)))
      :ruleset debug-deletes)

(rule ((TypeList-ith a b))
      ((delete (TypeList-ith a b)))
      :ruleset debug-deletes)

(rule ((InIf a b c))
      ((delete (InIf a b c)))
      :ruleset debug-deletes)
(rule ((InLoop a b))
      ((delete (InLoop a b)))
      :ruleset debug-deletes)
(rule ((InFunc a))
      ((delete (InFunc a)))
      :ruleset debug-deletes)

(rule ((TupleT a))
      ((delete (TupleT a)))
      :ruleset debug-deletes)
(rule ((TCons a b))
      ((delete (TCons a b)))
      :ruleset debug-deletes)
(rule ((TNil))
      ((delete (TNil)))
      :ruleset debug-deletes)
(rule ((Base a))
      ((delete (Base a)))
      :ruleset debug-deletes)
(rule ((IntT))
      ((delete (IntT)))
      :ruleset debug-deletes)

;; Hacker's delight optimizations

(ruleset hacker)

;; A simple analysis to identify loops that run exactly #popcount times

;; IsIsEven e x => e is a boolean expression that checks whether x is an even number
(relation IsIsEven (Expr Expr))

(rule (
    (= two (Const (Int 2) ty ctx))
    (= e (Bop (Eq) x (Bop (Mul) (Bop (Div) x two) two)))
) (
    (IsIsEven e x)
) :ruleset hacker)

;; NTZIterations lp n pos => loop lp runs exactly number_of_trailing_zeros(n) times at index pos
(relation NTZIterations (Expr Expr i64))

(rule (
    ;; Grab the outer if
    (= outerif (If cond inputs evenbr oddbr))
    ;; There exists an argument n
    (= n (Get inputs i))
    ;; The condition is on the parity of n
    (IsIsEven cond n)
    ;; In the even/true branch, there is a loop
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    ;; n is passed into to the loop
    (= (Get lp_inputs j) (Get (Arg _ty1 _ctx1) i))
    ;; the loop continues as long as n / 2 is even
    (= two (Const (Int 2) _ty2 _ctx2))
    (= nd2 (Bop (Div) (Get (Arg _ty3 _ctx3) j) two))
    (IsIsEven (Get lp_pred_outputs 0) nd2)
    ;; n is divided by 2 every loop
    (= nd2 (Get lp_pred_outputs (+ j 1)))
    ;; In the odd/false branch, we look for an n
    (= (Get (Arg _ty4 _ctx4) i) (Get oddbr j))
) (
    (NTZIterations outerif n j)
) :ruleset hacker)

;; Identify and optimize lowbit

(rule (
    (NTZIterations outerif n i)
    (= outerif (If cond inputs evenbr oddbr))
    ;; In the even branch, it returns a value that doubles every iter
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    (= (Const (Int 1) _ty1 _ctx1) (Get lp_inputs j))
    (= two (Const (Int 2) _ty2 _ctx2))
    (= (Bop (Mul) (Get (Arg _ty3 _ctx3) j) two) (Get lp_pred_outputs (+ j 1)))    
    ;; In the odd branch, it returns an 1
    (= (Const (Int 1) _ty0 _ctx0) (Get oddbr j))
) (
    (let lowbitn (Bop (Bitand) n (Uop (Neg) n)))
    (union (Get outerif j) lowbitn)
    (union (Get outerif i) (Bop (Div) n lowbitn))
) :ruleset hacker)

;; Try to do a state-edge-passthrough for loops
;; NLZIterations guarantees termination for non-zero values
;; lowbit(0) is undefined behavior

(constructor DummyLoopContext (Expr Expr Expr) Assumption)

(rule (
    (NTZIterations anyif n i)
    (= anyif (If cond inputs thenbr elsebr))
    (= thenbr (DoWhile lpinputs pred_outputs))
    (= (Get pred_outputs (+ j 1)) (Get (Arg arg_ty then_ctx) j))
    (HasType (Get pred_outputs (+ j 1)) (Base (StateT)))
) (
    (let newlpinputs (TupleRemoveAt lpinputs j))
    (let newpred_outputs (TupleRemoveAt pred_outputs (+ j 1)))
    
    (let newlpctx (DummyLoopContext newlpinputs newpred_outputs pred_outputs))

    (let newbody (DropAt newlpctx j newpred_outputs))

    (union newlpctx (InLoop newlpinputs newbody))

    (let newlp (DoWhile newlpinputs newbody))
    (let oldlp (TupleRemoveAt thenbr j))

    (union newlp oldlp)

    (union (Get thenbr j) (Get lpinputs j))

) :ruleset hacker)

(unstable-combined-ruleset cheap-optimizations
    hacker
loop-simplify
interval-rewrite
always-switch-rewrite
peepholes
)

(unstable-combined-ruleset all-optimizations
    select_opt
loop-unroll
switch_rewrite
loop-inv-motion
loop-strength-reduction
cicm
push-in
hacker
loop-simplify
interval-rewrite
always-switch-rewrite
peepholes
)
    

; required by function_inlining_unoins
; Function inlining unions
(relation InlinedCall (String Expr))

(ruleset initialization)
(rule () (
    ; Program nodes
    (let __tmp0 (Int 180))
(let __tmp1 (StateT ))
(let __tmp2 (TNil ))
(let __tmp3 (TCons __tmp1 __tmp2))
(let __tmp4 (TupleT __tmp3))
(let __tmp5 (InFunc "main"))
(let __tmp6 (Const __tmp0 __tmp4 __tmp5))
(let __tmp7 (Single __tmp6))
(let __tmp8 (Int 200))
(let __tmp9 (Const __tmp8 __tmp4 __tmp5))
(let __tmp10 (Single __tmp9))
(let __tmp11 (Arg __tmp4 __tmp5))
(let __tmp12 (Concat __tmp10 __tmp11))
(let __tmp13 (Concat __tmp7 __tmp12))
(let __tmp14 (Call "matrix_new" __tmp13))
(let __tmp15 (Mul ))
(let __tmp16 (Get __tmp13 1))
(let __tmp17 (Get __tmp13 0))
(let __tmp18 (Bop __tmp15 __tmp16 __tmp17))
(let __tmp19 (Get __tmp13 2))
(let __tmp20 (FloatT ))
(let __tmp21 (PointerT __tmp20))
(let __tmp22 (Alloc 0 __tmp18 __tmp19 __tmp21))
(let __tmp23 (Int 190))
(let __tmp24 (Const __tmp23 __tmp4 __tmp5))
(let __tmp25 (Single __tmp24))
(let __tmp26 (Get __tmp14 1))
(let __tmp27 (Single __tmp26))
(let __tmp28 (Concat __tmp25 __tmp27))
(let __tmp29 (Concat __tmp10 __tmp28))
(let __tmp30 (Call "matrix_new" __tmp29))
(let __tmp31 (Get __tmp29 1))
(let __tmp32 (Get __tmp29 0))
(let __tmp33 (Bop __tmp15 __tmp31 __tmp32))
(let __tmp34 (Get __tmp29 2))
(let __tmp35 (Alloc 0 __tmp33 __tmp34 __tmp21))
(let __tmp36 (Int 220))
(let __tmp37 (Const __tmp36 __tmp4 __tmp5))
(let __tmp38 (Single __tmp37))
(let __tmp39 (Get __tmp30 1))
(let __tmp40 (Single __tmp39))
(let __tmp41 (Concat __tmp38 __tmp40))
(let __tmp42 (Concat __tmp25 __tmp41))
(let __tmp43 (Call "matrix_new" __tmp42))
(let __tmp44 (Get __tmp42 1))
(let __tmp45 (Get __tmp42 0))
(let __tmp46 (Bop __tmp15 __tmp44 __tmp45))
(let __tmp47 (Get __tmp42 2))
(let __tmp48 (Alloc 0 __tmp46 __tmp47 __tmp21))
(let __tmp49 (Int 210))
(let __tmp50 (Const __tmp49 __tmp4 __tmp5))
(let __tmp51 (Single __tmp50))
(let __tmp52 (Get __tmp43 1))
(let __tmp53 (Single __tmp52))
(let __tmp54 (Concat __tmp51 __tmp53))
(let __tmp55 (Concat __tmp38 __tmp54))
(let __tmp56 (Call "matrix_new" __tmp55))
(let __tmp57 (Get __tmp55 1))
(let __tmp58 (Get __tmp55 0))
(let __tmp59 (Bop __tmp15 __tmp57 __tmp58))
(let __tmp60 (Get __tmp55 2))
(let __tmp61 (Alloc 0 __tmp59 __tmp60 __tmp21))
(let __tmp62 (Get __tmp14 0))
(let __tmp63 (Single __tmp62))
(let __tmp64 (Get __tmp30 0))
(let __tmp65 (Single __tmp64))
(let __tmp66 (Get __tmp43 0))
(let __tmp67 (Single __tmp66))
(let __tmp68 (Get __tmp56 0))
(let __tmp69 (Single __tmp68))
(let __tmp70 (Float 180.0))
(let __tmp71 (Const __tmp70 __tmp4 __tmp5))
(let __tmp72 (Single __tmp71))
(let __tmp73 (Float 190.0))
(let __tmp74 (Const __tmp73 __tmp4 __tmp5))
(let __tmp75 (Single __tmp74))
(let __tmp76 (Float 200.0))
(let __tmp77 (Const __tmp76 __tmp4 __tmp5))
(let __tmp78 (Single __tmp77))
(let __tmp79 (Float 210.0))
(let __tmp80 (Const __tmp79 __tmp4 __tmp5))
(let __tmp81 (Single __tmp80))
(let __tmp82 (Float 220.0))
(let __tmp83 (Const __tmp82 __tmp4 __tmp5))
(let __tmp84 (Single __tmp83))
(let __tmp85 (Get __tmp56 1))
(let __tmp86 (Single __tmp85))
(let __tmp87 (Concat __tmp84 __tmp86))
(let __tmp88 (Concat __tmp38 __tmp87))
(let __tmp89 (Concat __tmp81 __tmp88))
(let __tmp90 (Concat __tmp51 __tmp89))
(let __tmp91 (Concat __tmp78 __tmp90))
(let __tmp92 (Concat __tmp10 __tmp91))
(let __tmp93 (Concat __tmp75 __tmp92))
(let __tmp94 (Concat __tmp25 __tmp93))
(let __tmp95 (Concat __tmp72 __tmp94))
(let __tmp96 (Concat __tmp7 __tmp95))
(let __tmp97 (Concat __tmp69 __tmp96))
(let __tmp98 (Concat __tmp67 __tmp97))
(let __tmp99 (Concat __tmp65 __tmp98))
(let __tmp100 (Concat __tmp63 __tmp99))
(let __tmp101 (Call "init" __tmp100))
(let __tmp102 (Get __tmp100 14))
(let __tmp103 (Single __tmp102))
(let __tmp104 (Float 0.0))
(let __tmp105 (Const __tmp104 __tmp4 __tmp5))
(let __tmp106 (Single __tmp105))
(let __tmp107 (Float 1.0))
(let __tmp108 (Const __tmp107 __tmp4 __tmp5))
(let __tmp109 (Single __tmp108))
(let __tmp110 (Int 0))
(let __tmp111 (Const __tmp110 __tmp4 __tmp5))
(let __tmp112 (Single __tmp111))
(let __tmp113 (Int 1))
(let __tmp114 (Const __tmp113 __tmp4 __tmp5))
(let __tmp115 (Single __tmp114))
(let __tmp116 (Get __tmp100 3))
(let __tmp117 (Single __tmp116))
(let __tmp118 (Get __tmp100 10))
(let __tmp119 (Single __tmp118))
(let __tmp120 (Float 5.0))
(let __tmp121 (Const __tmp120 __tmp4 __tmp5))
(let __tmp122 (Single __tmp121))
(let __tmp123 (Get __tmp100 9))
(let __tmp124 (Single __tmp123))
(let __tmp125 (Float 2.0))
(let __tmp126 (Const __tmp125 __tmp4 __tmp5))
(let __tmp127 (Single __tmp126))
(let __tmp128 (Get __tmp100 12))
(let __tmp129 (Single __tmp128))
(let __tmp130 (Get __tmp100 2))
(let __tmp131 (Single __tmp130))
(let __tmp132 (Get __tmp100 11))
(let __tmp133 (Single __tmp132))
(let __tmp134 (Float 3.0))
(let __tmp135 (Const __tmp134 __tmp4 __tmp5))
(let __tmp136 (Single __tmp135))
(let __tmp137 (Get __tmp100 6))
(let __tmp138 (Single __tmp137))
(let __tmp139 (Get __tmp100 1))
(let __tmp140 (Single __tmp139))
(let __tmp141 (Get __tmp100 7))
(let __tmp142 (Single __tmp141))
(let __tmp143 (Get __tmp100 8))
(let __tmp144 (Single __tmp143))
(let __tmp145 (Get __tmp100 0))
(let __tmp146 (Single __tmp145))
(let __tmp147 (Get __tmp100 5))
(let __tmp148 (Single __tmp147))
(let __tmp149 (Get __tmp100 4))
(let __tmp150 (Single __tmp149))
(let __tmp151 (Concat __tmp148 __tmp150))
(let __tmp152 (Concat __tmp146 __tmp151))
(let __tmp153 (Concat __tmp144 __tmp152))
(let __tmp154 (Concat __tmp142 __tmp153))
(let __tmp155 (Concat __tmp140 __tmp154))
(let __tmp156 (Concat __tmp138 __tmp155))
(let __tmp157 (Concat __tmp136 __tmp156))
(let __tmp158 (Concat __tmp133 __tmp157))
(let __tmp159 (Concat __tmp131 __tmp158))
(let __tmp160 (Concat __tmp129 __tmp159))
(let __tmp161 (Concat __tmp127 __tmp160))
(let __tmp162 (Concat __tmp124 __tmp161))
(let __tmp163 (Concat __tmp122 __tmp162))
(let __tmp164 (Concat __tmp119 __tmp163))
(let __tmp165 (Concat __tmp117 __tmp164))
(let __tmp166 (Concat __tmp115 __tmp165))
(let __tmp167 (Concat __tmp112 __tmp166))
(let __tmp168 (Concat __tmp109 __tmp167))
(let __tmp169 (Concat __tmp106 __tmp168))
(let __tmp170 (Concat __tmp103 __tmp169))
(let __tmp171 (LessThan ))
(let __tmp172 (IntT ))
(let __tmp173 (TCons __tmp172 __tmp2))
(let __tmp174 (TCons __tmp20 __tmp173))
(let __tmp175 (TCons __tmp21 __tmp174))
(let __tmp176 (TCons __tmp172 __tmp175))
(let __tmp177 (TCons __tmp20 __tmp176))
(let __tmp178 (TCons __tmp21 __tmp177))
(let __tmp179 (TCons __tmp172 __tmp178))
(let __tmp180 (TCons __tmp20 __tmp179))
(let __tmp181 (TCons __tmp20 __tmp180))
(let __tmp182 (TCons __tmp21 __tmp181))
(let __tmp183 (TCons __tmp172 __tmp182))
(let __tmp184 (TCons __tmp20 __tmp183))
(let __tmp185 (TCons __tmp20 __tmp184))
(let __tmp186 (TCons __tmp20 __tmp185))
(let __tmp187 (TCons __tmp172 __tmp186))
(let __tmp188 (TCons __tmp21 __tmp187))
(let __tmp189 (TCons __tmp172 __tmp188))
(let __tmp190 (TCons __tmp172 __tmp189))
(let __tmp191 (TCons __tmp20 __tmp190))
(let __tmp192 (TCons __tmp20 __tmp191))
(let __tmp193 (TCons __tmp1 __tmp192))
(let __tmp194 (TupleT __tmp193))
(let __tmp195 (InFunc " loop_ctx_23"))
(let __tmp196 (Arg __tmp194 __tmp195))
(let __tmp197 (Get __tmp196 3))
(let __tmp198 (Get __tmp196 20))
(let __tmp199 (Bop __tmp171 __tmp197 __tmp198))
(let __tmp200 (Single __tmp199))
(let __tmp201 (InIf true __tmp199 __tmp196))
(let __tmp202 (Const __tmp110 __tmp194 __tmp201))
(let __tmp203 (Arg __tmp194 __tmp201))
(let __tmp204 (Get __tmp203 17))
(let __tmp205 (Bop __tmp171 __tmp202 __tmp204))
(let __tmp206 (Get __tmp203 0))
(let __tmp207 (Single __tmp206))
(let __tmp208 (Get __tmp203 1))
(let __tmp209 (Single __tmp208))
(let __tmp210 (Get __tmp203 2))
(let __tmp211 (Single __tmp210))
(let __tmp212 (Get __tmp203 3))
(let __tmp213 (Single __tmp212))
(let __tmp214 (Get __tmp203 4))
(let __tmp215 (Single __tmp214))
(let __tmp216 (Const __tmp104 __tmp194 __tmp201))
(let __tmp217 (Single __tmp216))
(let __tmp218 (Single __tmp202))
(let __tmp219 (Get __tmp203 5))
(let __tmp220 (Single __tmp219))
(let __tmp221 (Get __tmp203 6))
(let __tmp222 (Single __tmp221))
(let __tmp223 (Get __tmp203 7))
(let __tmp224 (Single __tmp223))
(let __tmp225 (Get __tmp203 8))
(let __tmp226 (Single __tmp225))
(let __tmp227 (Get __tmp203 9))
(let __tmp228 (Single __tmp227))
(let __tmp229 (Get __tmp203 10))
(let __tmp230 (Single __tmp229))
(let __tmp231 (Get __tmp203 11))
(let __tmp232 (Single __tmp231))
(let __tmp233 (Get __tmp203 12))
(let __tmp234 (Single __tmp233))
(let __tmp235 (Get __tmp203 13))
(let __tmp236 (Single __tmp235))
(let __tmp237 (Get __tmp203 14))
(let __tmp238 (Single __tmp237))
(let __tmp239 (Get __tmp203 15))
(let __tmp240 (Single __tmp239))
(let __tmp241 (Get __tmp203 16))
(let __tmp242 (Single __tmp241))
(let __tmp243 (Single __tmp204))
(let __tmp244 (Get __tmp203 18))
(let __tmp245 (Single __tmp244))
(let __tmp246 (Get __tmp203 19))
(let __tmp247 (Single __tmp246))
(let __tmp248 (Get __tmp203 20))
(let __tmp249 (Single __tmp248))
(let __tmp250 (Concat __tmp247 __tmp249))
(let __tmp251 (Concat __tmp245 __tmp250))
(let __tmp252 (Concat __tmp243 __tmp251))
(let __tmp253 (Concat __tmp242 __tmp252))
(let __tmp254 (Concat __tmp240 __tmp253))
(let __tmp255 (Concat __tmp238 __tmp254))
(let __tmp256 (Concat __tmp236 __tmp255))
(let __tmp257 (Concat __tmp234 __tmp256))
(let __tmp258 (Concat __tmp232 __tmp257))
(let __tmp259 (Concat __tmp230 __tmp258))
(let __tmp260 (Concat __tmp228 __tmp259))
(let __tmp261 (Concat __tmp226 __tmp260))
(let __tmp262 (Concat __tmp224 __tmp261))
(let __tmp263 (Concat __tmp222 __tmp262))
(let __tmp264 (Concat __tmp220 __tmp263))
(let __tmp265 (Concat __tmp218 __tmp264))
(let __tmp266 (Concat __tmp217 __tmp265))
(let __tmp267 (Concat __tmp215 __tmp266))
(let __tmp268 (Concat __tmp213 __tmp267))
(let __tmp269 (Concat __tmp211 __tmp268))
(let __tmp270 (Concat __tmp209 __tmp269))
(let __tmp271 (Concat __tmp207 __tmp270))
(let __tmp272 (TCons __tmp20 __tmp189))
(let __tmp273 (TCons __tmp172 __tmp272))
(let __tmp274 (TCons __tmp172 __tmp273))
(let __tmp275 (TCons __tmp20 __tmp274))
(let __tmp276 (TCons __tmp20 __tmp275))
(let __tmp277 (TCons __tmp1 __tmp276))
(let __tmp278 (TupleT __tmp277))
(let __tmp279 (InIf true __tmp205 __tmp271))
(let __tmp280 (Arg __tmp278 __tmp279))
(let __tmp281 (InFunc " loop_ctx_24"))
(let __tmp282 (Arg __tmp278 __tmp281))
(let __tmp283 (Get __tmp282 20))
(let __tmp284 (Single __tmp283))
(let __tmp285 (Get __tmp282 3))
(let __tmp286 (Single __tmp285))
(let __tmp287 (Get __tmp282 6))
(let __tmp288 (Single __tmp287))
(let __tmp289 (Get __tmp282 19))
(let __tmp290 (Single __tmp289))
(let __tmp291 (FDiv ))
(let __tmp292 (FAdd ))
(let __tmp293 (FMul ))
(let __tmp294 (Get __tmp282 1))
(let __tmp295 (Get __tmp282 5))
(let __tmp296 (Bop __tmp293 __tmp294 __tmp295))
(let __tmp297 (Get __tmp282 2))
(let __tmp298 (Bop __tmp292 __tmp296 __tmp297))
(let __tmp299 (Single __tmp298))
(let __tmp300 (Get __tmp282 21))
(let __tmp301 (Single __tmp300))
(let __tmp302 (Get __tmp282 0))
(let __tmp303 (Single __tmp302))
(let __tmp304 (Concat __tmp301 __tmp303))
(let __tmp305 (Concat __tmp299 __tmp304))
(let __tmp306 (Call "fmod" __tmp305))
(let __tmp307 (Get __tmp306 0))
(let __tmp308 (Get __tmp282 9))
(let __tmp309 (Bop __tmp293 __tmp308 __tmp300))
(let __tmp310 (Bop __tmp291 __tmp307 __tmp309))
(let __tmp311 (Single __tmp310))
(let __tmp312 (Get __tmp306 1))
(let __tmp313 (Single __tmp312))
(let __tmp314 (Concat __tmp311 __tmp313))
(let __tmp315 (Concat __tmp290 __tmp314))
(let __tmp316 (Concat __tmp288 __tmp315))
(let __tmp317 (Concat __tmp286 __tmp316))
(let __tmp318 (Concat __tmp284 __tmp317))
(let __tmp319 (Call "matrix_set" __tmp318))
(let __tmp320 (Single __tmp294))
(let __tmp321 (Single __tmp297))
(let __tmp322 (Get __tmp282 4))
(let __tmp323 (Single __tmp322))
(let __tmp324 (Bop __tmp292 __tmp295 __tmp297))
(let __tmp325 (Single __tmp324))
(let __tmp326 (Add ))
(let __tmp327 (Bop __tmp326 __tmp322 __tmp287))
(let __tmp328 (Single __tmp327))
(let __tmp329 (Get __tmp282 7))
(let __tmp330 (Single __tmp329))
(let __tmp331 (Get __tmp282 8))
(let __tmp332 (Single __tmp331))
(let __tmp333 (Single __tmp308))
(let __tmp334 (Get __tmp282 10))
(let __tmp335 (Single __tmp334))
(let __tmp336 (Get __tmp282 11))
(let __tmp337 (Single __tmp336))
(let __tmp338 (Get __tmp282 12))
(let __tmp339 (Single __tmp338))
(let __tmp340 (Get __tmp282 13))
(let __tmp341 (Single __tmp340))
(let __tmp342 (Get __tmp282 14))
(let __tmp343 (Single __tmp342))
(let __tmp344 (Get __tmp282 15))
(let __tmp345 (Single __tmp344))
(let __tmp346 (Get __tmp282 16))
(let __tmp347 (Single __tmp346))
(let __tmp348 (Get __tmp282 17))
(let __tmp349 (Single __tmp348))
(let __tmp350 (Get __tmp282 18))
(let __tmp351 (Single __tmp350))
(let __tmp352 (Concat __tmp351 __tmp290))
(let __tmp353 (Concat __tmp349 __tmp352))
(let __tmp354 (Concat __tmp347 __tmp353))
(let __tmp355 (Concat __tmp345 __tmp354))
(let __tmp356 (Concat __tmp343 __tmp355))
(let __tmp357 (Concat __tmp341 __tmp356))
(let __tmp358 (Concat __tmp339 __tmp357))
(let __tmp359 (Concat __tmp337 __tmp358))
(let __tmp360 (Concat __tmp335 __tmp359))
(let __tmp361 (Concat __tmp333 __tmp360))
(let __tmp362 (Concat __tmp332 __tmp361))
(let __tmp363 (Get __tmp282 22))
(let __tmp364 (Single __tmp363))
(let __tmp365 (Concat __tmp301 __tmp364))
(let __tmp366 (Concat __tmp284 __tmp365))
(let __tmp367 (Concat __tmp362 __tmp366))
(let __tmp368 (Concat __tmp330 __tmp367))
(let __tmp369 (Concat __tmp328 __tmp368))
(let __tmp370 (Concat __tmp325 __tmp369))
(let __tmp371 (Concat __tmp323 __tmp370))
(let __tmp372 (Concat __tmp286 __tmp371))
(let __tmp373 (Concat __tmp321 __tmp372))
(let __tmp374 (Concat __tmp320 __tmp373))
(let __tmp375 (Concat __tmp319 __tmp374))
(let __tmp376 (Get __tmp375 6))
(let __tmp377 (Get __tmp375 19))
(let __tmp378 (Bop __tmp171 __tmp376 __tmp377))
(let __tmp379 (Single __tmp378))
(let __tmp380 (Concat __tmp379 __tmp375))
(let __tmp381 (DoWhile __tmp280 __tmp380))
(let __tmp382 (InIf false __tmp205 __tmp271))
(let __tmp383 (Arg __tmp278 __tmp382))
(let __tmp384 (If __tmp205 __tmp271 __tmp381 __tmp383))
(let __tmp385 (Get __tmp384 0))
(let __tmp386 (Single __tmp385))
(let __tmp387 (Get __tmp384 1))
(let __tmp388 (Get __tmp384 2))
(let __tmp389 (Bop __tmp292 __tmp387 __tmp388))
(let __tmp390 (Single __tmp389))
(let __tmp391 (Single __tmp388))
(let __tmp392 (Bop __tmp326 __tmp214 __tmp212))
(let __tmp393 (Single __tmp392))
(let __tmp394 (Get __tmp384 7))
(let __tmp395 (Single __tmp394))
(let __tmp396 (Get __tmp384 9))
(let __tmp397 (Single __tmp396))
(let __tmp398 (Get __tmp384 10))
(let __tmp399 (Single __tmp398))
(let __tmp400 (Get __tmp384 11))
(let __tmp401 (Single __tmp400))
(let __tmp402 (Get __tmp384 13))
(let __tmp403 (Single __tmp402))
(let __tmp404 (Get __tmp384 14))
(let __tmp405 (Single __tmp404))
(let __tmp406 (Get __tmp384 15))
(let __tmp407 (Single __tmp406))
(let __tmp408 (Get __tmp384 17))
(let __tmp409 (Single __tmp408))
(let __tmp410 (Get __tmp384 18))
(let __tmp411 (Single __tmp410))
(let __tmp412 (Concat __tmp411 __tmp243))
(let __tmp413 (Concat __tmp409 __tmp412))
(let __tmp414 (Concat __tmp238 __tmp413))
(let __tmp415 (Concat __tmp407 __tmp414))
(let __tmp416 (Concat __tmp405 __tmp415))
(let __tmp417 (Concat __tmp403 __tmp416))
(let __tmp418 (Concat __tmp230 __tmp417))
(let __tmp419 (Concat __tmp401 __tmp418))
(let __tmp420 (Concat __tmp399 __tmp419))
(let __tmp421 (Concat __tmp397 __tmp420))
(let __tmp422 (Concat __tmp222 __tmp421))
(let __tmp423 (Concat __tmp395 __tmp422))
(let __tmp424 (Concat __tmp215 __tmp423))
(let __tmp425 (Concat __tmp393 __tmp424))
(let __tmp426 (Concat __tmp391 __tmp425))
(let __tmp427 (Concat __tmp390 __tmp426))
(let __tmp428 (Concat __tmp386 __tmp427))
(let __tmp429 (Get __tmp384 20))
(let __tmp430 (Single __tmp429))
(let __tmp431 (Get __tmp384 21))
(let __tmp432 (Single __tmp431))
(let __tmp433 (Concat __tmp432 __tmp249))
(let __tmp434 (Concat __tmp430 __tmp433))
(let __tmp435 (Concat __tmp428 __tmp434))
(let __tmp436 (InIf false __tmp199 __tmp196))
(let __tmp437 (Arg __tmp194 __tmp436))
(let __tmp438 (If __tmp199 __tmp196 __tmp435 __tmp437))
(let __tmp439 (Concat __tmp200 __tmp438))
(let __tmp440 (DoWhile __tmp170 __tmp439))
(let __tmp441 (Get __tmp440 0))
(let __tmp442 (Single __tmp441))
(let __tmp443 (Get __tmp440 2))
(let __tmp444 (Single __tmp443))
(let __tmp445 (Get __tmp440 5))
(let __tmp446 (Single __tmp445))
(let __tmp447 (Get __tmp440 7))
(let __tmp448 (Single __tmp447))
(let __tmp449 (Get __tmp440 8))
(let __tmp450 (Single __tmp449))
(let __tmp451 (Get __tmp440 9))
(let __tmp452 (Single __tmp451))
(let __tmp453 (Get __tmp440 11))
(let __tmp454 (Single __tmp453))
(let __tmp455 (Get __tmp440 12))
(let __tmp456 (Single __tmp455))
(let __tmp457 (Get __tmp440 13))
(let __tmp458 (Single __tmp457))
(let __tmp459 (Get __tmp440 15))
(let __tmp460 (Single __tmp459))
(let __tmp461 (Get __tmp440 16))
(let __tmp462 (Single __tmp461))
(let __tmp463 (Concat __tmp462 __tmp144))
(let __tmp464 (Concat __tmp460 __tmp463))
(let __tmp465 (Concat __tmp138 __tmp464))
(let __tmp466 (Concat __tmp458 __tmp465))
(let __tmp467 (Concat __tmp456 __tmp466))
(let __tmp468 (Concat __tmp454 __tmp467))
(let __tmp469 (Concat __tmp129 __tmp468))
(let __tmp470 (Concat __tmp452 __tmp469))
(let __tmp471 (Concat __tmp450 __tmp470))
(let __tmp472 (Concat __tmp448 __tmp471))
(let __tmp473 (Concat __tmp119 __tmp472))
(let __tmp474 (Concat __tmp446 __tmp473))
(let __tmp475 (Concat __tmp115 __tmp474))
(let __tmp476 (Concat __tmp112 __tmp475))
(let __tmp477 (Concat __tmp444 __tmp476))
(let __tmp478 (Concat __tmp106 __tmp477))
(let __tmp479 (Concat __tmp442 __tmp478))
(let __tmp480 (TCons __tmp20 __tmp177))
(let __tmp481 (TCons __tmp21 __tmp480))
(let __tmp482 (TCons __tmp172 __tmp481))
(let __tmp483 (TCons __tmp20 __tmp482))
(let __tmp484 (TCons __tmp20 __tmp483))
(let __tmp485 (TCons __tmp20 __tmp484))
(let __tmp486 (TCons __tmp172 __tmp485))
(let __tmp487 (TCons __tmp21 __tmp486))
(let __tmp488 (TCons __tmp172 __tmp487))
(let __tmp489 (TCons __tmp172 __tmp488))
(let __tmp490 (TCons __tmp20 __tmp489))
(let __tmp491 (TCons __tmp20 __tmp490))
(let __tmp492 (TCons __tmp1 __tmp491))
(let __tmp493 (TupleT __tmp492))
(let __tmp494 (InFunc " loop_ctx_22"))
(let __tmp495 (Arg __tmp493 __tmp494))
(let __tmp496 (Get __tmp495 3))
(let __tmp497 (Get __tmp495 17))
(let __tmp498 (Bop __tmp171 __tmp496 __tmp497))
(let __tmp499 (Single __tmp498))
(let __tmp500 (InIf true __tmp498 __tmp495))
(let __tmp501 (Const __tmp110 __tmp493 __tmp500))
(let __tmp502 (Arg __tmp493 __tmp500))
(let __tmp503 (Get __tmp502 14))
(let __tmp504 (Bop __tmp171 __tmp501 __tmp503))
(let __tmp505 (Get __tmp502 0))
(let __tmp506 (Single __tmp505))
(let __tmp507 (Get __tmp502 1))
(let __tmp508 (Single __tmp507))
(let __tmp509 (Get __tmp502 2))
(let __tmp510 (Single __tmp509))
(let __tmp511 (Get __tmp502 3))
(let __tmp512 (Single __tmp511))
(let __tmp513 (Get __tmp502 4))
(let __tmp514 (Single __tmp513))
(let __tmp515 (Const __tmp104 __tmp493 __tmp500))
(let __tmp516 (Single __tmp515))
(let __tmp517 (Single __tmp501))
(let __tmp518 (Get __tmp502 5))
(let __tmp519 (Single __tmp518))
(let __tmp520 (Get __tmp502 6))
(let __tmp521 (Single __tmp520))
(let __tmp522 (Get __tmp502 7))
(let __tmp523 (Single __tmp522))
(let __tmp524 (Get __tmp502 8))
(let __tmp525 (Single __tmp524))
(let __tmp526 (Get __tmp502 9))
(let __tmp527 (Single __tmp526))
(let __tmp528 (Get __tmp502 10))
(let __tmp529 (Single __tmp528))
(let __tmp530 (Get __tmp502 11))
(let __tmp531 (Single __tmp530))
(let __tmp532 (Get __tmp502 12))
(let __tmp533 (Single __tmp532))
(let __tmp534 (Get __tmp502 13))
(let __tmp535 (Single __tmp534))
(let __tmp536 (Single __tmp503))
(let __tmp537 (Get __tmp502 15))
(let __tmp538 (Single __tmp537))
(let __tmp539 (Get __tmp502 16))
(let __tmp540 (Single __tmp539))
(let __tmp541 (Get __tmp502 17))
(let __tmp542 (Single __tmp541))
(let __tmp543 (Concat __tmp540 __tmp542))
(let __tmp544 (Concat __tmp538 __tmp543))
(let __tmp545 (Concat __tmp536 __tmp544))
(let __tmp546 (Concat __tmp535 __tmp545))
(let __tmp547 (Concat __tmp533 __tmp546))
(let __tmp548 (Concat __tmp531 __tmp547))
(let __tmp549 (Concat __tmp529 __tmp548))
(let __tmp550 (Concat __tmp527 __tmp549))
(let __tmp551 (Concat __tmp525 __tmp550))
(let __tmp552 (Concat __tmp523 __tmp551))
(let __tmp553 (Concat __tmp521 __tmp552))
(let __tmp554 (Concat __tmp519 __tmp553))
(let __tmp555 (Concat __tmp517 __tmp554))
(let __tmp556 (Concat __tmp516 __tmp555))
(let __tmp557 (Concat __tmp514 __tmp556))
(let __tmp558 (Concat __tmp512 __tmp557))
(let __tmp559 (Concat __tmp510 __tmp558))
(let __tmp560 (Concat __tmp508 __tmp559))
(let __tmp561 (Concat __tmp506 __tmp560))
(let __tmp562 (TCons __tmp20 __tmp488))
(let __tmp563 (TCons __tmp172 __tmp562))
(let __tmp564 (TCons __tmp172 __tmp563))
(let __tmp565 (TCons __tmp20 __tmp564))
(let __tmp566 (TCons __tmp20 __tmp565))
(let __tmp567 (TCons __tmp1 __tmp566))
(let __tmp568 (TupleT __tmp567))
(let __tmp569 (InIf true __tmp504 __tmp561))
(let __tmp570 (Arg __tmp568 __tmp569))
(let __tmp571 (InFunc " loop_ctx_25"))
(let __tmp572 (Arg __tmp568 __tmp571))
(let __tmp573 (Get __tmp572 17))
(let __tmp574 (Single __tmp573))
(let __tmp575 (Get __tmp572 3))
(let __tmp576 (Single __tmp575))
(let __tmp577 (Get __tmp572 6))
(let __tmp578 (Single __tmp577))
(let __tmp579 (Get __tmp572 16))
(let __tmp580 (Single __tmp579))
(let __tmp581 (Get __tmp572 1))
(let __tmp582 (Get __tmp572 5))
(let __tmp583 (Get __tmp572 2))
(let __tmp584 (Bop __tmp292 __tmp582 __tmp583))
(let __tmp585 (Bop __tmp293 __tmp581 __tmp584))
(let __tmp586 (Get __tmp572 11))
(let __tmp587 (Bop __tmp292 __tmp585 __tmp586))
(let __tmp588 (Single __tmp587))
(let __tmp589 (Get __tmp572 18))
(let __tmp590 (Single __tmp589))
(let __tmp591 (Get __tmp572 0))
(let __tmp592 (Single __tmp591))
(let __tmp593 (Concat __tmp590 __tmp592))
(let __tmp594 (Concat __tmp588 __tmp593))
(let __tmp595 (Call "fmod" __tmp594))
(let __tmp596 (Get __tmp595 0))
(let __tmp597 (Get __tmp572 9))
(let __tmp598 (Bop __tmp293 __tmp597 __tmp589))
(let __tmp599 (Bop __tmp291 __tmp596 __tmp598))
(let __tmp600 (Single __tmp599))
(let __tmp601 (Get __tmp595 1))
(let __tmp602 (Single __tmp601))
(let __tmp603 (Concat __tmp600 __tmp602))
(let __tmp604 (Concat __tmp580 __tmp603))
(let __tmp605 (Concat __tmp578 __tmp604))
(let __tmp606 (Concat __tmp576 __tmp605))
(let __tmp607 (Concat __tmp574 __tmp606))
(let __tmp608 (Call "matrix_set" __tmp607))
(let __tmp609 (Single __tmp581))
(let __tmp610 (Single __tmp583))
(let __tmp611 (Get __tmp572 4))
(let __tmp612 (Single __tmp611))
(let __tmp613 (Single __tmp584))
(let __tmp614 (Bop __tmp326 __tmp611 __tmp577))
(let __tmp615 (Single __tmp614))
(let __tmp616 (Get __tmp572 7))
(let __tmp617 (Single __tmp616))
(let __tmp618 (Get __tmp572 8))
(let __tmp619 (Single __tmp618))
(let __tmp620 (Single __tmp597))
(let __tmp621 (Get __tmp572 10))
(let __tmp622 (Single __tmp621))
(let __tmp623 (Single __tmp586))
(let __tmp624 (Get __tmp572 12))
(let __tmp625 (Single __tmp624))
(let __tmp626 (Get __tmp572 13))
(let __tmp627 (Single __tmp626))
(let __tmp628 (Get __tmp572 14))
(let __tmp629 (Single __tmp628))
(let __tmp630 (Get __tmp572 15))
(let __tmp631 (Single __tmp630))
(let __tmp632 (Concat __tmp631 __tmp580))
(let __tmp633 (Concat __tmp629 __tmp632))
(let __tmp634 (Concat __tmp627 __tmp633))
(let __tmp635 (Concat __tmp625 __tmp634))
(let __tmp636 (Concat __tmp623 __tmp635))
(let __tmp637 (Concat __tmp622 __tmp636))
(let __tmp638 (Concat __tmp620 __tmp637))
(let __tmp639 (Concat __tmp619 __tmp638))
(let __tmp640 (Concat __tmp617 __tmp639))
(let __tmp641 (Concat __tmp615 __tmp640))
(let __tmp642 (Get __tmp572 19))
(let __tmp643 (Single __tmp642))
(let __tmp644 (Concat __tmp590 __tmp643))
(let __tmp645 (Concat __tmp574 __tmp644))
(let __tmp646 (Concat __tmp641 __tmp645))
(let __tmp647 (Concat __tmp613 __tmp646))
(let __tmp648 (Concat __tmp612 __tmp647))
(let __tmp649 (Concat __tmp576 __tmp648))
(let __tmp650 (Concat __tmp610 __tmp649))
(let __tmp651 (Concat __tmp609 __tmp650))
(let __tmp652 (Concat __tmp608 __tmp651))
(let __tmp653 (Get __tmp652 6))
(let __tmp654 (Get __tmp652 16))
(let __tmp655 (Bop __tmp171 __tmp653 __tmp654))
(let __tmp656 (Single __tmp655))
(let __tmp657 (Concat __tmp656 __tmp652))
(let __tmp658 (DoWhile __tmp570 __tmp657))
(let __tmp659 (InIf false __tmp504 __tmp561))
(let __tmp660 (Arg __tmp568 __tmp659))
(let __tmp661 (If __tmp504 __tmp561 __tmp658 __tmp660))
(let __tmp662 (Get __tmp661 0))
(let __tmp663 (Single __tmp662))
(let __tmp664 (Get __tmp661 1))
(let __tmp665 (Get __tmp661 2))
(let __tmp666 (Bop __tmp292 __tmp664 __tmp665))
(let __tmp667 (Single __tmp666))
(let __tmp668 (Single __tmp665))
(let __tmp669 (Bop __tmp326 __tmp513 __tmp511))
(let __tmp670 (Single __tmp669))
(let __tmp671 (Get __tmp661 7))
(let __tmp672 (Single __tmp671))
(let __tmp673 (Get __tmp661 9))
(let __tmp674 (Single __tmp673))
(let __tmp675 (Get __tmp661 10))
(let __tmp676 (Single __tmp675))
(let __tmp677 (Get __tmp661 11))
(let __tmp678 (Single __tmp677))
(let __tmp679 (Get __tmp661 13))
(let __tmp680 (Single __tmp679))
(let __tmp681 (Get __tmp661 14))
(let __tmp682 (Single __tmp681))
(let __tmp683 (Get __tmp661 15))
(let __tmp684 (Single __tmp683))
(let __tmp685 (Concat __tmp684 __tmp536))
(let __tmp686 (Concat __tmp682 __tmp685))
(let __tmp687 (Concat __tmp680 __tmp686))
(let __tmp688 (Get __tmp661 17))
(let __tmp689 (Single __tmp688))
(let __tmp690 (Get __tmp661 18))
(let __tmp691 (Single __tmp690))
(let __tmp692 (Concat __tmp691 __tmp542))
(let __tmp693 (Concat __tmp689 __tmp692))
(let __tmp694 (Concat __tmp687 __tmp693))
(let __tmp695 (Concat __tmp529 __tmp694))
(let __tmp696 (Concat __tmp678 __tmp695))
(let __tmp697 (Concat __tmp676 __tmp696))
(let __tmp698 (Concat __tmp674 __tmp697))
(let __tmp699 (Concat __tmp521 __tmp698))
(let __tmp700 (Concat __tmp672 __tmp699))
(let __tmp701 (Concat __tmp514 __tmp700))
(let __tmp702 (Concat __tmp670 __tmp701))
(let __tmp703 (Concat __tmp668 __tmp702))
(let __tmp704 (Concat __tmp667 __tmp703))
(let __tmp705 (Concat __tmp663 __tmp704))
(let __tmp706 (InIf false __tmp498 __tmp495))
(let __tmp707 (Arg __tmp493 __tmp706))
(let __tmp708 (If __tmp498 __tmp495 __tmp705 __tmp707))
(let __tmp709 (Concat __tmp499 __tmp708))
(let __tmp710 (DoWhile __tmp479 __tmp709))
(let __tmp711 (Get __tmp710 0))
(let __tmp712 (Single __tmp711))
(let __tmp713 (Get __tmp710 2))
(let __tmp714 (Single __tmp713))
(let __tmp715 (Get __tmp710 5))
(let __tmp716 (Single __tmp715))
(let __tmp717 (Get __tmp710 7))
(let __tmp718 (Single __tmp717))
(let __tmp719 (Get __tmp710 8))
(let __tmp720 (Single __tmp719))
(let __tmp721 (Get __tmp710 9))
(let __tmp722 (Single __tmp721))
(let __tmp723 (Get __tmp710 11))
(let __tmp724 (Single __tmp723))
(let __tmp725 (Get __tmp710 12))
(let __tmp726 (Single __tmp725))
(let __tmp727 (Get __tmp710 13))
(let __tmp728 (Single __tmp727))
(let __tmp729 (Concat __tmp728 __tmp138))
(let __tmp730 (Concat __tmp726 __tmp729))
(let __tmp731 (Concat __tmp724 __tmp730))
(let __tmp732 (Concat __tmp129 __tmp731))
(let __tmp733 (Concat __tmp722 __tmp732))
(let __tmp734 (Concat __tmp720 __tmp733))
(let __tmp735 (Concat __tmp718 __tmp734))
(let __tmp736 (Concat __tmp119 __tmp735))
(let __tmp737 (Concat __tmp716 __tmp736))
(let __tmp738 (Concat __tmp115 __tmp737))
(let __tmp739 (Concat __tmp112 __tmp738))
(let __tmp740 (Concat __tmp714 __tmp739))
(let __tmp741 (Concat __tmp106 __tmp740))
(let __tmp742 (Concat __tmp712 __tmp741))
(let __tmp743 (TCons __tmp20 __tmp174))
(let __tmp744 (TCons __tmp21 __tmp743))
(let __tmp745 (TCons __tmp172 __tmp744))
(let __tmp746 (TCons __tmp20 __tmp745))
(let __tmp747 (TCons __tmp20 __tmp746))
(let __tmp748 (TCons __tmp20 __tmp747))
(let __tmp749 (TCons __tmp172 __tmp748))
(let __tmp750 (TCons __tmp21 __tmp749))
(let __tmp751 (TCons __tmp172 __tmp750))
(let __tmp752 (TCons __tmp172 __tmp751))
(let __tmp753 (TCons __tmp20 __tmp752))
(let __tmp754 (TCons __tmp20 __tmp753))
(let __tmp755 (TCons __tmp1 __tmp754))
(let __tmp756 (TupleT __tmp755))
(let __tmp757 (InFunc " loop_ctx_21"))
(let __tmp758 (Arg __tmp756 __tmp757))
(let __tmp759 (Get __tmp758 3))
(let __tmp760 (Get __tmp758 14))
(let __tmp761 (Bop __tmp171 __tmp759 __tmp760))
(let __tmp762 (Single __tmp761))
(let __tmp763 (InIf true __tmp761 __tmp758))
(let __tmp764 (Const __tmp110 __tmp756 __tmp763))
(let __tmp765 (Arg __tmp756 __tmp763))
(let __tmp766 (Get __tmp765 10))
(let __tmp767 (Bop __tmp171 __tmp764 __tmp766))
(let __tmp768 (Get __tmp765 0))
(let __tmp769 (Single __tmp768))
(let __tmp770 (Get __tmp765 1))
(let __tmp771 (Single __tmp770))
(let __tmp772 (Get __tmp765 2))
(let __tmp773 (Single __tmp772))
(let __tmp774 (Get __tmp765 3))
(let __tmp775 (Single __tmp774))
(let __tmp776 (Get __tmp765 4))
(let __tmp777 (Single __tmp776))
(let __tmp778 (Const __tmp104 __tmp756 __tmp763))
(let __tmp779 (Single __tmp778))
(let __tmp780 (Single __tmp764))
(let __tmp781 (Get __tmp765 5))
(let __tmp782 (Single __tmp781))
(let __tmp783 (Get __tmp765 6))
(let __tmp784 (Single __tmp783))
(let __tmp785 (Get __tmp765 7))
(let __tmp786 (Single __tmp785))
(let __tmp787 (Get __tmp765 8))
(let __tmp788 (Single __tmp787))
(let __tmp789 (Get __tmp765 9))
(let __tmp790 (Single __tmp789))
(let __tmp791 (Single __tmp766))
(let __tmp792 (Get __tmp765 11))
(let __tmp793 (Single __tmp792))
(let __tmp794 (Get __tmp765 12))
(let __tmp795 (Single __tmp794))
(let __tmp796 (Get __tmp765 13))
(let __tmp797 (Single __tmp796))
(let __tmp798 (Get __tmp765 14))
(let __tmp799 (Single __tmp798))
(let __tmp800 (Concat __tmp797 __tmp799))
(let __tmp801 (Concat __tmp795 __tmp800))
(let __tmp802 (Concat __tmp793 __tmp801))
(let __tmp803 (Concat __tmp791 __tmp802))
(let __tmp804 (Concat __tmp790 __tmp803))
(let __tmp805 (Concat __tmp788 __tmp804))
(let __tmp806 (Concat __tmp786 __tmp805))
(let __tmp807 (Concat __tmp784 __tmp806))
(let __tmp808 (Concat __tmp782 __tmp807))
(let __tmp809 (Concat __tmp780 __tmp808))
(let __tmp810 (Concat __tmp779 __tmp809))
(let __tmp811 (Concat __tmp777 __tmp810))
(let __tmp812 (Concat __tmp775 __tmp811))
(let __tmp813 (Concat __tmp773 __tmp812))
(let __tmp814 (Concat __tmp771 __tmp813))
(let __tmp815 (Concat __tmp769 __tmp814))
(let __tmp816 (TCons __tmp20 __tmp751))
(let __tmp817 (TCons __tmp172 __tmp816))
(let __tmp818 (TCons __tmp172 __tmp817))
(let __tmp819 (TCons __tmp20 __tmp818))
(let __tmp820 (TCons __tmp20 __tmp819))
(let __tmp821 (TCons __tmp1 __tmp820))
(let __tmp822 (TupleT __tmp821))
(let __tmp823 (InIf true __tmp767 __tmp815))
(let __tmp824 (Arg __tmp822 __tmp823))
(let __tmp825 (InFunc " loop_ctx_26"))
(let __tmp826 (Arg __tmp822 __tmp825))
(let __tmp827 (Get __tmp826 13))
(let __tmp828 (Single __tmp827))
(let __tmp829 (Get __tmp826 3))
(let __tmp830 (Single __tmp829))
(let __tmp831 (Get __tmp826 6))
(let __tmp832 (Single __tmp831))
(let __tmp833 (Get __tmp826 12))
(let __tmp834 (Single __tmp833))
(let __tmp835 (Get __tmp826 1))
(let __tmp836 (Get __tmp826 5))
(let __tmp837 (Get __tmp826 15))
(let __tmp838 (Bop __tmp292 __tmp836 __tmp837))
(let __tmp839 (Bop __tmp293 __tmp835 __tmp838))
(let __tmp840 (Single __tmp839))
(let __tmp841 (Get __tmp826 14))
(let __tmp842 (Single __tmp841))
(let __tmp843 (Get __tmp826 0))
(let __tmp844 (Single __tmp843))
(let __tmp845 (Concat __tmp842 __tmp844))
(let __tmp846 (Concat __tmp840 __tmp845))
(let __tmp847 (Call "fmod" __tmp846))
(let __tmp848 (Get __tmp847 0))
(let __tmp849 (Get __tmp826 9))
(let __tmp850 (Bop __tmp293 __tmp849 __tmp841))
(let __tmp851 (Bop __tmp291 __tmp848 __tmp850))
(let __tmp852 (Single __tmp851))
(let __tmp853 (Get __tmp847 1))
(let __tmp854 (Single __tmp853))
(let __tmp855 (Concat __tmp852 __tmp854))
(let __tmp856 (Concat __tmp834 __tmp855))
(let __tmp857 (Concat __tmp832 __tmp856))
(let __tmp858 (Concat __tmp830 __tmp857))
(let __tmp859 (Concat __tmp828 __tmp858))
(let __tmp860 (Call "matrix_set" __tmp859))
(let __tmp861 (Single __tmp835))
(let __tmp862 (Get __tmp826 2))
(let __tmp863 (Single __tmp862))
(let __tmp864 (Get __tmp826 4))
(let __tmp865 (Single __tmp864))
(let __tmp866 (Bop __tmp292 __tmp836 __tmp862))
(let __tmp867 (Single __tmp866))
(let __tmp868 (Bop __tmp326 __tmp864 __tmp831))
(let __tmp869 (Single __tmp868))
(let __tmp870 (Get __tmp826 7))
(let __tmp871 (Single __tmp870))
(let __tmp872 (Get __tmp826 8))
(let __tmp873 (Single __tmp872))
(let __tmp874 (Single __tmp849))
(let __tmp875 (Get __tmp826 10))
(let __tmp876 (Single __tmp875))
(let __tmp877 (Get __tmp826 11))
(let __tmp878 (Single __tmp877))
(let __tmp879 (Concat __tmp878 __tmp834))
(let __tmp880 (Concat __tmp876 __tmp879))
(let __tmp881 (Concat __tmp874 __tmp880))
(let __tmp882 (Concat __tmp873 __tmp881))
(let __tmp883 (Single __tmp837))
(let __tmp884 (Get __tmp826 16))
(let __tmp885 (Single __tmp884))
(let __tmp886 (Concat __tmp883 __tmp885))
(let __tmp887 (Concat __tmp842 __tmp886))
(let __tmp888 (Concat __tmp828 __tmp887))
(let __tmp889 (Concat __tmp882 __tmp888))
(let __tmp890 (Concat __tmp871 __tmp889))
(let __tmp891 (Concat __tmp869 __tmp890))
(let __tmp892 (Concat __tmp867 __tmp891))
(let __tmp893 (Concat __tmp865 __tmp892))
(let __tmp894 (Concat __tmp830 __tmp893))
(let __tmp895 (Concat __tmp863 __tmp894))
(let __tmp896 (Concat __tmp861 __tmp895))
(let __tmp897 (Concat __tmp860 __tmp896))
(let __tmp898 (Get __tmp897 6))
(let __tmp899 (Get __tmp897 12))
(let __tmp900 (Bop __tmp171 __tmp898 __tmp899))
(let __tmp901 (Single __tmp900))
(let __tmp902 (Concat __tmp901 __tmp897))
(let __tmp903 (DoWhile __tmp824 __tmp902))
(let __tmp904 (InIf false __tmp767 __tmp815))
(let __tmp905 (Arg __tmp822 __tmp904))
(let __tmp906 (If __tmp767 __tmp815 __tmp903 __tmp905))
(let __tmp907 (Get __tmp906 0))
(let __tmp908 (Single __tmp907))
(let __tmp909 (Get __tmp906 1))
(let __tmp910 (Get __tmp906 2))
(let __tmp911 (Bop __tmp292 __tmp909 __tmp910))
(let __tmp912 (Single __tmp911))
(let __tmp913 (Single __tmp910))
(let __tmp914 (Bop __tmp326 __tmp776 __tmp774))
(let __tmp915 (Single __tmp914))
(let __tmp916 (Get __tmp906 7))
(let __tmp917 (Single __tmp916))
(let __tmp918 (Get __tmp906 9))
(let __tmp919 (Single __tmp918))
(let __tmp920 (Get __tmp906 10))
(let __tmp921 (Single __tmp920))
(let __tmp922 (Get __tmp906 11))
(let __tmp923 (Single __tmp922))
(let __tmp924 (Concat __tmp923 __tmp791))
(let __tmp925 (Concat __tmp921 __tmp924))
(let __tmp926 (Concat __tmp919 __tmp925))
(let __tmp927 (Get __tmp906 13))
(let __tmp928 (Single __tmp927))
(let __tmp929 (Get __tmp906 14))
(let __tmp930 (Single __tmp929))
(let __tmp931 (Get __tmp906 15))
(let __tmp932 (Single __tmp931))
(let __tmp933 (Concat __tmp932 __tmp799))
(let __tmp934 (Concat __tmp930 __tmp933))
(let __tmp935 (Concat __tmp928 __tmp934))
(let __tmp936 (Concat __tmp926 __tmp935))
(let __tmp937 (Concat __tmp784 __tmp936))
(let __tmp938 (Concat __tmp917 __tmp937))
(let __tmp939 (Concat __tmp777 __tmp938))
(let __tmp940 (Concat __tmp915 __tmp939))
(let __tmp941 (Concat __tmp913 __tmp940))
(let __tmp942 (Concat __tmp912 __tmp941))
(let __tmp943 (Concat __tmp908 __tmp942))
(let __tmp944 (InIf false __tmp761 __tmp758))
(let __tmp945 (Arg __tmp756 __tmp944))
(let __tmp946 (If __tmp761 __tmp758 __tmp943 __tmp945))
(let __tmp947 (Concat __tmp762 __tmp946))
(let __tmp948 (DoWhile __tmp742 __tmp947))
(let __tmp949 (Get __tmp948 0))
(let __tmp950 (Single __tmp949))
(let __tmp951 (Get __tmp948 2))
(let __tmp952 (Single __tmp951))
(let __tmp953 (Get __tmp948 5))
(let __tmp954 (Single __tmp953))
(let __tmp955 (Get __tmp948 7))
(let __tmp956 (Single __tmp955))
(let __tmp957 (Get __tmp948 8))
(let __tmp958 (Single __tmp957))
(let __tmp959 (Get __tmp948 9))
(let __tmp960 (Single __tmp959))
(let __tmp961 (Concat __tmp960 __tmp129))
(let __tmp962 (Concat __tmp958 __tmp961))
(let __tmp963 (Concat __tmp956 __tmp962))
(let __tmp964 (Concat __tmp119 __tmp963))
(let __tmp965 (Concat __tmp954 __tmp964))
(let __tmp966 (Concat __tmp115 __tmp965))
(let __tmp967 (Concat __tmp112 __tmp966))
(let __tmp968 (Concat __tmp952 __tmp967))
(let __tmp969 (Concat __tmp106 __tmp968))
(let __tmp970 (Concat __tmp950 __tmp969))
(let __tmp971 (TCons __tmp20 __tmp743))
(let __tmp972 (TCons __tmp172 __tmp971))
(let __tmp973 (TCons __tmp21 __tmp972))
(let __tmp974 (TCons __tmp172 __tmp973))
(let __tmp975 (TCons __tmp172 __tmp974))
(let __tmp976 (TCons __tmp20 __tmp975))
(let __tmp977 (TCons __tmp20 __tmp976))
(let __tmp978 (TCons __tmp1 __tmp977))
(let __tmp979 (TupleT __tmp978))
(let __tmp980 (InFunc " loop_ctx_20"))
(let __tmp981 (Arg __tmp979 __tmp980))
(let __tmp982 (Get __tmp981 3))
(let __tmp983 (Get __tmp981 10))
(let __tmp984 (Bop __tmp171 __tmp982 __tmp983))
(let __tmp985 (Single __tmp984))
(let __tmp986 (InIf true __tmp984 __tmp981))
(let __tmp987 (Const __tmp110 __tmp979 __tmp986))
(let __tmp988 (Arg __tmp979 __tmp986))
(let __tmp989 (Get __tmp988 6))
(let __tmp990 (Bop __tmp171 __tmp987 __tmp989))
(let __tmp991 (Get __tmp988 0))
(let __tmp992 (Single __tmp991))
(let __tmp993 (Get __tmp988 1))
(let __tmp994 (Single __tmp993))
(let __tmp995 (Get __tmp988 2))
(let __tmp996 (Single __tmp995))
(let __tmp997 (Get __tmp988 3))
(let __tmp998 (Single __tmp997))
(let __tmp999 (Get __tmp988 4))
(let __tmp1000 (Single __tmp999))
(let __tmp1001 (Const __tmp104 __tmp979 __tmp986))
(let __tmp1002 (Single __tmp1001))
(let __tmp1003 (Single __tmp987))
(let __tmp1004 (Get __tmp988 5))
(let __tmp1005 (Single __tmp1004))
(let __tmp1006 (Single __tmp989))
(let __tmp1007 (Get __tmp988 7))
(let __tmp1008 (Single __tmp1007))
(let __tmp1009 (Get __tmp988 8))
(let __tmp1010 (Single __tmp1009))
(let __tmp1011 (Get __tmp988 9))
(let __tmp1012 (Single __tmp1011))
(let __tmp1013 (Get __tmp988 10))
(let __tmp1014 (Single __tmp1013))
(let __tmp1015 (Concat __tmp1012 __tmp1014))
(let __tmp1016 (Concat __tmp1010 __tmp1015))
(let __tmp1017 (Concat __tmp1008 __tmp1016))
(let __tmp1018 (Concat __tmp1006 __tmp1017))
(let __tmp1019 (Concat __tmp1005 __tmp1018))
(let __tmp1020 (Concat __tmp1003 __tmp1019))
(let __tmp1021 (Concat __tmp1002 __tmp1020))
(let __tmp1022 (Concat __tmp1000 __tmp1021))
(let __tmp1023 (Concat __tmp998 __tmp1022))
(let __tmp1024 (Concat __tmp996 __tmp1023))
(let __tmp1025 (Concat __tmp994 __tmp1024))
(let __tmp1026 (Concat __tmp992 __tmp1025))
(let __tmp1027 (TCons __tmp20 __tmp974))
(let __tmp1028 (TCons __tmp172 __tmp1027))
(let __tmp1029 (TCons __tmp172 __tmp1028))
(let __tmp1030 (TCons __tmp20 __tmp1029))
(let __tmp1031 (TCons __tmp20 __tmp1030))
(let __tmp1032 (TCons __tmp1 __tmp1031))
(let __tmp1033 (TupleT __tmp1032))
(let __tmp1034 (InIf true __tmp990 __tmp1026))
(let __tmp1035 (Arg __tmp1033 __tmp1034))
(let __tmp1036 (InFunc " loop_ctx_27"))
(let __tmp1037 (Arg __tmp1033 __tmp1036))
(let __tmp1038 (Get __tmp1037 7))
(let __tmp1039 (Single __tmp1038))
(let __tmp1040 (Get __tmp1037 3))
(let __tmp1041 (Single __tmp1040))
(let __tmp1042 (Get __tmp1037 6))
(let __tmp1043 (Single __tmp1042))
(let __tmp1044 (Get __tmp1037 8))
(let __tmp1045 (Single __tmp1044))
(let __tmp1046 (Get __tmp1037 1))
(let __tmp1047 (Get __tmp1037 5))
(let __tmp1048 (Get __tmp1037 11))
(let __tmp1049 (Bop __tmp292 __tmp1047 __tmp1048))
(let __tmp1050 (Bop __tmp293 __tmp1046 __tmp1049))
(let __tmp1051 (Bop __tmp292 __tmp1050 __tmp1048))
(let __tmp1052 (Single __tmp1051))
(let __tmp1053 (Get __tmp1037 10))
(let __tmp1054 (Single __tmp1053))
(let __tmp1055 (Get __tmp1037 0))
(let __tmp1056 (Single __tmp1055))
(let __tmp1057 (Concat __tmp1054 __tmp1056))
(let __tmp1058 (Concat __tmp1052 __tmp1057))
(let __tmp1059 (Call "fmod" __tmp1058))
(let __tmp1060 (Get __tmp1059 0))
(let __tmp1061 (Get __tmp1037 9))
(let __tmp1062 (Bop __tmp293 __tmp1061 __tmp1053))
(let __tmp1063 (Bop __tmp291 __tmp1060 __tmp1062))
(let __tmp1064 (Single __tmp1063))
(let __tmp1065 (Get __tmp1059 1))
(let __tmp1066 (Single __tmp1065))
(let __tmp1067 (Concat __tmp1064 __tmp1066))
(let __tmp1068 (Concat __tmp1045 __tmp1067))
(let __tmp1069 (Concat __tmp1043 __tmp1068))
(let __tmp1070 (Concat __tmp1041 __tmp1069))
(let __tmp1071 (Concat __tmp1039 __tmp1070))
(let __tmp1072 (Call "matrix_set" __tmp1071))
(let __tmp1073 (Single __tmp1046))
(let __tmp1074 (Get __tmp1037 2))
(let __tmp1075 (Single __tmp1074))
(let __tmp1076 (Get __tmp1037 4))
(let __tmp1077 (Single __tmp1076))
(let __tmp1078 (Bop __tmp292 __tmp1047 __tmp1074))
(let __tmp1079 (Single __tmp1078))
(let __tmp1080 (Bop __tmp326 __tmp1076 __tmp1042))
(let __tmp1081 (Single __tmp1080))
(let __tmp1082 (Single __tmp1061))
(let __tmp1083 (Single __tmp1048))
(let __tmp1084 (Get __tmp1037 12))
(let __tmp1085 (Single __tmp1084))
(let __tmp1086 (Concat __tmp1083 __tmp1085))
(let __tmp1087 (Concat __tmp1054 __tmp1086))
(let __tmp1088 (Concat __tmp1082 __tmp1087))
(let __tmp1089 (Concat __tmp1045 __tmp1088))
(let __tmp1090 (Concat __tmp1039 __tmp1089))
(let __tmp1091 (Concat __tmp1081 __tmp1090))
(let __tmp1092 (Concat __tmp1079 __tmp1091))
(let __tmp1093 (Concat __tmp1077 __tmp1092))
(let __tmp1094 (Concat __tmp1041 __tmp1093))
(let __tmp1095 (Concat __tmp1075 __tmp1094))
(let __tmp1096 (Concat __tmp1073 __tmp1095))
(let __tmp1097 (Concat __tmp1072 __tmp1096))
(let __tmp1098 (Get __tmp1097 6))
(let __tmp1099 (Get __tmp1097 8))
(let __tmp1100 (Bop __tmp171 __tmp1098 __tmp1099))
(let __tmp1101 (Single __tmp1100))
(let __tmp1102 (Concat __tmp1101 __tmp1097))
(let __tmp1103 (DoWhile __tmp1035 __tmp1102))
(let __tmp1104 (InIf false __tmp990 __tmp1026))
(let __tmp1105 (Arg __tmp1033 __tmp1104))
(let __tmp1106 (If __tmp990 __tmp1026 __tmp1103 __tmp1105))
(let __tmp1107 (Get __tmp1106 0))
(let __tmp1108 (Single __tmp1107))
(let __tmp1109 (Get __tmp1106 1))
(let __tmp1110 (Get __tmp1106 2))
(let __tmp1111 (Bop __tmp292 __tmp1109 __tmp1110))
(let __tmp1112 (Single __tmp1111))
(let __tmp1113 (Single __tmp1110))
(let __tmp1114 (Bop __tmp326 __tmp999 __tmp997))
(let __tmp1115 (Single __tmp1114))
(let __tmp1116 (Get __tmp1106 7))
(let __tmp1117 (Single __tmp1116))
(let __tmp1118 (Get __tmp1106 9))
(let __tmp1119 (Single __tmp1118))
(let __tmp1120 (Get __tmp1106 10))
(let __tmp1121 (Single __tmp1120))
(let __tmp1122 (Get __tmp1106 11))
(let __tmp1123 (Single __tmp1122))
(let __tmp1124 (Concat __tmp1123 __tmp1014))
(let __tmp1125 (Concat __tmp1121 __tmp1124))
(let __tmp1126 (Concat __tmp1119 __tmp1125))
(let __tmp1127 (Concat __tmp1006 __tmp1126))
(let __tmp1128 (Concat __tmp1117 __tmp1127))
(let __tmp1129 (Concat __tmp1000 __tmp1128))
(let __tmp1130 (Concat __tmp1115 __tmp1129))
(let __tmp1131 (Concat __tmp1113 __tmp1130))
(let __tmp1132 (Concat __tmp1112 __tmp1131))
(let __tmp1133 (Concat __tmp1108 __tmp1132))
(let __tmp1134 (InIf false __tmp984 __tmp981))
(let __tmp1135 (Arg __tmp979 __tmp1134))
(let __tmp1136 (If __tmp984 __tmp981 __tmp1133 __tmp1135))
(let __tmp1137 (Concat __tmp985 __tmp1136))
(let __tmp1138 (DoWhile __tmp970 __tmp1137))
(let __tmp1139 (Get __tmp1138 0))
(let __tmp1140 (Single __tmp1139))
(let __tmp1141 (Concat __tmp25 __tmp101))
(let __tmp1142 (Concat __tmp7 __tmp1141))
(let __tmp1143 (Call "matrix_new" __tmp1142))
(let __tmp1144 (Get __tmp1142 1))
(let __tmp1145 (Get __tmp1142 0))
(let __tmp1146 (Bop __tmp15 __tmp1144 __tmp1145))
(let __tmp1147 (Get __tmp1142 2))
(let __tmp1148 (Alloc 0 __tmp1146 __tmp1147 __tmp21))
(let __tmp1149 (TCons __tmp172 __tmp173))
(let __tmp1150 (TCons __tmp20 __tmp1149))
(let __tmp1151 (TCons __tmp172 __tmp1150))
(let __tmp1152 (TCons __tmp172 __tmp1151))
(let __tmp1153 (TCons __tmp172 __tmp1152))
(let __tmp1154 (TCons __tmp172 __tmp1153))
(let __tmp1155 (TCons __tmp172 __tmp1154))
(let __tmp1156 (TCons __tmp172 __tmp1155))
(let __tmp1157 (TCons __tmp21 __tmp1156))
(let __tmp1158 (TCons __tmp21 __tmp1157))
(let __tmp1159 (TCons __tmp21 __tmp1158))
(let __tmp1160 (TCons __tmp21 __tmp1159))
(let __tmp1161 (TCons __tmp21 __tmp1160))
(let __tmp1162 (TCons __tmp1 __tmp1161))
(let __tmp1163 (TupleT __tmp1162))
(let __tmp1164 (InFunc " loop_ctx_3"))
(let __tmp1165 (Arg __tmp1163 __tmp1164))
(let __tmp1166 (Get __tmp1165 10))
(let __tmp1167 (Get __tmp1165 11))
(let __tmp1168 (Bop __tmp171 __tmp1166 __tmp1167))
(let __tmp1169 (InIf true __tmp1168 __tmp1165))
(let __tmp1170 (Arg __tmp1163 __tmp1169))
(let __tmp1171 (Get __tmp1170 1))
(let __tmp1172 (Single __tmp1171))
(let __tmp1173 (Get __tmp1170 8))
(let __tmp1174 (Single __tmp1173))
(let __tmp1175 (Get __tmp1170 10))
(let __tmp1176 (Single __tmp1175))
(let __tmp1177 (Get __tmp1170 11))
(let __tmp1178 (Single __tmp1177))
(let __tmp1179 (Get __tmp1170 12))
(let __tmp1180 (Single __tmp1179))
(let __tmp1181 (Get __tmp1170 0))
(let __tmp1182 (Single __tmp1181))
(let __tmp1183 (Concat __tmp1180 __tmp1182))
(let __tmp1184 (Concat __tmp1178 __tmp1183))
(let __tmp1185 (Concat __tmp1176 __tmp1184))
(let __tmp1186 (Concat __tmp1174 __tmp1185))
(let __tmp1187 (Concat __tmp1172 __tmp1186))
(let __tmp1188 (Call "matrix_set" __tmp1187))
(let __tmp1189 (Write ))
(let __tmp1190 (Get __tmp1187 0))
(let __tmp1191 (Single __tmp1190))
(let __tmp1192 (Get __tmp1187 1))
(let __tmp1193 (Single __tmp1192))
(let __tmp1194 (Get __tmp1187 2))
(let __tmp1195 (Single __tmp1194))
(let __tmp1196 (Get __tmp1187 3))
(let __tmp1197 (Single __tmp1196))
(let __tmp1198 (Get __tmp1187 5))
(let __tmp1199 (Single __tmp1198))
(let __tmp1200 (Concat __tmp1197 __tmp1199))
(let __tmp1201 (Concat __tmp1195 __tmp1200))
(let __tmp1202 (Concat __tmp1193 __tmp1201))
(let __tmp1203 (Concat __tmp1191 __tmp1202))
(let __tmp1204 (Call "matrix_loc" __tmp1203))
(let __tmp1205 (Get __tmp1204 0))
(let __tmp1206 (Get __tmp1187 4))
(let __tmp1207 (Get __tmp1204 1))
(let __tmp1208 (Top __tmp1189 __tmp1205 __tmp1206 __tmp1207))
(let __tmp1209 (Single __tmp1208))
(let __tmp1210 (TCons __tmp172 __tmp1156))
(let __tmp1211 (TCons __tmp21 __tmp1210))
(let __tmp1212 (TCons __tmp21 __tmp1211))
(let __tmp1213 (TCons __tmp21 __tmp1212))
(let __tmp1214 (TCons __tmp21 __tmp1213))
(let __tmp1215 (TCons __tmp21 __tmp1214))
(let __tmp1216 (TCons __tmp1 __tmp1215))
(let __tmp1217 (TupleT __tmp1216))
(let __tmp1218 (InFunc " loop_ctx_4"))
(let __tmp1219 (Arg __tmp1217 __tmp1218))
(let __tmp1220 (Get __tmp1219 5))
(let __tmp1221 (Single __tmp1220))
(let __tmp1222 (Get __tmp1219 8))
(let __tmp1223 (Single __tmp1222))
(let __tmp1224 (Get __tmp1219 11))
(let __tmp1225 (Single __tmp1224))
(let __tmp1226 (Get __tmp1219 15))
(let __tmp1227 (Single __tmp1226))
(let __tmp1228 (Get __tmp1219 0))
(let __tmp1229 (Single __tmp1228))
(let __tmp1230 (Concat __tmp1227 __tmp1229))
(let __tmp1231 (Concat __tmp1225 __tmp1230))
(let __tmp1232 (Concat __tmp1223 __tmp1231))
(let __tmp1233 (Concat __tmp1221 __tmp1232))
(let __tmp1234 (Call "matrix_get" __tmp1233))
(let __tmp1235 (Load ))
(let __tmp1236 (Call "matrix_loc" __tmp1233))
(let __tmp1237 (Get __tmp1236 0))
(let __tmp1238 (Get __tmp1236 1))
(let __tmp1239 (Bop __tmp1235 __tmp1237 __tmp1238))
(let __tmp1240 (Get __tmp1219 4))
(let __tmp1241 (Single __tmp1240))
(let __tmp1242 (Get __tmp1219 10))
(let __tmp1243 (Single __tmp1242))
(let __tmp1244 (Get __tmp1219 12))
(let __tmp1245 (Single __tmp1244))
(let __tmp1246 (Get __tmp1234 1))
(let __tmp1247 (Single __tmp1246))
(let __tmp1248 (Concat __tmp1245 __tmp1247))
(let __tmp1249 (Concat __tmp1243 __tmp1248))
(let __tmp1250 (Concat __tmp1225 __tmp1249))
(let __tmp1251 (Concat __tmp1241 __tmp1250))
(let __tmp1252 (Call "matrix_get" __tmp1251))
(let __tmp1253 (Call "matrix_loc" __tmp1251))
(let __tmp1254 (Get __tmp1253 0))
(let __tmp1255 (Get __tmp1253 1))
(let __tmp1256 (Bop __tmp1235 __tmp1254 __tmp1255))
(let __tmp1257 (Get __tmp1219 1))
(let __tmp1258 (Single __tmp1257))
(let __tmp1259 (Get __tmp1234 0))
(let __tmp1260 (Get __tmp1252 0))
(let __tmp1261 (Bop __tmp293 __tmp1259 __tmp1260))
(let __tmp1262 (Single __tmp1261))
(let __tmp1263 (Get __tmp1252 1))
(let __tmp1264 (Single __tmp1263))
(let __tmp1265 (Concat __tmp1262 __tmp1264))
(let __tmp1266 (Concat __tmp1245 __tmp1265))
(let __tmp1267 (Concat __tmp1243 __tmp1266))
(let __tmp1268 (Concat __tmp1223 __tmp1267))
(let __tmp1269 (Concat __tmp1258 __tmp1268))
(let __tmp1270 (Call "matrix_incr" __tmp1269))
(let __tmp1271 (Get __tmp1269 0))
(let __tmp1272 (Single __tmp1271))
(let __tmp1273 (Get __tmp1269 1))
(let __tmp1274 (Single __tmp1273))
(let __tmp1275 (Get __tmp1269 2))
(let __tmp1276 (Single __tmp1275))
(let __tmp1277 (Get __tmp1269 3))
(let __tmp1278 (Single __tmp1277))
(let __tmp1279 (Get __tmp1269 5))
(let __tmp1280 (Single __tmp1279))
(let __tmp1281 (Concat __tmp1278 __tmp1280))
(let __tmp1282 (Concat __tmp1276 __tmp1281))
(let __tmp1283 (Concat __tmp1274 __tmp1282))
(let __tmp1284 (Concat __tmp1272 __tmp1283))
(let __tmp1285 (Call "matrix_loc" __tmp1284))
(let __tmp1286 (Get __tmp1285 0))
(let __tmp1287 (Get __tmp1285 1))
(let __tmp1288 (Bop __tmp1235 __tmp1286 __tmp1287))
(let __tmp1289 (Get __tmp1288 0))
(let __tmp1290 (Get __tmp1269 4))
(let __tmp1291 (Bop __tmp292 __tmp1289 __tmp1290))
(let __tmp1292 (Get __tmp1288 1))
(let __tmp1293 (Top __tmp1189 __tmp1286 __tmp1291 __tmp1292))
(let __tmp1294 (Single __tmp1293))
(let __tmp1295 (Get __tmp1143 1))
(let __tmp1296 (Single __tmp1295))
(let __tmp1297 (Get __tmp1143 0))
(let __tmp1298 (Single __tmp1297))
(let __tmp1299 (Concat __tmp38 __tmp10))
(let __tmp1300 (Concat __tmp106 __tmp1299))
(let __tmp1301 (Concat __tmp25 __tmp1300))
(let __tmp1302 (Concat __tmp115 __tmp1301))
(let __tmp1303 (Concat __tmp112 __tmp1302))
(let __tmp1304 (Concat __tmp51 __tmp1303))
(let __tmp1305 (Concat __tmp7 __tmp1304))
(let __tmp1306 (Concat __tmp63 __tmp1305))
(let __tmp1307 (Concat __tmp65 __tmp1306))
(let __tmp1308 (Concat __tmp67 __tmp1307))
(let __tmp1309 (Concat __tmp69 __tmp1308))
(let __tmp1310 (Concat __tmp1298 __tmp1309))
(let __tmp1311 (Concat __tmp1296 __tmp1310))
(let __tmp1312 (TCons __tmp21 __tmp1155))
(let __tmp1313 (TCons __tmp21 __tmp1312))
(let __tmp1314 (TCons __tmp21 __tmp1313))
(let __tmp1315 (TCons __tmp21 __tmp1314))
(let __tmp1316 (TCons __tmp21 __tmp1315))
(let __tmp1317 (TCons __tmp1 __tmp1316))
(let __tmp1318 (TupleT __tmp1317))
(let __tmp1319 (InFunc " loop_ctx_2"))
(let __tmp1320 (Arg __tmp1318 __tmp1319))
(let __tmp1321 (Get __tmp1320 8))
(let __tmp1322 (Get __tmp1320 6))
(let __tmp1323 (Bop __tmp171 __tmp1321 __tmp1322))
(let __tmp1324 (Single __tmp1323))
(let __tmp1325 (InIf true __tmp1323 __tmp1320))
(let __tmp1326 (Arg __tmp1318 __tmp1325))
(let __tmp1327 (Get __tmp1326 0))
(let __tmp1328 (Single __tmp1327))
(let __tmp1329 (Get __tmp1326 1))
(let __tmp1330 (Single __tmp1329))
(let __tmp1331 (Get __tmp1326 2))
(let __tmp1332 (Single __tmp1331))
(let __tmp1333 (Get __tmp1326 3))
(let __tmp1334 (Single __tmp1333))
(let __tmp1335 (Get __tmp1326 4))
(let __tmp1336 (Single __tmp1335))
(let __tmp1337 (Get __tmp1326 5))
(let __tmp1338 (Single __tmp1337))
(let __tmp1339 (Get __tmp1326 6))
(let __tmp1340 (Single __tmp1339))
(let __tmp1341 (Get __tmp1326 7))
(let __tmp1342 (Single __tmp1341))
(let __tmp1343 (Get __tmp1326 8))
(let __tmp1344 (Single __tmp1343))
(let __tmp1345 (Get __tmp1326 9))
(let __tmp1346 (Single __tmp1345))
(let __tmp1347 (Const __tmp110 __tmp1318 __tmp1325))
(let __tmp1348 (Single __tmp1347))
(let __tmp1349 (Get __tmp1326 10))
(let __tmp1350 (Single __tmp1349))
(let __tmp1351 (Get __tmp1326 11))
(let __tmp1352 (Single __tmp1351))
(let __tmp1353 (Get __tmp1326 12))
(let __tmp1354 (Single __tmp1353))
(let __tmp1355 (Get __tmp1326 13))
(let __tmp1356 (Single __tmp1355))
(let __tmp1357 (Concat __tmp1354 __tmp1356))
(let __tmp1358 (Concat __tmp1352 __tmp1357))
(let __tmp1359 (Concat __tmp1350 __tmp1358))
(let __tmp1360 (Concat __tmp1348 __tmp1359))
(let __tmp1361 (Concat __tmp1346 __tmp1360))
(let __tmp1362 (Concat __tmp1344 __tmp1361))
(let __tmp1363 (Concat __tmp1342 __tmp1362))
(let __tmp1364 (Concat __tmp1340 __tmp1363))
(let __tmp1365 (Concat __tmp1338 __tmp1364))
(let __tmp1366 (Concat __tmp1336 __tmp1365))
(let __tmp1367 (Concat __tmp1334 __tmp1366))
(let __tmp1368 (Concat __tmp1332 __tmp1367))
(let __tmp1369 (Concat __tmp1330 __tmp1368))
(let __tmp1370 (Concat __tmp1328 __tmp1369))
(let __tmp1371 (Single __tmp1168))
(let __tmp1372 (Get __tmp1170 2))
(let __tmp1373 (Single __tmp1372))
(let __tmp1374 (Get __tmp1170 3))
(let __tmp1375 (Single __tmp1374))
(let __tmp1376 (Get __tmp1170 4))
(let __tmp1377 (Single __tmp1376))
(let __tmp1378 (Get __tmp1170 5))
(let __tmp1379 (Single __tmp1378))
(let __tmp1380 (Get __tmp1170 6))
(let __tmp1381 (Single __tmp1380))
(let __tmp1382 (Get __tmp1170 7))
(let __tmp1383 (Single __tmp1382))
(let __tmp1384 (Get __tmp1170 9))
(let __tmp1385 (Single __tmp1384))
(let __tmp1386 (Const __tmp110 __tmp1163 __tmp1169))
(let __tmp1387 (Single __tmp1386))
(let __tmp1388 (Get __tmp1170 13))
(let __tmp1389 (Single __tmp1388))
(let __tmp1390 (Get __tmp1170 14))
(let __tmp1391 (Single __tmp1390))
(let __tmp1392 (Concat __tmp1389 __tmp1391))
(let __tmp1393 (Concat __tmp1180 __tmp1392))
(let __tmp1394 (Concat __tmp1178 __tmp1393))
(let __tmp1395 (Concat __tmp1387 __tmp1394))
(let __tmp1396 (Concat __tmp1176 __tmp1395))
(let __tmp1397 (Concat __tmp1385 __tmp1396))
(let __tmp1398 (Concat __tmp1174 __tmp1397))
(let __tmp1399 (Concat __tmp1383 __tmp1398))
(let __tmp1400 (Concat __tmp1381 __tmp1399))
(let __tmp1401 (Concat __tmp1379 __tmp1400))
(let __tmp1402 (Concat __tmp1377 __tmp1401))
(let __tmp1403 (Concat __tmp1375 __tmp1402))
(let __tmp1404 (Concat __tmp1373 __tmp1403))
(let __tmp1405 (Concat __tmp1172 __tmp1404))
(let __tmp1406 (Concat __tmp1188 __tmp1405))
(let __tmp1407 (Get __tmp1406 11))
(let __tmp1408 (Get __tmp1406 15))
(let __tmp1409 (Bop __tmp171 __tmp1407 __tmp1408))
(let __tmp1410 (InIf true __tmp1409 __tmp1406))
(let __tmp1411 (Arg __tmp1217 __tmp1410))
(let __tmp1412 (Get __tmp1219 2))
(let __tmp1413 (Single __tmp1412))
(let __tmp1414 (Get __tmp1219 3))
(let __tmp1415 (Single __tmp1414))
(let __tmp1416 (Get __tmp1219 6))
(let __tmp1417 (Single __tmp1416))
(let __tmp1418 (Get __tmp1219 7))
(let __tmp1419 (Single __tmp1418))
(let __tmp1420 (Get __tmp1219 9))
(let __tmp1421 (Single __tmp1420))
(let __tmp1422 (Bop __tmp326 __tmp1224 __tmp1420))
(let __tmp1423 (Single __tmp1422))
(let __tmp1424 (Get __tmp1219 13))
(let __tmp1425 (Single __tmp1424))
(let __tmp1426 (Get __tmp1219 14))
(let __tmp1427 (Single __tmp1426))
(let __tmp1428 (Concat __tmp1425 __tmp1427))
(let __tmp1429 (Concat __tmp1428 __tmp1227))
(let __tmp1430 (Concat __tmp1245 __tmp1429))
(let __tmp1431 (Concat __tmp1423 __tmp1430))
(let __tmp1432 (Concat __tmp1243 __tmp1431))
(let __tmp1433 (Concat __tmp1421 __tmp1432))
(let __tmp1434 (Concat __tmp1223 __tmp1433))
(let __tmp1435 (Concat __tmp1419 __tmp1434))
(let __tmp1436 (Concat __tmp1417 __tmp1435))
(let __tmp1437 (Concat __tmp1221 __tmp1436))
(let __tmp1438 (Concat __tmp1241 __tmp1437))
(let __tmp1439 (Concat __tmp1415 __tmp1438))
(let __tmp1440 (Concat __tmp1413 __tmp1439))
(let __tmp1441 (Concat __tmp1258 __tmp1440))
(let __tmp1442 (Concat __tmp1270 __tmp1441))
(let __tmp1443 (Get __tmp1442 11))
(let __tmp1444 (Get __tmp1442 15))
(let __tmp1445 (Bop __tmp171 __tmp1443 __tmp1444))
(let __tmp1446 (Single __tmp1445))
(let __tmp1447 (Concat __tmp1446 __tmp1442))
(let __tmp1448 (DoWhile __tmp1411 __tmp1447))
(let __tmp1449 (InIf false __tmp1409 __tmp1406))
(let __tmp1450 (Arg __tmp1217 __tmp1449))
(let __tmp1451 (If __tmp1409 __tmp1406 __tmp1448 __tmp1450))
(let __tmp1452 (Get __tmp1451 0))
(let __tmp1453 (Single __tmp1452))
(let __tmp1454 (Get __tmp1451 1))
(let __tmp1455 (Single __tmp1454))
(let __tmp1456 (Get __tmp1451 2))
(let __tmp1457 (Single __tmp1456))
(let __tmp1458 (Get __tmp1451 3))
(let __tmp1459 (Single __tmp1458))
(let __tmp1460 (Get __tmp1451 4))
(let __tmp1461 (Single __tmp1460))
(let __tmp1462 (Get __tmp1451 5))
(let __tmp1463 (Single __tmp1462))
(let __tmp1464 (Bop __tmp326 __tmp1175 __tmp1384))
(let __tmp1465 (Single __tmp1464))
(let __tmp1466 (Get __tmp1451 13))
(let __tmp1467 (Single __tmp1466))
(let __tmp1468 (Concat __tmp1467 __tmp1392))
(let __tmp1469 (Concat __tmp1178 __tmp1468))
(let __tmp1470 (Concat __tmp1465 __tmp1469))
(let __tmp1471 (Concat __tmp1385 __tmp1470))
(let __tmp1472 (Concat __tmp1174 __tmp1471))
(let __tmp1473 (Concat __tmp1383 __tmp1472))
(let __tmp1474 (Concat __tmp1381 __tmp1473))
(let __tmp1475 (Concat __tmp1463 __tmp1474))
(let __tmp1476 (Concat __tmp1461 __tmp1475))
(let __tmp1477 (Concat __tmp1459 __tmp1476))
(let __tmp1478 (Concat __tmp1457 __tmp1477))
(let __tmp1479 (Concat __tmp1455 __tmp1478))
(let __tmp1480 (Concat __tmp1453 __tmp1479))
(let __tmp1481 (InIf false __tmp1168 __tmp1165))
(let __tmp1482 (Arg __tmp1163 __tmp1481))
(let __tmp1483 (If __tmp1168 __tmp1165 __tmp1480 __tmp1482))
(let __tmp1484 (Concat __tmp1371 __tmp1483))
(let __tmp1485 (DoWhile __tmp1370 __tmp1484))
(let __tmp1486 (Get __tmp1485 0))
(let __tmp1487 (Single __tmp1486))
(let __tmp1488 (Get __tmp1485 1))
(let __tmp1489 (Single __tmp1488))
(let __tmp1490 (Get __tmp1485 2))
(let __tmp1491 (Single __tmp1490))
(let __tmp1492 (Get __tmp1485 3))
(let __tmp1493 (Single __tmp1492))
(let __tmp1494 (Get __tmp1485 4))
(let __tmp1495 (Single __tmp1494))
(let __tmp1496 (Get __tmp1485 5))
(let __tmp1497 (Single __tmp1496))
(let __tmp1498 (Bop __tmp326 __tmp1343 __tmp1345))
(let __tmp1499 (Single __tmp1498))
(let __tmp1500 (Get __tmp1485 12))
(let __tmp1501 (Single __tmp1500))
(let __tmp1502 (Concat __tmp1501 __tmp1357))
(let __tmp1503 (Concat __tmp1350 __tmp1502))
(let __tmp1504 (Concat __tmp1346 __tmp1503))
(let __tmp1505 (Concat __tmp1499 __tmp1504))
(let __tmp1506 (Concat __tmp1342 __tmp1505))
(let __tmp1507 (Concat __tmp1340 __tmp1506))
(let __tmp1508 (Concat __tmp1497 __tmp1507))
(let __tmp1509 (Concat __tmp1495 __tmp1508))
(let __tmp1510 (Concat __tmp1493 __tmp1509))
(let __tmp1511 (Concat __tmp1491 __tmp1510))
(let __tmp1512 (Concat __tmp1489 __tmp1511))
(let __tmp1513 (Concat __tmp1487 __tmp1512))
(let __tmp1514 (InIf false __tmp1323 __tmp1320))
(let __tmp1515 (Arg __tmp1318 __tmp1514))
(let __tmp1516 (If __tmp1323 __tmp1320 __tmp1513 __tmp1515))
(let __tmp1517 (Concat __tmp1324 __tmp1516))
(let __tmp1518 (DoWhile __tmp1311 __tmp1517))
(let __tmp1519 (Get __tmp1518 0))
(let __tmp1520 (Single __tmp1519))
(let __tmp1521 (Concat __tmp51 __tmp1520))
(let __tmp1522 (Concat __tmp25 __tmp1521))
(let __tmp1523 (Call "matrix_new" __tmp1522))
(let __tmp1524 (Get __tmp1522 1))
(let __tmp1525 (Get __tmp1522 0))
(let __tmp1526 (Bop __tmp15 __tmp1524 __tmp1525))
(let __tmp1527 (Get __tmp1522 2))
(let __tmp1528 (Alloc 0 __tmp1526 __tmp1527 __tmp21))
(let __tmp1529 (TCons __tmp172 __tmp174))
(let __tmp1530 (TCons __tmp172 __tmp1529))
(let __tmp1531 (TCons __tmp172 __tmp1530))
(let __tmp1532 (TCons __tmp172 __tmp1531))
(let __tmp1533 (TCons __tmp172 __tmp1532))
(let __tmp1534 (TCons __tmp172 __tmp1533))
(let __tmp1535 (TCons __tmp21 __tmp1534))
(let __tmp1536 (TCons __tmp21 __tmp1535))
(let __tmp1537 (TCons __tmp21 __tmp1536))
(let __tmp1538 (TCons __tmp21 __tmp1537))
(let __tmp1539 (TCons __tmp21 __tmp1538))
(let __tmp1540 (TCons __tmp21 __tmp1539))
(let __tmp1541 (TCons __tmp1 __tmp1540))
(let __tmp1542 (TupleT __tmp1541))
(let __tmp1543 (InFunc " loop_ctx_5"))
(let __tmp1544 (Arg __tmp1542 __tmp1543))
(let __tmp1545 (Get __tmp1544 11))
(let __tmp1546 (Get __tmp1544 8))
(let __tmp1547 (Bop __tmp171 __tmp1545 __tmp1546))
(let __tmp1548 (InIf true __tmp1547 __tmp1544))
(let __tmp1549 (Arg __tmp1542 __tmp1548))
(let __tmp1550 (Get __tmp1549 1))
(let __tmp1551 (Single __tmp1550))
(let __tmp1552 (Get __tmp1549 9))
(let __tmp1553 (Single __tmp1552))
(let __tmp1554 (Get __tmp1549 11))
(let __tmp1555 (Single __tmp1554))
(let __tmp1556 (Get __tmp1549 8))
(let __tmp1557 (Single __tmp1556))
(let __tmp1558 (Get __tmp1549 13))
(let __tmp1559 (Single __tmp1558))
(let __tmp1560 (Get __tmp1549 0))
(let __tmp1561 (Single __tmp1560))
(let __tmp1562 (Concat __tmp1559 __tmp1561))
(let __tmp1563 (Concat __tmp1557 __tmp1562))
(let __tmp1564 (Concat __tmp1555 __tmp1563))
(let __tmp1565 (Concat __tmp1553 __tmp1564))
(let __tmp1566 (Concat __tmp1551 __tmp1565))
(let __tmp1567 (Call "matrix_set" __tmp1566))
(let __tmp1568 (Get __tmp1566 0))
(let __tmp1569 (Single __tmp1568))
(let __tmp1570 (Get __tmp1566 1))
(let __tmp1571 (Single __tmp1570))
(let __tmp1572 (Get __tmp1566 2))
(let __tmp1573 (Single __tmp1572))
(let __tmp1574 (Get __tmp1566 3))
(let __tmp1575 (Single __tmp1574))
(let __tmp1576 (Get __tmp1566 5))
(let __tmp1577 (Single __tmp1576))
(let __tmp1578 (Concat __tmp1575 __tmp1577))
(let __tmp1579 (Concat __tmp1573 __tmp1578))
(let __tmp1580 (Concat __tmp1571 __tmp1579))
(let __tmp1581 (Concat __tmp1569 __tmp1580))
(let __tmp1582 (Call "matrix_loc" __tmp1581))
(let __tmp1583 (Get __tmp1582 0))
(let __tmp1584 (Get __tmp1566 4))
(let __tmp1585 (Get __tmp1582 1))
(let __tmp1586 (Top __tmp1189 __tmp1583 __tmp1584 __tmp1585))
(let __tmp1587 (Single __tmp1586))
(let __tmp1588 (TCons __tmp172 __tmp1534))
(let __tmp1589 (TCons __tmp21 __tmp1588))
(let __tmp1590 (TCons __tmp21 __tmp1589))
(let __tmp1591 (TCons __tmp21 __tmp1590))
(let __tmp1592 (TCons __tmp21 __tmp1591))
(let __tmp1593 (TCons __tmp21 __tmp1592))
(let __tmp1594 (TCons __tmp21 __tmp1593))
(let __tmp1595 (TCons __tmp1 __tmp1594))
(let __tmp1596 (TupleT __tmp1595))
(let __tmp1597 (InFunc " loop_ctx_6"))
(let __tmp1598 (Arg __tmp1596 __tmp1597))
(let __tmp1599 (Get __tmp1598 4))
(let __tmp1600 (Single __tmp1599))
(let __tmp1601 (Get __tmp1598 9))
(let __tmp1602 (Single __tmp1601))
(let __tmp1603 (Get __tmp1598 12))
(let __tmp1604 (Single __tmp1603))
(let __tmp1605 (Get __tmp1598 15))
(let __tmp1606 (Single __tmp1605))
(let __tmp1607 (Get __tmp1598 0))
(let __tmp1608 (Single __tmp1607))
(let __tmp1609 (Concat __tmp1606 __tmp1608))
(let __tmp1610 (Concat __tmp1604 __tmp1609))
(let __tmp1611 (Concat __tmp1602 __tmp1610))
(let __tmp1612 (Concat __tmp1600 __tmp1611))
(let __tmp1613 (Call "matrix_get" __tmp1612))
(let __tmp1614 (Call "matrix_loc" __tmp1612))
(let __tmp1615 (Get __tmp1614 0))
(let __tmp1616 (Get __tmp1614 1))
(let __tmp1617 (Bop __tmp1235 __tmp1615 __tmp1616))
(let __tmp1618 (Get __tmp1598 3))
(let __tmp1619 (Single __tmp1618))
(let __tmp1620 (Get __tmp1598 11))
(let __tmp1621 (Single __tmp1620))
(let __tmp1622 (Get __tmp1598 8))
(let __tmp1623 (Single __tmp1622))
(let __tmp1624 (Get __tmp1613 1))
(let __tmp1625 (Single __tmp1624))
(let __tmp1626 (Concat __tmp1623 __tmp1625))
(let __tmp1627 (Concat __tmp1621 __tmp1626))
(let __tmp1628 (Concat __tmp1604 __tmp1627))
(let __tmp1629 (Concat __tmp1619 __tmp1628))
(let __tmp1630 (Call "matrix_get" __tmp1629))
(let __tmp1631 (Call "matrix_loc" __tmp1629))
(let __tmp1632 (Get __tmp1631 0))
(let __tmp1633 (Get __tmp1631 1))
(let __tmp1634 (Bop __tmp1235 __tmp1632 __tmp1633))
(let __tmp1635 (Get __tmp1598 1))
(let __tmp1636 (Single __tmp1635))
(let __tmp1637 (Get __tmp1613 0))
(let __tmp1638 (Get __tmp1630 0))
(let __tmp1639 (Bop __tmp293 __tmp1637 __tmp1638))
(let __tmp1640 (Single __tmp1639))
(let __tmp1641 (Get __tmp1630 1))
(let __tmp1642 (Single __tmp1641))
(let __tmp1643 (Concat __tmp1640 __tmp1642))
(let __tmp1644 (Concat __tmp1623 __tmp1643))
(let __tmp1645 (Concat __tmp1621 __tmp1644))
(let __tmp1646 (Concat __tmp1602 __tmp1645))
(let __tmp1647 (Concat __tmp1636 __tmp1646))
(let __tmp1648 (Call "matrix_incr" __tmp1647))
(let __tmp1649 (Get __tmp1647 0))
(let __tmp1650 (Single __tmp1649))
(let __tmp1651 (Get __tmp1647 1))
(let __tmp1652 (Single __tmp1651))
(let __tmp1653 (Get __tmp1647 2))
(let __tmp1654 (Single __tmp1653))
(let __tmp1655 (Get __tmp1647 3))
(let __tmp1656 (Single __tmp1655))
(let __tmp1657 (Get __tmp1647 5))
(let __tmp1658 (Single __tmp1657))
(let __tmp1659 (Concat __tmp1656 __tmp1658))
(let __tmp1660 (Concat __tmp1654 __tmp1659))
(let __tmp1661 (Concat __tmp1652 __tmp1660))
(let __tmp1662 (Concat __tmp1650 __tmp1661))
(let __tmp1663 (Call "matrix_loc" __tmp1662))
(let __tmp1664 (Get __tmp1663 0))
(let __tmp1665 (Get __tmp1663 1))
(let __tmp1666 (Bop __tmp1235 __tmp1664 __tmp1665))
(let __tmp1667 (Get __tmp1666 0))
(let __tmp1668 (Get __tmp1647 4))
(let __tmp1669 (Bop __tmp292 __tmp1667 __tmp1668))
(let __tmp1670 (Get __tmp1666 1))
(let __tmp1671 (Top __tmp1189 __tmp1664 __tmp1669 __tmp1670))
(let __tmp1672 (Single __tmp1671))
(let __tmp1673 (Get __tmp1523 1))
(let __tmp1674 (Single __tmp1673))
(let __tmp1675 (Get __tmp1523 0))
(let __tmp1676 (Single __tmp1675))
(let __tmp1677 (Get __tmp1518 1))
(let __tmp1678 (Single __tmp1677))
(let __tmp1679 (Get __tmp1518 2))
(let __tmp1680 (Single __tmp1679))
(let __tmp1681 (Get __tmp1518 3))
(let __tmp1682 (Single __tmp1681))
(let __tmp1683 (Get __tmp1518 4))
(let __tmp1684 (Single __tmp1683))
(let __tmp1685 (Get __tmp1518 5))
(let __tmp1686 (Single __tmp1685))
(let __tmp1687 (Get __tmp1518 11))
(let __tmp1688 (Single __tmp1687))
(let __tmp1689 (Concat __tmp1688 __tmp38))
(let __tmp1690 (Concat __tmp25 __tmp1689))
(let __tmp1691 (Concat __tmp115 __tmp1690))
(let __tmp1692 (Concat __tmp112 __tmp1691))
(let __tmp1693 (Concat __tmp51 __tmp1692))
(let __tmp1694 (Concat __tmp7 __tmp1693))
(let __tmp1695 (Concat __tmp1686 __tmp1694))
(let __tmp1696 (Concat __tmp1684 __tmp1695))
(let __tmp1697 (Concat __tmp1682 __tmp1696))
(let __tmp1698 (Concat __tmp1680 __tmp1697))
(let __tmp1699 (Concat __tmp1678 __tmp1698))
(let __tmp1700 (Concat __tmp1676 __tmp1699))
(let __tmp1701 (Concat __tmp1674 __tmp1700))
(let __tmp1702 (TCons __tmp21 __tmp1533))
(let __tmp1703 (TCons __tmp21 __tmp1702))
(let __tmp1704 (TCons __tmp21 __tmp1703))
(let __tmp1705 (TCons __tmp21 __tmp1704))
(let __tmp1706 (TCons __tmp21 __tmp1705))
(let __tmp1707 (TCons __tmp21 __tmp1706))
(let __tmp1708 (TCons __tmp1 __tmp1707))
(let __tmp1709 (TupleT __tmp1708))
(let __tmp1710 (InFunc " loop_ctx_1"))
(let __tmp1711 (Arg __tmp1709 __tmp1710))
(let __tmp1712 (Get __tmp1711 9))
(let __tmp1713 (Get __tmp1711 11))
(let __tmp1714 (Bop __tmp171 __tmp1712 __tmp1713))
(let __tmp1715 (Single __tmp1714))
(let __tmp1716 (InIf true __tmp1714 __tmp1711))
(let __tmp1717 (Arg __tmp1709 __tmp1716))
(let __tmp1718 (Get __tmp1717 0))
(let __tmp1719 (Single __tmp1718))
(let __tmp1720 (Get __tmp1717 1))
(let __tmp1721 (Single __tmp1720))
(let __tmp1722 (Get __tmp1717 2))
(let __tmp1723 (Single __tmp1722))
(let __tmp1724 (Get __tmp1717 3))
(let __tmp1725 (Single __tmp1724))
(let __tmp1726 (Get __tmp1717 4))
(let __tmp1727 (Single __tmp1726))
(let __tmp1728 (Get __tmp1717 5))
(let __tmp1729 (Single __tmp1728))
(let __tmp1730 (Get __tmp1717 6))
(let __tmp1731 (Single __tmp1730))
(let __tmp1732 (Get __tmp1717 7))
(let __tmp1733 (Single __tmp1732))
(let __tmp1734 (Get __tmp1717 8))
(let __tmp1735 (Single __tmp1734))
(let __tmp1736 (Get __tmp1717 9))
(let __tmp1737 (Single __tmp1736))
(let __tmp1738 (Get __tmp1717 10))
(let __tmp1739 (Single __tmp1738))
(let __tmp1740 (Const __tmp110 __tmp1709 __tmp1716))
(let __tmp1741 (Single __tmp1740))
(let __tmp1742 (Get __tmp1717 11))
(let __tmp1743 (Single __tmp1742))
(let __tmp1744 (Get __tmp1717 12))
(let __tmp1745 (Single __tmp1744))
(let __tmp1746 (Get __tmp1717 13))
(let __tmp1747 (Single __tmp1746))
(let __tmp1748 (Concat __tmp1745 __tmp1747))
(let __tmp1749 (Concat __tmp1743 __tmp1748))
(let __tmp1750 (Concat __tmp1741 __tmp1749))
(let __tmp1751 (Concat __tmp1739 __tmp1750))
(let __tmp1752 (Concat __tmp1737 __tmp1751))
(let __tmp1753 (Concat __tmp1735 __tmp1752))
(let __tmp1754 (Concat __tmp1733 __tmp1753))
(let __tmp1755 (Concat __tmp1731 __tmp1754))
(let __tmp1756 (Concat __tmp1729 __tmp1755))
(let __tmp1757 (Concat __tmp1727 __tmp1756))
(let __tmp1758 (Concat __tmp1725 __tmp1757))
(let __tmp1759 (Concat __tmp1723 __tmp1758))
(let __tmp1760 (Concat __tmp1721 __tmp1759))
(let __tmp1761 (Concat __tmp1719 __tmp1760))
(let __tmp1762 (Single __tmp1547))
(let __tmp1763 (Get __tmp1549 2))
(let __tmp1764 (Single __tmp1763))
(let __tmp1765 (Get __tmp1549 3))
(let __tmp1766 (Single __tmp1765))
(let __tmp1767 (Get __tmp1549 4))
(let __tmp1768 (Single __tmp1767))
(let __tmp1769 (Get __tmp1549 5))
(let __tmp1770 (Single __tmp1769))
(let __tmp1771 (Get __tmp1549 6))
(let __tmp1772 (Single __tmp1771))
(let __tmp1773 (Get __tmp1549 7))
(let __tmp1774 (Single __tmp1773))
(let __tmp1775 (Get __tmp1549 10))
(let __tmp1776 (Single __tmp1775))
(let __tmp1777 (Const __tmp110 __tmp1542 __tmp1548))
(let __tmp1778 (Single __tmp1777))
(let __tmp1779 (Get __tmp1549 12))
(let __tmp1780 (Single __tmp1779))
(let __tmp1781 (Get __tmp1549 14))
(let __tmp1782 (Single __tmp1781))
(let __tmp1783 (Concat __tmp1559 __tmp1782))
(let __tmp1784 (Concat __tmp1780 __tmp1783))
(let __tmp1785 (Concat __tmp1778 __tmp1784))
(let __tmp1786 (Concat __tmp1555 __tmp1785))
(let __tmp1787 (Concat __tmp1776 __tmp1786))
(let __tmp1788 (Concat __tmp1553 __tmp1787))
(let __tmp1789 (Concat __tmp1557 __tmp1788))
(let __tmp1790 (Concat __tmp1774 __tmp1789))
(let __tmp1791 (Concat __tmp1772 __tmp1790))
(let __tmp1792 (Concat __tmp1770 __tmp1791))
(let __tmp1793 (Concat __tmp1768 __tmp1792))
(let __tmp1794 (Concat __tmp1766 __tmp1793))
(let __tmp1795 (Concat __tmp1764 __tmp1794))
(let __tmp1796 (Concat __tmp1551 __tmp1795))
(let __tmp1797 (Concat __tmp1567 __tmp1796))
(let __tmp1798 (Get __tmp1797 12))
(let __tmp1799 (Get __tmp1797 15))
(let __tmp1800 (Bop __tmp171 __tmp1798 __tmp1799))
(let __tmp1801 (InIf true __tmp1800 __tmp1797))
(let __tmp1802 (Arg __tmp1596 __tmp1801))
(let __tmp1803 (Get __tmp1598 2))
(let __tmp1804 (Single __tmp1803))
(let __tmp1805 (Get __tmp1598 5))
(let __tmp1806 (Single __tmp1805))
(let __tmp1807 (Get __tmp1598 6))
(let __tmp1808 (Single __tmp1807))
(let __tmp1809 (Get __tmp1598 7))
(let __tmp1810 (Single __tmp1809))
(let __tmp1811 (Get __tmp1598 10))
(let __tmp1812 (Single __tmp1811))
(let __tmp1813 (Bop __tmp326 __tmp1603 __tmp1811))
(let __tmp1814 (Single __tmp1813))
(let __tmp1815 (Get __tmp1598 13))
(let __tmp1816 (Single __tmp1815))
(let __tmp1817 (Get __tmp1598 14))
(let __tmp1818 (Single __tmp1817))
(let __tmp1819 (Concat __tmp1816 __tmp1818))
(let __tmp1820 (Concat __tmp1819 __tmp1606))
(let __tmp1821 (Concat __tmp1814 __tmp1820))
(let __tmp1822 (Concat __tmp1621 __tmp1821))
(let __tmp1823 (Concat __tmp1812 __tmp1822))
(let __tmp1824 (Concat __tmp1602 __tmp1823))
(let __tmp1825 (Concat __tmp1623 __tmp1824))
(let __tmp1826 (Concat __tmp1810 __tmp1825))
(let __tmp1827 (Concat __tmp1808 __tmp1826))
(let __tmp1828 (Concat __tmp1806 __tmp1827))
(let __tmp1829 (Concat __tmp1600 __tmp1828))
(let __tmp1830 (Concat __tmp1619 __tmp1829))
(let __tmp1831 (Concat __tmp1804 __tmp1830))
(let __tmp1832 (Concat __tmp1636 __tmp1831))
(let __tmp1833 (Concat __tmp1648 __tmp1832))
(let __tmp1834 (Get __tmp1833 12))
(let __tmp1835 (Get __tmp1833 15))
(let __tmp1836 (Bop __tmp171 __tmp1834 __tmp1835))
(let __tmp1837 (Single __tmp1836))
(let __tmp1838 (Concat __tmp1837 __tmp1833))
(let __tmp1839 (DoWhile __tmp1802 __tmp1838))
(let __tmp1840 (InIf false __tmp1800 __tmp1797))
(let __tmp1841 (Arg __tmp1596 __tmp1840))
(let __tmp1842 (If __tmp1800 __tmp1797 __tmp1839 __tmp1841))
(let __tmp1843 (Get __tmp1842 0))
(let __tmp1844 (Single __tmp1843))
(let __tmp1845 (Get __tmp1842 1))
(let __tmp1846 (Single __tmp1845))
(let __tmp1847 (Get __tmp1842 2))
(let __tmp1848 (Single __tmp1847))
(let __tmp1849 (Get __tmp1842 3))
(let __tmp1850 (Single __tmp1849))
(let __tmp1851 (Get __tmp1842 4))
(let __tmp1852 (Single __tmp1851))
(let __tmp1853 (Get __tmp1842 5))
(let __tmp1854 (Single __tmp1853))
(let __tmp1855 (Get __tmp1842 6))
(let __tmp1856 (Single __tmp1855))
(let __tmp1857 (Bop __tmp326 __tmp1554 __tmp1775))
(let __tmp1858 (Single __tmp1857))
(let __tmp1859 (Get __tmp1842 14))
(let __tmp1860 (Single __tmp1859))
(let __tmp1861 (Concat __tmp1860 __tmp1782))
(let __tmp1862 (Concat __tmp1780 __tmp1861))
(let __tmp1863 (Concat __tmp1858 __tmp1862))
(let __tmp1864 (Concat __tmp1776 __tmp1863))
(let __tmp1865 (Concat __tmp1553 __tmp1864))
(let __tmp1866 (Concat __tmp1557 __tmp1865))
(let __tmp1867 (Concat __tmp1774 __tmp1866))
(let __tmp1868 (Concat __tmp1856 __tmp1867))
(let __tmp1869 (Concat __tmp1854 __tmp1868))
(let __tmp1870 (Concat __tmp1852 __tmp1869))
(let __tmp1871 (Concat __tmp1850 __tmp1870))
(let __tmp1872 (Concat __tmp1848 __tmp1871))
(let __tmp1873 (Concat __tmp1846 __tmp1872))
(let __tmp1874 (Concat __tmp1844 __tmp1873))
(let __tmp1875 (InIf false __tmp1547 __tmp1544))
(let __tmp1876 (Arg __tmp1542 __tmp1875))
(let __tmp1877 (If __tmp1547 __tmp1544 __tmp1874 __tmp1876))
(let __tmp1878 (Concat __tmp1762 __tmp1877))
(let __tmp1879 (DoWhile __tmp1761 __tmp1878))
(let __tmp1880 (Get __tmp1879 0))
(let __tmp1881 (Single __tmp1880))
(let __tmp1882 (Get __tmp1879 1))
(let __tmp1883 (Single __tmp1882))
(let __tmp1884 (Get __tmp1879 2))
(let __tmp1885 (Single __tmp1884))
(let __tmp1886 (Get __tmp1879 3))
(let __tmp1887 (Single __tmp1886))
(let __tmp1888 (Get __tmp1879 4))
(let __tmp1889 (Single __tmp1888))
(let __tmp1890 (Get __tmp1879 5))
(let __tmp1891 (Single __tmp1890))
(let __tmp1892 (Get __tmp1879 6))
(let __tmp1893 (Single __tmp1892))
(let __tmp1894 (Bop __tmp326 __tmp1736 __tmp1738))
(let __tmp1895 (Single __tmp1894))
(let __tmp1896 (Get __tmp1879 13))
(let __tmp1897 (Single __tmp1896))
(let __tmp1898 (Concat __tmp1897 __tmp1747))
(let __tmp1899 (Concat __tmp1743 __tmp1898))
(let __tmp1900 (Concat __tmp1739 __tmp1899))
(let __tmp1901 (Concat __tmp1895 __tmp1900))
(let __tmp1902 (Concat __tmp1735 __tmp1901))
(let __tmp1903 (Concat __tmp1733 __tmp1902))
(let __tmp1904 (Concat __tmp1893 __tmp1903))
(let __tmp1905 (Concat __tmp1891 __tmp1904))
(let __tmp1906 (Concat __tmp1889 __tmp1905))
(let __tmp1907 (Concat __tmp1887 __tmp1906))
(let __tmp1908 (Concat __tmp1885 __tmp1907))
(let __tmp1909 (Concat __tmp1883 __tmp1908))
(let __tmp1910 (Concat __tmp1881 __tmp1909))
(let __tmp1911 (InIf false __tmp1714 __tmp1711))
(let __tmp1912 (Arg __tmp1709 __tmp1911))
(let __tmp1913 (If __tmp1714 __tmp1711 __tmp1910 __tmp1912))
(let __tmp1914 (Concat __tmp1715 __tmp1913))
(let __tmp1915 (DoWhile __tmp1701 __tmp1914))
(let __tmp1916 (Get __tmp1915 0))
(let __tmp1917 (Single __tmp1916))
(let __tmp1918 (Concat __tmp51 __tmp1917))
(let __tmp1919 (Concat __tmp7 __tmp1918))
(let __tmp1920 (Call "matrix_new" __tmp1919))
(let __tmp1921 (Get __tmp1919 1))
(let __tmp1922 (Get __tmp1919 0))
(let __tmp1923 (Bop __tmp15 __tmp1921 __tmp1922))
(let __tmp1924 (Get __tmp1919 2))
(let __tmp1925 (Alloc 0 __tmp1923 __tmp1924 __tmp21))
(let __tmp1926 (TCons __tmp20 __tmp2))
(let __tmp1927 (TCons __tmp172 __tmp1926))
(let __tmp1928 (TCons __tmp172 __tmp1927))
(let __tmp1929 (TCons __tmp172 __tmp1928))
(let __tmp1930 (TCons __tmp172 __tmp1929))
(let __tmp1931 (TCons __tmp172 __tmp1930))
(let __tmp1932 (TCons __tmp172 __tmp1931))
(let __tmp1933 (TCons __tmp21 __tmp1932))
(let __tmp1934 (TCons __tmp21 __tmp1933))
(let __tmp1935 (TCons __tmp21 __tmp1934))
(let __tmp1936 (TCons __tmp21 __tmp1935))
(let __tmp1937 (TCons __tmp21 __tmp1936))
(let __tmp1938 (TCons __tmp21 __tmp1937))
(let __tmp1939 (TCons __tmp21 __tmp1938))
(let __tmp1940 (TCons __tmp1 __tmp1939))
(let __tmp1941 (TupleT __tmp1940))
(let __tmp1942 (InFunc " loop_ctx_7"))
(let __tmp1943 (Arg __tmp1941 __tmp1942))
(let __tmp1944 (Get __tmp1943 12))
(let __tmp1945 (Get __tmp1943 9))
(let __tmp1946 (Bop __tmp171 __tmp1944 __tmp1945))
(let __tmp1947 (InIf true __tmp1946 __tmp1943))
(let __tmp1948 (Arg __tmp1941 __tmp1947))
(let __tmp1949 (Get __tmp1948 1))
(let __tmp1950 (Single __tmp1949))
(let __tmp1951 (Get __tmp1948 10))
(let __tmp1952 (Single __tmp1951))
(let __tmp1953 (Get __tmp1948 12))
(let __tmp1954 (Single __tmp1953))
(let __tmp1955 (Get __tmp1948 9))
(let __tmp1956 (Single __tmp1955))
(let __tmp1957 (Get __tmp1948 14))
(let __tmp1958 (Single __tmp1957))
(let __tmp1959 (Get __tmp1948 0))
(let __tmp1960 (Single __tmp1959))
(let __tmp1961 (Concat __tmp1958 __tmp1960))
(let __tmp1962 (Concat __tmp1956 __tmp1961))
(let __tmp1963 (Concat __tmp1954 __tmp1962))
(let __tmp1964 (Concat __tmp1952 __tmp1963))
(let __tmp1965 (Concat __tmp1950 __tmp1964))
(let __tmp1966 (Call "matrix_set" __tmp1965))
(let __tmp1967 (Get __tmp1965 0))
(let __tmp1968 (Single __tmp1967))
(let __tmp1969 (Get __tmp1965 1))
(let __tmp1970 (Single __tmp1969))
(let __tmp1971 (Get __tmp1965 2))
(let __tmp1972 (Single __tmp1971))
(let __tmp1973 (Get __tmp1965 3))
(let __tmp1974 (Single __tmp1973))
(let __tmp1975 (Get __tmp1965 5))
(let __tmp1976 (Single __tmp1975))
(let __tmp1977 (Concat __tmp1974 __tmp1976))
(let __tmp1978 (Concat __tmp1972 __tmp1977))
(let __tmp1979 (Concat __tmp1970 __tmp1978))
(let __tmp1980 (Concat __tmp1968 __tmp1979))
(let __tmp1981 (Call "matrix_loc" __tmp1980))
(let __tmp1982 (Get __tmp1981 0))
(let __tmp1983 (Get __tmp1965 4))
(let __tmp1984 (Get __tmp1981 1))
(let __tmp1985 (Top __tmp1189 __tmp1982 __tmp1983 __tmp1984))
(let __tmp1986 (Single __tmp1985))
(let __tmp1987 (TCons __tmp172 __tmp1932))
(let __tmp1988 (TCons __tmp21 __tmp1987))
(let __tmp1989 (TCons __tmp21 __tmp1988))
(let __tmp1990 (TCons __tmp21 __tmp1989))
(let __tmp1991 (TCons __tmp21 __tmp1990))
(let __tmp1992 (TCons __tmp21 __tmp1991))
(let __tmp1993 (TCons __tmp21 __tmp1992))
(let __tmp1994 (TCons __tmp21 __tmp1993))
(let __tmp1995 (TCons __tmp1 __tmp1994))
(let __tmp1996 (TupleT __tmp1995))
(let __tmp1997 (InFunc " loop_ctx_8"))
(let __tmp1998 (Arg __tmp1996 __tmp1997))
(let __tmp1999 (Get __tmp1998 3))
(let __tmp2000 (Single __tmp1999))
(let __tmp2001 (Get __tmp1998 10))
(let __tmp2002 (Single __tmp2001))
(let __tmp2003 (Get __tmp1998 13))
(let __tmp2004 (Single __tmp2003))
(let __tmp2005 (Get __tmp1998 14))
(let __tmp2006 (Single __tmp2005))
(let __tmp2007 (Get __tmp1998 0))
(let __tmp2008 (Single __tmp2007))
(let __tmp2009 (Concat __tmp2006 __tmp2008))
(let __tmp2010 (Concat __tmp2004 __tmp2009))
(let __tmp2011 (Concat __tmp2002 __tmp2010))
(let __tmp2012 (Concat __tmp2000 __tmp2011))
(let __tmp2013 (Call "matrix_get" __tmp2012))
(let __tmp2014 (Call "matrix_loc" __tmp2012))
(let __tmp2015 (Get __tmp2014 0))
(let __tmp2016 (Get __tmp2014 1))
(let __tmp2017 (Bop __tmp1235 __tmp2015 __tmp2016))
(let __tmp2018 (Get __tmp1998 2))
(let __tmp2019 (Single __tmp2018))
(let __tmp2020 (Get __tmp1998 12))
(let __tmp2021 (Single __tmp2020))
(let __tmp2022 (Get __tmp1998 9))
(let __tmp2023 (Single __tmp2022))
(let __tmp2024 (Get __tmp2013 1))
(let __tmp2025 (Single __tmp2024))
(let __tmp2026 (Concat __tmp2023 __tmp2025))
(let __tmp2027 (Concat __tmp2021 __tmp2026))
(let __tmp2028 (Concat __tmp2004 __tmp2027))
(let __tmp2029 (Concat __tmp2019 __tmp2028))
(let __tmp2030 (Call "matrix_get" __tmp2029))
(let __tmp2031 (Call "matrix_loc" __tmp2029))
(let __tmp2032 (Get __tmp2031 0))
(let __tmp2033 (Get __tmp2031 1))
(let __tmp2034 (Bop __tmp1235 __tmp2032 __tmp2033))
(let __tmp2035 (Get __tmp1998 1))
(let __tmp2036 (Single __tmp2035))
(let __tmp2037 (Get __tmp2013 0))
(let __tmp2038 (Get __tmp2030 0))
(let __tmp2039 (Bop __tmp293 __tmp2037 __tmp2038))
(let __tmp2040 (Single __tmp2039))
(let __tmp2041 (Get __tmp2030 1))
(let __tmp2042 (Single __tmp2041))
(let __tmp2043 (Concat __tmp2040 __tmp2042))
(let __tmp2044 (Concat __tmp2023 __tmp2043))
(let __tmp2045 (Concat __tmp2021 __tmp2044))
(let __tmp2046 (Concat __tmp2002 __tmp2045))
(let __tmp2047 (Concat __tmp2036 __tmp2046))
(let __tmp2048 (Call "matrix_incr" __tmp2047))
(let __tmp2049 (Get __tmp2047 0))
(let __tmp2050 (Single __tmp2049))
(let __tmp2051 (Get __tmp2047 1))
(let __tmp2052 (Single __tmp2051))
(let __tmp2053 (Get __tmp2047 2))
(let __tmp2054 (Single __tmp2053))
(let __tmp2055 (Get __tmp2047 3))
(let __tmp2056 (Single __tmp2055))
(let __tmp2057 (Get __tmp2047 5))
(let __tmp2058 (Single __tmp2057))
(let __tmp2059 (Concat __tmp2056 __tmp2058))
(let __tmp2060 (Concat __tmp2054 __tmp2059))
(let __tmp2061 (Concat __tmp2052 __tmp2060))
(let __tmp2062 (Concat __tmp2050 __tmp2061))
(let __tmp2063 (Call "matrix_loc" __tmp2062))
(let __tmp2064 (Get __tmp2063 0))
(let __tmp2065 (Get __tmp2063 1))
(let __tmp2066 (Bop __tmp1235 __tmp2064 __tmp2065))
(let __tmp2067 (Get __tmp2066 0))
(let __tmp2068 (Get __tmp2047 4))
(let __tmp2069 (Bop __tmp292 __tmp2067 __tmp2068))
(let __tmp2070 (Get __tmp2066 1))
(let __tmp2071 (Top __tmp1189 __tmp2064 __tmp2069 __tmp2070))
(let __tmp2072 (Single __tmp2071))
(let __tmp2073 (Get __tmp1920 1))
(let __tmp2074 (Single __tmp2073))
(let __tmp2075 (Get __tmp1920 0))
(let __tmp2076 (Single __tmp2075))
(let __tmp2077 (Get __tmp1915 1))
(let __tmp2078 (Single __tmp2077))
(let __tmp2079 (Get __tmp1915 2))
(let __tmp2080 (Single __tmp2079))
(let __tmp2081 (Get __tmp1915 3))
(let __tmp2082 (Single __tmp2081))
(let __tmp2083 (Get __tmp1915 4))
(let __tmp2084 (Single __tmp2083))
(let __tmp2085 (Get __tmp1915 5))
(let __tmp2086 (Single __tmp2085))
(let __tmp2087 (Get __tmp1915 6))
(let __tmp2088 (Single __tmp2087))
(let __tmp2089 (Get __tmp1915 12))
(let __tmp2090 (Single __tmp2089))
(let __tmp2091 (Concat __tmp25 __tmp2090))
(let __tmp2092 (Concat __tmp115 __tmp2091))
(let __tmp2093 (Concat __tmp112 __tmp2092))
(let __tmp2094 (Concat __tmp51 __tmp2093))
(let __tmp2095 (Concat __tmp7 __tmp2094))
(let __tmp2096 (Concat __tmp2088 __tmp2095))
(let __tmp2097 (Concat __tmp2086 __tmp2096))
(let __tmp2098 (Concat __tmp2084 __tmp2097))
(let __tmp2099 (Concat __tmp2082 __tmp2098))
(let __tmp2100 (Concat __tmp2080 __tmp2099))
(let __tmp2101 (Concat __tmp2078 __tmp2100))
(let __tmp2102 (Concat __tmp2076 __tmp2101))
(let __tmp2103 (Concat __tmp2074 __tmp2102))
(let __tmp2104 (TCons __tmp21 __tmp1931))
(let __tmp2105 (TCons __tmp21 __tmp2104))
(let __tmp2106 (TCons __tmp21 __tmp2105))
(let __tmp2107 (TCons __tmp21 __tmp2106))
(let __tmp2108 (TCons __tmp21 __tmp2107))
(let __tmp2109 (TCons __tmp21 __tmp2108))
(let __tmp2110 (TCons __tmp21 __tmp2109))
(let __tmp2111 (TCons __tmp1 __tmp2110))
(let __tmp2112 (TupleT __tmp2111))
(let __tmp2113 (InFunc " loop_ctx_0"))
(let __tmp2114 (Arg __tmp2112 __tmp2113))
(let __tmp2115 (Get __tmp2114 10))
(let __tmp2116 (Get __tmp2114 8))
(let __tmp2117 (Bop __tmp171 __tmp2115 __tmp2116))
(let __tmp2118 (Single __tmp2117))
(let __tmp2119 (InIf true __tmp2117 __tmp2114))
(let __tmp2120 (Arg __tmp2112 __tmp2119))
(let __tmp2121 (Get __tmp2120 0))
(let __tmp2122 (Single __tmp2121))
(let __tmp2123 (Get __tmp2120 1))
(let __tmp2124 (Single __tmp2123))
(let __tmp2125 (Get __tmp2120 2))
(let __tmp2126 (Single __tmp2125))
(let __tmp2127 (Get __tmp2120 3))
(let __tmp2128 (Single __tmp2127))
(let __tmp2129 (Get __tmp2120 4))
(let __tmp2130 (Single __tmp2129))
(let __tmp2131 (Get __tmp2120 5))
(let __tmp2132 (Single __tmp2131))
(let __tmp2133 (Get __tmp2120 6))
(let __tmp2134 (Single __tmp2133))
(let __tmp2135 (Get __tmp2120 7))
(let __tmp2136 (Single __tmp2135))
(let __tmp2137 (Get __tmp2120 8))
(let __tmp2138 (Single __tmp2137))
(let __tmp2139 (Get __tmp2120 9))
(let __tmp2140 (Single __tmp2139))
(let __tmp2141 (Get __tmp2120 10))
(let __tmp2142 (Single __tmp2141))
(let __tmp2143 (Get __tmp2120 11))
(let __tmp2144 (Single __tmp2143))
(let __tmp2145 (Const __tmp110 __tmp2112 __tmp2119))
(let __tmp2146 (Single __tmp2145))
(let __tmp2147 (Get __tmp2120 12))
(let __tmp2148 (Single __tmp2147))
(let __tmp2149 (Get __tmp2120 13))
(let __tmp2150 (Single __tmp2149))
(let __tmp2151 (Concat __tmp2148 __tmp2150))
(let __tmp2152 (Concat __tmp2146 __tmp2151))
(let __tmp2153 (Concat __tmp2144 __tmp2152))
(let __tmp2154 (Concat __tmp2142 __tmp2153))
(let __tmp2155 (Concat __tmp2140 __tmp2154))
(let __tmp2156 (Concat __tmp2138 __tmp2155))
(let __tmp2157 (Concat __tmp2136 __tmp2156))
(let __tmp2158 (Concat __tmp2134 __tmp2157))
(let __tmp2159 (Concat __tmp2132 __tmp2158))
(let __tmp2160 (Concat __tmp2130 __tmp2159))
(let __tmp2161 (Concat __tmp2128 __tmp2160))
(let __tmp2162 (Concat __tmp2126 __tmp2161))
(let __tmp2163 (Concat __tmp2124 __tmp2162))
(let __tmp2164 (Concat __tmp2122 __tmp2163))
(let __tmp2165 (Single __tmp1946))
(let __tmp2166 (Get __tmp1948 2))
(let __tmp2167 (Single __tmp2166))
(let __tmp2168 (Get __tmp1948 3))
(let __tmp2169 (Single __tmp2168))
(let __tmp2170 (Get __tmp1948 4))
(let __tmp2171 (Single __tmp2170))
(let __tmp2172 (Get __tmp1948 5))
(let __tmp2173 (Single __tmp2172))
(let __tmp2174 (Get __tmp1948 6))
(let __tmp2175 (Single __tmp2174))
(let __tmp2176 (Get __tmp1948 7))
(let __tmp2177 (Single __tmp2176))
(let __tmp2178 (Get __tmp1948 8))
(let __tmp2179 (Single __tmp2178))
(let __tmp2180 (Get __tmp1948 11))
(let __tmp2181 (Single __tmp2180))
(let __tmp2182 (Const __tmp110 __tmp1941 __tmp1947))
(let __tmp2183 (Single __tmp2182))
(let __tmp2184 (Get __tmp1948 13))
(let __tmp2185 (Single __tmp2184))
(let __tmp2186 (Concat __tmp2185 __tmp1958))
(let __tmp2187 (Concat __tmp2183 __tmp2186))
(let __tmp2188 (Concat __tmp1954 __tmp2187))
(let __tmp2189 (Concat __tmp2181 __tmp2188))
(let __tmp2190 (Concat __tmp1952 __tmp2189))
(let __tmp2191 (Concat __tmp1956 __tmp2190))
(let __tmp2192 (Concat __tmp2179 __tmp2191))
(let __tmp2193 (Concat __tmp2177 __tmp2192))
(let __tmp2194 (Concat __tmp2175 __tmp2193))
(let __tmp2195 (Concat __tmp2173 __tmp2194))
(let __tmp2196 (Concat __tmp2171 __tmp2195))
(let __tmp2197 (Concat __tmp2169 __tmp2196))
(let __tmp2198 (Concat __tmp2167 __tmp2197))
(let __tmp2199 (Concat __tmp1950 __tmp2198))
(let __tmp2200 (Concat __tmp1966 __tmp2199))
(let __tmp2201 (Get __tmp2200 13))
(let __tmp2202 (Get __tmp2200 14))
(let __tmp2203 (Bop __tmp171 __tmp2201 __tmp2202))
(let __tmp2204 (InIf true __tmp2203 __tmp2200))
(let __tmp2205 (Arg __tmp1996 __tmp2204))
(let __tmp2206 (Get __tmp1998 4))
(let __tmp2207 (Single __tmp2206))
(let __tmp2208 (Get __tmp1998 5))
(let __tmp2209 (Single __tmp2208))
(let __tmp2210 (Get __tmp1998 6))
(let __tmp2211 (Single __tmp2210))
(let __tmp2212 (Get __tmp1998 7))
(let __tmp2213 (Single __tmp2212))
(let __tmp2214 (Get __tmp1998 8))
(let __tmp2215 (Single __tmp2214))
(let __tmp2216 (Get __tmp1998 11))
(let __tmp2217 (Single __tmp2216))
(let __tmp2218 (Concat __tmp2217 __tmp2021))
(let __tmp2219 (Concat __tmp2002 __tmp2218))
(let __tmp2220 (Bop __tmp326 __tmp2216 __tmp2003))
(let __tmp2221 (Single __tmp2220))
(let __tmp2222 (Get __tmp1998 15))
(let __tmp2223 (Single __tmp2222))
(let __tmp2224 (Concat __tmp2006 __tmp2223))
(let __tmp2225 (Concat __tmp2221 __tmp2224))
(let __tmp2226 (Concat __tmp2219 __tmp2225))
(let __tmp2227 (Concat __tmp2023 __tmp2226))
(let __tmp2228 (Concat __tmp2215 __tmp2227))
(let __tmp2229 (Concat __tmp2213 __tmp2228))
(let __tmp2230 (Concat __tmp2211 __tmp2229))
(let __tmp2231 (Concat __tmp2209 __tmp2230))
(let __tmp2232 (Concat __tmp2207 __tmp2231))
(let __tmp2233 (Concat __tmp2000 __tmp2232))
(let __tmp2234 (Concat __tmp2019 __tmp2233))
(let __tmp2235 (Concat __tmp2036 __tmp2234))
(let __tmp2236 (Concat __tmp2048 __tmp2235))
(let __tmp2237 (Get __tmp2236 13))
(let __tmp2238 (Get __tmp2236 14))
(let __tmp2239 (Bop __tmp171 __tmp2237 __tmp2238))
(let __tmp2240 (Single __tmp2239))
(let __tmp2241 (Concat __tmp2240 __tmp2236))
(let __tmp2242 (DoWhile __tmp2205 __tmp2241))
(let __tmp2243 (InIf false __tmp2203 __tmp2200))
(let __tmp2244 (Arg __tmp1996 __tmp2243))
(let __tmp2245 (If __tmp2203 __tmp2200 __tmp2242 __tmp2244))
(let __tmp2246 (Get __tmp2245 0))
(let __tmp2247 (Single __tmp2246))
(let __tmp2248 (Get __tmp2245 1))
(let __tmp2249 (Single __tmp2248))
(let __tmp2250 (Get __tmp2245 2))
(let __tmp2251 (Single __tmp2250))
(let __tmp2252 (Get __tmp2245 3))
(let __tmp2253 (Single __tmp2252))
(let __tmp2254 (Get __tmp2245 4))
(let __tmp2255 (Single __tmp2254))
(let __tmp2256 (Get __tmp2245 5))
(let __tmp2257 (Single __tmp2256))
(let __tmp2258 (Get __tmp2245 6))
(let __tmp2259 (Single __tmp2258))
(let __tmp2260 (Get __tmp2245 7))
(let __tmp2261 (Single __tmp2260))
(let __tmp2262 (Concat __tmp1952 __tmp2181))
(let __tmp2263 (Concat __tmp1956 __tmp2262))
(let __tmp2264 (Concat __tmp2179 __tmp2263))
(let __tmp2265 (Concat __tmp2261 __tmp2264))
(let __tmp2266 (Concat __tmp2259 __tmp2265))
(let __tmp2267 (Concat __tmp2257 __tmp2266))
(let __tmp2268 (Bop __tmp326 __tmp2180 __tmp1953))
(let __tmp2269 (Single __tmp2268))
(let __tmp2270 (Get __tmp2245 15))
(let __tmp2271 (Single __tmp2270))
(let __tmp2272 (Concat __tmp2185 __tmp2271))
(let __tmp2273 (Concat __tmp2269 __tmp2272))
(let __tmp2274 (Concat __tmp2267 __tmp2273))
(let __tmp2275 (Concat __tmp2255 __tmp2274))
(let __tmp2276 (Concat __tmp2253 __tmp2275))
(let __tmp2277 (Concat __tmp2251 __tmp2276))
(let __tmp2278 (Concat __tmp2249 __tmp2277))
(let __tmp2279 (Concat __tmp2247 __tmp2278))
(let __tmp2280 (InIf false __tmp1946 __tmp1943))
(let __tmp2281 (Arg __tmp1941 __tmp2280))
(let __tmp2282 (If __tmp1946 __tmp1943 __tmp2279 __tmp2281))
(let __tmp2283 (Concat __tmp2165 __tmp2282))
(let __tmp2284 (DoWhile __tmp2164 __tmp2283))
(let __tmp2285 (Get __tmp2284 0))
(let __tmp2286 (Single __tmp2285))
(let __tmp2287 (Get __tmp2284 1))
(let __tmp2288 (Single __tmp2287))
(let __tmp2289 (Get __tmp2284 2))
(let __tmp2290 (Single __tmp2289))
(let __tmp2291 (Get __tmp2284 3))
(let __tmp2292 (Single __tmp2291))
(let __tmp2293 (Get __tmp2284 4))
(let __tmp2294 (Single __tmp2293))
(let __tmp2295 (Get __tmp2284 5))
(let __tmp2296 (Single __tmp2295))
(let __tmp2297 (Get __tmp2284 6))
(let __tmp2298 (Single __tmp2297))
(let __tmp2299 (Get __tmp2284 7))
(let __tmp2300 (Single __tmp2299))
(let __tmp2301 (Concat __tmp2138 __tmp2140))
(let __tmp2302 (Concat __tmp2300 __tmp2301))
(let __tmp2303 (Concat __tmp2298 __tmp2302))
(let __tmp2304 (Concat __tmp2296 __tmp2303))
(let __tmp2305 (Concat __tmp2294 __tmp2304))
(let __tmp2306 (Concat __tmp2292 __tmp2305))
(let __tmp2307 (Concat __tmp2290 __tmp2306))
(let __tmp2308 (Concat __tmp2288 __tmp2307))
(let __tmp2309 (Concat __tmp2286 __tmp2308))
(let __tmp2310 (Bop __tmp326 __tmp2143 __tmp2141))
(let __tmp2311 (Single __tmp2310))
(let __tmp2312 (Get __tmp2284 14))
(let __tmp2313 (Single __tmp2312))
(let __tmp2314 (Concat __tmp2148 __tmp2313))
(let __tmp2315 (Concat __tmp2144 __tmp2314))
(let __tmp2316 (Concat __tmp2311 __tmp2315))
(let __tmp2317 (Concat __tmp2309 __tmp2316))
(let __tmp2318 (InIf false __tmp2117 __tmp2114))
(let __tmp2319 (Arg __tmp2112 __tmp2318))
(let __tmp2320 (If __tmp2117 __tmp2114 __tmp2317 __tmp2319))
(let __tmp2321 (Concat __tmp2118 __tmp2320))
(let __tmp2322 (DoWhile __tmp2103 __tmp2321))
(let __tmp2323 (Get __tmp2322 1))
(let __tmp2324 (Single __tmp2323))
(let __tmp2325 (Get __tmp2322 0))
(let __tmp2326 (Single __tmp2325))
(let __tmp2327 (Concat __tmp51 __tmp2326))
(let __tmp2328 (Concat __tmp7 __tmp2327))
(let __tmp2329 (Concat __tmp2324 __tmp2328))
(let __tmp2330 (Call "matrix_sum" __tmp2329))
(let __tmp2331 (Get __tmp2329 1))
(let __tmp2332 (Get __tmp2329 2))
(let __tmp2333 (Bop __tmp15 __tmp2331 __tmp2332))
(let __tmp2334 (Bop __tmp171 __tmp111 __tmp2333))
(let __tmp2335 (Get __tmp2329 3))
(let __tmp2336 (Single __tmp2335))
(let __tmp2337 (Get __tmp2329 0))
(let __tmp2338 (Single __tmp2337))
(let __tmp2339 (Single __tmp2333))
(let __tmp2340 (Concat __tmp2338 __tmp2339))
(let __tmp2341 (Concat __tmp115 __tmp2340))
(let __tmp2342 (Concat __tmp112 __tmp2341))
(let __tmp2343 (Concat __tmp106 __tmp2342))
(let __tmp2344 (Concat __tmp2336 __tmp2343))
(let __tmp2345 (TCons __tmp21 __tmp173))
(let __tmp2346 (TCons __tmp172 __tmp2345))
(let __tmp2347 (TCons __tmp172 __tmp2346))
(let __tmp2348 (TCons __tmp20 __tmp2347))
(let __tmp2349 (TCons __tmp1 __tmp2348))
(let __tmp2350 (TupleT __tmp2349))
(let __tmp2351 (InIf true __tmp2334 __tmp2344))
(let __tmp2352 (Arg __tmp2350 __tmp2351))
(let __tmp2353 (InFunc " loop_ctx_28"))
(let __tmp2354 (Arg __tmp2350 __tmp2353))
(let __tmp2355 (Get __tmp2354 2))
(let __tmp2356 (Get __tmp2354 3))
(let __tmp2357 (Bop __tmp326 __tmp2355 __tmp2356))
(let __tmp2358 (Get __tmp2354 5))
(let __tmp2359 (Bop __tmp171 __tmp2357 __tmp2358))
(let __tmp2360 (Single __tmp2359))
(let __tmp2361 (PtrAdd ))
(let __tmp2362 (Get __tmp2354 4))
(let __tmp2363 (Bop __tmp2361 __tmp2362 __tmp2355))
(let __tmp2364 (Get __tmp2354 0))
(let __tmp2365 (Bop __tmp1235 __tmp2363 __tmp2364))
(let __tmp2366 (Get __tmp2365 1))
(let __tmp2367 (Single __tmp2366))
(let __tmp2368 (Get __tmp2354 1))
(let __tmp2369 (Get __tmp2365 0))
(let __tmp2370 (Bop __tmp292 __tmp2368 __tmp2369))
(let __tmp2371 (Single __tmp2370))
(let __tmp2372 (Single __tmp2357))
(let __tmp2373 (Single __tmp2356))
(let __tmp2374 (Concat __tmp2372 __tmp2373))
(let __tmp2375 (Single __tmp2362))
(let __tmp2376 (Concat __tmp2374 __tmp2375))
(let __tmp2377 (Single __tmp2358))
(let __tmp2378 (Concat __tmp2376 __tmp2377))
(let __tmp2379 (Concat __tmp2371 __tmp2378))
(let __tmp2380 (Concat __tmp2367 __tmp2379))
(let __tmp2381 (Concat __tmp2360 __tmp2380))
(let __tmp2382 (DoWhile __tmp2352 __tmp2381))
(let __tmp2383 (InIf false __tmp2334 __tmp2344))
(let __tmp2384 (Arg __tmp2350 __tmp2383))
(let __tmp2385 (If __tmp2334 __tmp2344 __tmp2382 __tmp2384))
(let __tmp2386 (Get __tmp2385 1))
(let __tmp2387 (Single __tmp2386))
(let __tmp2388 (Get __tmp2385 0))
(let __tmp2389 (Single __tmp2388))
(let __tmp2390 (Concat __tmp2387 __tmp2389))
(let __tmp2391 (Get __tmp305 2))
(let __tmp2392 (Single __tmp2391))
(let __tmp2393 (Get __tmp305 0))
(let __tmp2394 (Single __tmp2393))
(let __tmp2395 (Const __tmp125 __tmp278 __tmp281))
(let __tmp2396 (Single __tmp2395))
(let __tmp2397 (Const __tmp104 __tmp278 __tmp281))
(let __tmp2398 (Single __tmp2397))
(let __tmp2399 (Get __tmp305 1))
(let __tmp2400 (Single __tmp2399))
(let __tmp2401 (Concat __tmp2398 __tmp2400))
(let __tmp2402 (Concat __tmp2396 __tmp2401))
(let __tmp2403 (Concat __tmp2394 __tmp2402))
(let __tmp2404 (Concat __tmp2392 __tmp2403))
(let __tmp2405 (FGreaterEq ))
(let __tmp2406 (TCons __tmp20 __tmp1926))
(let __tmp2407 (TCons __tmp20 __tmp2406))
(let __tmp2408 (TCons __tmp20 __tmp2407))
(let __tmp2409 (TCons __tmp1 __tmp2408))
(let __tmp2410 (TupleT __tmp2409))
(let __tmp2411 (InFunc " loop_ctx_29"))
(let __tmp2412 (Arg __tmp2410 __tmp2411))
(let __tmp2413 (Get __tmp2412 1))
(let __tmp2414 (Get __tmp2412 4))
(let __tmp2415 (Bop __tmp2405 __tmp2413 __tmp2414))
(let __tmp2416 (Single __tmp2415))
(let __tmp2417 (FSub ))
(let __tmp2418 (InIf true __tmp2415 __tmp2412))
(let __tmp2419 (Arg __tmp2410 __tmp2418))
(let __tmp2420 (Get __tmp2419 1))
(let __tmp2421 (Get __tmp2419 4))
(let __tmp2422 (Bop __tmp2417 __tmp2420 __tmp2421))
(let __tmp2423 (Get __tmp2419 3))
(let __tmp2424 (Bop __tmp2405 __tmp2422 __tmp2423))
(let __tmp2425 (Get __tmp2419 0))
(let __tmp2426 (Single __tmp2425))
(let __tmp2427 (Single __tmp2420))
(let __tmp2428 (Single __tmp2421))
(let __tmp2429 (Get __tmp2419 2))
(let __tmp2430 (Single __tmp2429))
(let __tmp2431 (Single __tmp2423))
(let __tmp2432 (Concat __tmp2431 __tmp2428))
(let __tmp2433 (Concat __tmp2430 __tmp2432))
(let __tmp2434 (Concat __tmp2428 __tmp2433))
(let __tmp2435 (Concat __tmp2427 __tmp2434))
(let __tmp2436 (Concat __tmp2426 __tmp2435))
(let __tmp2437 (TCons __tmp20 __tmp2408))
(let __tmp2438 (TCons __tmp1 __tmp2437))
(let __tmp2439 (TupleT __tmp2438))
(let __tmp2440 (InIf true __tmp2424 __tmp2436))
(let __tmp2441 (Arg __tmp2439 __tmp2440))
(let __tmp2442 (InFunc " loop_ctx_30"))
(let __tmp2443 (Arg __tmp2439 __tmp2442))
(let __tmp2444 (Get __tmp2443 1))
(let __tmp2445 (Get __tmp2443 2))
(let __tmp2446 (Get __tmp2443 3))
(let __tmp2447 (Bop __tmp293 __tmp2445 __tmp2446))
(let __tmp2448 (Bop __tmp2417 __tmp2444 __tmp2447))
(let __tmp2449 (Get __tmp2443 4))
(let __tmp2450 (Bop __tmp2405 __tmp2448 __tmp2449))
(let __tmp2451 (Single __tmp2450))
(let __tmp2452 (Get __tmp2443 0))
(let __tmp2453 (Single __tmp2452))
(let __tmp2454 (Single __tmp2444))
(let __tmp2455 (Single __tmp2447))
(let __tmp2456 (Single __tmp2446))
(let __tmp2457 (Concat __tmp2455 __tmp2456))
(let __tmp2458 (Single __tmp2449))
(let __tmp2459 (Concat __tmp2457 __tmp2458))
(let __tmp2460 (Get __tmp2443 5))
(let __tmp2461 (Single __tmp2460))
(let __tmp2462 (Concat __tmp2459 __tmp2461))
(let __tmp2463 (Concat __tmp2454 __tmp2462))
(let __tmp2464 (Concat __tmp2453 __tmp2463))
(let __tmp2465 (Concat __tmp2451 __tmp2464))
(let __tmp2466 (DoWhile __tmp2441 __tmp2465))
(let __tmp2467 (InIf false __tmp2424 __tmp2436))
(let __tmp2468 (Arg __tmp2439 __tmp2467))
(let __tmp2469 (If __tmp2424 __tmp2436 __tmp2466 __tmp2468))
(let __tmp2470 (Get __tmp2469 0))
(let __tmp2471 (Single __tmp2470))
(let __tmp2472 (Get __tmp2469 1))
(let __tmp2473 (Get __tmp2469 2))
(let __tmp2474 (Get __tmp2469 3))
(let __tmp2475 (Bop __tmp291 __tmp2473 __tmp2474))
(let __tmp2476 (Bop __tmp2417 __tmp2472 __tmp2475))
(let __tmp2477 (Single __tmp2476))
(let __tmp2478 (Single __tmp2474))
(let __tmp2479 (Get __tmp2469 4))
(let __tmp2480 (Single __tmp2479))
(let __tmp2481 (Concat __tmp2478 __tmp2480))
(let __tmp2482 (Get __tmp2469 5))
(let __tmp2483 (Single __tmp2482))
(let __tmp2484 (Concat __tmp2481 __tmp2483))
(let __tmp2485 (Concat __tmp2477 __tmp2484))
(let __tmp2486 (Concat __tmp2471 __tmp2485))
(let __tmp2487 (InIf false __tmp2415 __tmp2412))
(let __tmp2488 (Arg __tmp2410 __tmp2487))
(let __tmp2489 (If __tmp2415 __tmp2412 __tmp2486 __tmp2488))
(let __tmp2490 (Concat __tmp2416 __tmp2489))
(let __tmp2491 (DoWhile __tmp2404 __tmp2490))
(let __tmp2492 (Get __tmp2491 1))
(let __tmp2493 (Single __tmp2492))
(let __tmp2494 (Get __tmp2491 0))
(let __tmp2495 (Single __tmp2494))
(let __tmp2496 (Concat __tmp2493 __tmp2495))
(let __tmp2497 (Get __tmp318 0))
(let __tmp2498 (Single __tmp2497))
(let __tmp2499 (Get __tmp318 1))
(let __tmp2500 (Single __tmp2499))
(let __tmp2501 (Get __tmp318 2))
(let __tmp2502 (Single __tmp2501))
(let __tmp2503 (Get __tmp318 3))
(let __tmp2504 (Single __tmp2503))
(let __tmp2505 (Get __tmp318 5))
(let __tmp2506 (Single __tmp2505))
(let __tmp2507 (Concat __tmp2504 __tmp2506))
(let __tmp2508 (Concat __tmp2502 __tmp2507))
(let __tmp2509 (Concat __tmp2500 __tmp2508))
(let __tmp2510 (Concat __tmp2498 __tmp2509))
(let __tmp2511 (Call "matrix_loc" __tmp2510))
(let __tmp2512 (Get __tmp2511 0))
(let __tmp2513 (Get __tmp318 4))
(let __tmp2514 (Get __tmp2511 1))
(let __tmp2515 (Top __tmp1189 __tmp2512 __tmp2513 __tmp2514))
(let __tmp2516 (Single __tmp2515))
(let __tmp2517 (Get __tmp594 2))
(let __tmp2518 (Single __tmp2517))
(let __tmp2519 (Get __tmp594 0))
(let __tmp2520 (Single __tmp2519))
(let __tmp2521 (Const __tmp125 __tmp568 __tmp571))
(let __tmp2522 (Single __tmp2521))
(let __tmp2523 (Const __tmp104 __tmp568 __tmp571))
(let __tmp2524 (Single __tmp2523))
(let __tmp2525 (Get __tmp594 1))
(let __tmp2526 (Single __tmp2525))
(let __tmp2527 (Concat __tmp2524 __tmp2526))
(let __tmp2528 (Concat __tmp2522 __tmp2527))
(let __tmp2529 (Concat __tmp2520 __tmp2528))
(let __tmp2530 (Concat __tmp2518 __tmp2529))
(let __tmp2531 (InFunc " loop_ctx_31"))
(let __tmp2532 (Arg __tmp2410 __tmp2531))
(let __tmp2533 (Get __tmp2532 1))
(let __tmp2534 (Get __tmp2532 4))
(let __tmp2535 (Bop __tmp2405 __tmp2533 __tmp2534))
(let __tmp2536 (Single __tmp2535))
(let __tmp2537 (InIf true __tmp2535 __tmp2532))
(let __tmp2538 (Arg __tmp2410 __tmp2537))
(let __tmp2539 (Get __tmp2538 1))
(let __tmp2540 (Get __tmp2538 4))
(let __tmp2541 (Bop __tmp2417 __tmp2539 __tmp2540))
(let __tmp2542 (Get __tmp2538 3))
(let __tmp2543 (Bop __tmp2405 __tmp2541 __tmp2542))
(let __tmp2544 (Get __tmp2538 0))
(let __tmp2545 (Single __tmp2544))
(let __tmp2546 (Single __tmp2539))
(let __tmp2547 (Single __tmp2540))
(let __tmp2548 (Get __tmp2538 2))
(let __tmp2549 (Single __tmp2548))
(let __tmp2550 (Single __tmp2542))
(let __tmp2551 (Concat __tmp2550 __tmp2547))
(let __tmp2552 (Concat __tmp2549 __tmp2551))
(let __tmp2553 (Concat __tmp2547 __tmp2552))
(let __tmp2554 (Concat __tmp2546 __tmp2553))
(let __tmp2555 (Concat __tmp2545 __tmp2554))
(let __tmp2556 (InIf true __tmp2543 __tmp2555))
(let __tmp2557 (Arg __tmp2439 __tmp2556))
(let __tmp2558 (InFunc " loop_ctx_32"))
(let __tmp2559 (Arg __tmp2439 __tmp2558))
(let __tmp2560 (Get __tmp2559 1))
(let __tmp2561 (Get __tmp2559 2))
(let __tmp2562 (Get __tmp2559 3))
(let __tmp2563 (Bop __tmp293 __tmp2561 __tmp2562))
(let __tmp2564 (Bop __tmp2417 __tmp2560 __tmp2563))
(let __tmp2565 (Get __tmp2559 4))
(let __tmp2566 (Bop __tmp2405 __tmp2564 __tmp2565))
(let __tmp2567 (Single __tmp2566))
(let __tmp2568 (Get __tmp2559 0))
(let __tmp2569 (Single __tmp2568))
(let __tmp2570 (Single __tmp2560))
(let __tmp2571 (Single __tmp2563))
(let __tmp2572 (Single __tmp2562))
(let __tmp2573 (Concat __tmp2571 __tmp2572))
(let __tmp2574 (Single __tmp2565))
(let __tmp2575 (Concat __tmp2573 __tmp2574))
(let __tmp2576 (Get __tmp2559 5))
(let __tmp2577 (Single __tmp2576))
(let __tmp2578 (Concat __tmp2575 __tmp2577))
(let __tmp2579 (Concat __tmp2570 __tmp2578))
(let __tmp2580 (Concat __tmp2569 __tmp2579))
(let __tmp2581 (Concat __tmp2567 __tmp2580))
(let __tmp2582 (DoWhile __tmp2557 __tmp2581))
(let __tmp2583 (InIf false __tmp2543 __tmp2555))
(let __tmp2584 (Arg __tmp2439 __tmp2583))
(let __tmp2585 (If __tmp2543 __tmp2555 __tmp2582 __tmp2584))
(let __tmp2586 (Get __tmp2585 0))
(let __tmp2587 (Single __tmp2586))
(let __tmp2588 (Get __tmp2585 1))
(let __tmp2589 (Get __tmp2585 2))
(let __tmp2590 (Get __tmp2585 3))
(let __tmp2591 (Bop __tmp291 __tmp2589 __tmp2590))
(let __tmp2592 (Bop __tmp2417 __tmp2588 __tmp2591))
(let __tmp2593 (Single __tmp2592))
(let __tmp2594 (Single __tmp2590))
(let __tmp2595 (Get __tmp2585 4))
(let __tmp2596 (Single __tmp2595))
(let __tmp2597 (Concat __tmp2594 __tmp2596))
(let __tmp2598 (Get __tmp2585 5))
(let __tmp2599 (Single __tmp2598))
(let __tmp2600 (Concat __tmp2597 __tmp2599))
(let __tmp2601 (Concat __tmp2593 __tmp2600))
(let __tmp2602 (Concat __tmp2587 __tmp2601))
(let __tmp2603 (InIf false __tmp2535 __tmp2532))
(let __tmp2604 (Arg __tmp2410 __tmp2603))
(let __tmp2605 (If __tmp2535 __tmp2532 __tmp2602 __tmp2604))
(let __tmp2606 (Concat __tmp2536 __tmp2605))
(let __tmp2607 (DoWhile __tmp2530 __tmp2606))
(let __tmp2608 (Get __tmp2607 1))
(let __tmp2609 (Single __tmp2608))
(let __tmp2610 (Get __tmp2607 0))
(let __tmp2611 (Single __tmp2610))
(let __tmp2612 (Concat __tmp2609 __tmp2611))
(let __tmp2613 (Get __tmp607 0))
(let __tmp2614 (Single __tmp2613))
(let __tmp2615 (Get __tmp607 1))
(let __tmp2616 (Single __tmp2615))
(let __tmp2617 (Get __tmp607 2))
(let __tmp2618 (Single __tmp2617))
(let __tmp2619 (Get __tmp607 3))
(let __tmp2620 (Single __tmp2619))
(let __tmp2621 (Get __tmp607 5))
(let __tmp2622 (Single __tmp2621))
(let __tmp2623 (Concat __tmp2620 __tmp2622))
(let __tmp2624 (Concat __tmp2618 __tmp2623))
(let __tmp2625 (Concat __tmp2616 __tmp2624))
(let __tmp2626 (Concat __tmp2614 __tmp2625))
(let __tmp2627 (Call "matrix_loc" __tmp2626))
(let __tmp2628 (Get __tmp2627 0))
(let __tmp2629 (Get __tmp607 4))
(let __tmp2630 (Get __tmp2627 1))
(let __tmp2631 (Top __tmp1189 __tmp2628 __tmp2629 __tmp2630))
(let __tmp2632 (Single __tmp2631))
(let __tmp2633 (Get __tmp846 2))
(let __tmp2634 (Single __tmp2633))
(let __tmp2635 (Get __tmp846 0))
(let __tmp2636 (Single __tmp2635))
(let __tmp2637 (Const __tmp125 __tmp822 __tmp825))
(let __tmp2638 (Single __tmp2637))
(let __tmp2639 (Const __tmp104 __tmp822 __tmp825))
(let __tmp2640 (Single __tmp2639))
(let __tmp2641 (Get __tmp846 1))
(let __tmp2642 (Single __tmp2641))
(let __tmp2643 (Concat __tmp2640 __tmp2642))
(let __tmp2644 (Concat __tmp2638 __tmp2643))
(let __tmp2645 (Concat __tmp2636 __tmp2644))
(let __tmp2646 (Concat __tmp2634 __tmp2645))
(let __tmp2647 (InFunc " loop_ctx_33"))
(let __tmp2648 (Arg __tmp2410 __tmp2647))
(let __tmp2649 (Get __tmp2648 1))
(let __tmp2650 (Get __tmp2648 4))
(let __tmp2651 (Bop __tmp2405 __tmp2649 __tmp2650))
(let __tmp2652 (Single __tmp2651))
(let __tmp2653 (InIf true __tmp2651 __tmp2648))
(let __tmp2654 (Arg __tmp2410 __tmp2653))
(let __tmp2655 (Get __tmp2654 1))
(let __tmp2656 (Get __tmp2654 4))
(let __tmp2657 (Bop __tmp2417 __tmp2655 __tmp2656))
(let __tmp2658 (Get __tmp2654 3))
(let __tmp2659 (Bop __tmp2405 __tmp2657 __tmp2658))
(let __tmp2660 (Get __tmp2654 0))
(let __tmp2661 (Single __tmp2660))
(let __tmp2662 (Single __tmp2655))
(let __tmp2663 (Single __tmp2656))
(let __tmp2664 (Get __tmp2654 2))
(let __tmp2665 (Single __tmp2664))
(let __tmp2666 (Single __tmp2658))
(let __tmp2667 (Concat __tmp2666 __tmp2663))
(let __tmp2668 (Concat __tmp2665 __tmp2667))
(let __tmp2669 (Concat __tmp2663 __tmp2668))
(let __tmp2670 (Concat __tmp2662 __tmp2669))
(let __tmp2671 (Concat __tmp2661 __tmp2670))
(let __tmp2672 (InIf true __tmp2659 __tmp2671))
(let __tmp2673 (Arg __tmp2439 __tmp2672))
(let __tmp2674 (InFunc " loop_ctx_34"))
(let __tmp2675 (Arg __tmp2439 __tmp2674))
(let __tmp2676 (Get __tmp2675 1))
(let __tmp2677 (Get __tmp2675 2))
(let __tmp2678 (Get __tmp2675 3))
(let __tmp2679 (Bop __tmp293 __tmp2677 __tmp2678))
(let __tmp2680 (Bop __tmp2417 __tmp2676 __tmp2679))
(let __tmp2681 (Get __tmp2675 4))
(let __tmp2682 (Bop __tmp2405 __tmp2680 __tmp2681))
(let __tmp2683 (Single __tmp2682))
(let __tmp2684 (Get __tmp2675 0))
(let __tmp2685 (Single __tmp2684))
(let __tmp2686 (Single __tmp2676))
(let __tmp2687 (Single __tmp2679))
(let __tmp2688 (Single __tmp2678))
(let __tmp2689 (Concat __tmp2687 __tmp2688))
(let __tmp2690 (Single __tmp2681))
(let __tmp2691 (Concat __tmp2689 __tmp2690))
(let __tmp2692 (Get __tmp2675 5))
(let __tmp2693 (Single __tmp2692))
(let __tmp2694 (Concat __tmp2691 __tmp2693))
(let __tmp2695 (Concat __tmp2686 __tmp2694))
(let __tmp2696 (Concat __tmp2685 __tmp2695))
(let __tmp2697 (Concat __tmp2683 __tmp2696))
(let __tmp2698 (DoWhile __tmp2673 __tmp2697))
(let __tmp2699 (InIf false __tmp2659 __tmp2671))
(let __tmp2700 (Arg __tmp2439 __tmp2699))
(let __tmp2701 (If __tmp2659 __tmp2671 __tmp2698 __tmp2700))
(let __tmp2702 (Get __tmp2701 0))
(let __tmp2703 (Single __tmp2702))
(let __tmp2704 (Get __tmp2701 1))
(let __tmp2705 (Get __tmp2701 2))
(let __tmp2706 (Get __tmp2701 3))
(let __tmp2707 (Bop __tmp291 __tmp2705 __tmp2706))
(let __tmp2708 (Bop __tmp2417 __tmp2704 __tmp2707))
(let __tmp2709 (Single __tmp2708))
(let __tmp2710 (Single __tmp2706))
(let __tmp2711 (Get __tmp2701 4))
(let __tmp2712 (Single __tmp2711))
(let __tmp2713 (Concat __tmp2710 __tmp2712))
(let __tmp2714 (Get __tmp2701 5))
(let __tmp2715 (Single __tmp2714))
(let __tmp2716 (Concat __tmp2713 __tmp2715))
(let __tmp2717 (Concat __tmp2709 __tmp2716))
(let __tmp2718 (Concat __tmp2703 __tmp2717))
(let __tmp2719 (InIf false __tmp2651 __tmp2648))
(let __tmp2720 (Arg __tmp2410 __tmp2719))
(let __tmp2721 (If __tmp2651 __tmp2648 __tmp2718 __tmp2720))
(let __tmp2722 (Concat __tmp2652 __tmp2721))
(let __tmp2723 (DoWhile __tmp2646 __tmp2722))
(let __tmp2724 (Get __tmp2723 1))
(let __tmp2725 (Single __tmp2724))
(let __tmp2726 (Get __tmp2723 0))
(let __tmp2727 (Single __tmp2726))
(let __tmp2728 (Concat __tmp2725 __tmp2727))
(let __tmp2729 (Get __tmp859 0))
(let __tmp2730 (Single __tmp2729))
(let __tmp2731 (Get __tmp859 1))
(let __tmp2732 (Single __tmp2731))
(let __tmp2733 (Get __tmp859 2))
(let __tmp2734 (Single __tmp2733))
(let __tmp2735 (Get __tmp859 3))
(let __tmp2736 (Single __tmp2735))
(let __tmp2737 (Get __tmp859 5))
(let __tmp2738 (Single __tmp2737))
(let __tmp2739 (Concat __tmp2736 __tmp2738))
(let __tmp2740 (Concat __tmp2734 __tmp2739))
(let __tmp2741 (Concat __tmp2732 __tmp2740))
(let __tmp2742 (Concat __tmp2730 __tmp2741))
(let __tmp2743 (Call "matrix_loc" __tmp2742))
(let __tmp2744 (Get __tmp2743 0))
(let __tmp2745 (Get __tmp859 4))
(let __tmp2746 (Get __tmp2743 1))
(let __tmp2747 (Top __tmp1189 __tmp2744 __tmp2745 __tmp2746))
(let __tmp2748 (Single __tmp2747))
(let __tmp2749 (Get __tmp1058 2))
(let __tmp2750 (Single __tmp2749))
(let __tmp2751 (Get __tmp1058 0))
(let __tmp2752 (Single __tmp2751))
(let __tmp2753 (Const __tmp125 __tmp1033 __tmp1036))
(let __tmp2754 (Single __tmp2753))
(let __tmp2755 (Const __tmp104 __tmp1033 __tmp1036))
(let __tmp2756 (Single __tmp2755))
(let __tmp2757 (Get __tmp1058 1))
(let __tmp2758 (Single __tmp2757))
(let __tmp2759 (Concat __tmp2756 __tmp2758))
(let __tmp2760 (Concat __tmp2754 __tmp2759))
(let __tmp2761 (Concat __tmp2752 __tmp2760))
(let __tmp2762 (Concat __tmp2750 __tmp2761))
(let __tmp2763 (InFunc " loop_ctx_35"))
(let __tmp2764 (Arg __tmp2410 __tmp2763))
(let __tmp2765 (Get __tmp2764 1))
(let __tmp2766 (Get __tmp2764 4))
(let __tmp2767 (Bop __tmp2405 __tmp2765 __tmp2766))
(let __tmp2768 (Single __tmp2767))
(let __tmp2769 (InIf true __tmp2767 __tmp2764))
(let __tmp2770 (Arg __tmp2410 __tmp2769))
(let __tmp2771 (Get __tmp2770 1))
(let __tmp2772 (Get __tmp2770 4))
(let __tmp2773 (Bop __tmp2417 __tmp2771 __tmp2772))
(let __tmp2774 (Get __tmp2770 3))
(let __tmp2775 (Bop __tmp2405 __tmp2773 __tmp2774))
(let __tmp2776 (Get __tmp2770 0))
(let __tmp2777 (Single __tmp2776))
(let __tmp2778 (Single __tmp2771))
(let __tmp2779 (Single __tmp2772))
(let __tmp2780 (Get __tmp2770 2))
(let __tmp2781 (Single __tmp2780))
(let __tmp2782 (Single __tmp2774))
(let __tmp2783 (Concat __tmp2782 __tmp2779))
(let __tmp2784 (Concat __tmp2781 __tmp2783))
(let __tmp2785 (Concat __tmp2779 __tmp2784))
(let __tmp2786 (Concat __tmp2778 __tmp2785))
(let __tmp2787 (Concat __tmp2777 __tmp2786))
(let __tmp2788 (InIf true __tmp2775 __tmp2787))
(let __tmp2789 (Arg __tmp2439 __tmp2788))
(let __tmp2790 (InFunc " loop_ctx_36"))
(let __tmp2791 (Arg __tmp2439 __tmp2790))
(let __tmp2792 (Get __tmp2791 1))
(let __tmp2793 (Get __tmp2791 2))
(let __tmp2794 (Get __tmp2791 3))
(let __tmp2795 (Bop __tmp293 __tmp2793 __tmp2794))
(let __tmp2796 (Bop __tmp2417 __tmp2792 __tmp2795))
(let __tmp2797 (Get __tmp2791 4))
(let __tmp2798 (Bop __tmp2405 __tmp2796 __tmp2797))
(let __tmp2799 (Single __tmp2798))
(let __tmp2800 (Get __tmp2791 0))
(let __tmp2801 (Single __tmp2800))
(let __tmp2802 (Single __tmp2792))
(let __tmp2803 (Single __tmp2795))
(let __tmp2804 (Single __tmp2794))
(let __tmp2805 (Concat __tmp2803 __tmp2804))
(let __tmp2806 (Single __tmp2797))
(let __tmp2807 (Concat __tmp2805 __tmp2806))
(let __tmp2808 (Get __tmp2791 5))
(let __tmp2809 (Single __tmp2808))
(let __tmp2810 (Concat __tmp2807 __tmp2809))
(let __tmp2811 (Concat __tmp2802 __tmp2810))
(let __tmp2812 (Concat __tmp2801 __tmp2811))
(let __tmp2813 (Concat __tmp2799 __tmp2812))
(let __tmp2814 (DoWhile __tmp2789 __tmp2813))
(let __tmp2815 (InIf false __tmp2775 __tmp2787))
(let __tmp2816 (Arg __tmp2439 __tmp2815))
(let __tmp2817 (If __tmp2775 __tmp2787 __tmp2814 __tmp2816))
(let __tmp2818 (Get __tmp2817 0))
(let __tmp2819 (Single __tmp2818))
(let __tmp2820 (Get __tmp2817 1))
(let __tmp2821 (Get __tmp2817 2))
(let __tmp2822 (Get __tmp2817 3))
(let __tmp2823 (Bop __tmp291 __tmp2821 __tmp2822))
(let __tmp2824 (Bop __tmp2417 __tmp2820 __tmp2823))
(let __tmp2825 (Single __tmp2824))
(let __tmp2826 (Single __tmp2822))
(let __tmp2827 (Get __tmp2817 4))
(let __tmp2828 (Single __tmp2827))
(let __tmp2829 (Concat __tmp2826 __tmp2828))
(let __tmp2830 (Get __tmp2817 5))
(let __tmp2831 (Single __tmp2830))
(let __tmp2832 (Concat __tmp2829 __tmp2831))
(let __tmp2833 (Concat __tmp2825 __tmp2832))
(let __tmp2834 (Concat __tmp2819 __tmp2833))
(let __tmp2835 (InIf false __tmp2767 __tmp2764))
(let __tmp2836 (Arg __tmp2410 __tmp2835))
(let __tmp2837 (If __tmp2767 __tmp2764 __tmp2834 __tmp2836))
(let __tmp2838 (Concat __tmp2768 __tmp2837))
(let __tmp2839 (DoWhile __tmp2762 __tmp2838))
(let __tmp2840 (Get __tmp2839 1))
(let __tmp2841 (Single __tmp2840))
(let __tmp2842 (Get __tmp2839 0))
(let __tmp2843 (Single __tmp2842))
(let __tmp2844 (Concat __tmp2841 __tmp2843))
(let __tmp2845 (Get __tmp1071 0))
(let __tmp2846 (Single __tmp2845))
(let __tmp2847 (Get __tmp1071 1))
(let __tmp2848 (Single __tmp2847))
(let __tmp2849 (Get __tmp1071 2))
(let __tmp2850 (Single __tmp2849))
(let __tmp2851 (Get __tmp1071 3))
(let __tmp2852 (Single __tmp2851))
(let __tmp2853 (Get __tmp1071 5))
(let __tmp2854 (Single __tmp2853))
(let __tmp2855 (Concat __tmp2852 __tmp2854))
(let __tmp2856 (Concat __tmp2850 __tmp2855))
(let __tmp2857 (Concat __tmp2848 __tmp2856))
(let __tmp2858 (Concat __tmp2846 __tmp2857))
(let __tmp2859 (Call "matrix_loc" __tmp2858))
(let __tmp2860 (Get __tmp2859 0))
(let __tmp2861 (Get __tmp1071 4))
(let __tmp2862 (Get __tmp2859 1))
(let __tmp2863 (Top __tmp1189 __tmp2860 __tmp2861 __tmp2862))
(let __tmp2864 (Single __tmp2863))
(let __tmp2865 (Get __tmp1203 0))
(let __tmp2866 (Get __tmp1203 2))
(let __tmp2867 (Get __tmp1203 3))
(let __tmp2868 (Get __tmp1203 1))
(let __tmp2869 (Bop __tmp15 __tmp2867 __tmp2868))
(let __tmp2870 (Bop __tmp326 __tmp2866 __tmp2869))
(let __tmp2871 (Bop __tmp2361 __tmp2865 __tmp2870))
(let __tmp2872 (Single __tmp2871))
(let __tmp2873 (Get __tmp1203 4))
(let __tmp2874 (Single __tmp2873))
(let __tmp2875 (Concat __tmp2872 __tmp2874))
(let __tmp2876 (Get __tmp1233 0))
(let __tmp2877 (Get __tmp1233 2))
(let __tmp2878 (Get __tmp1233 3))
(let __tmp2879 (Get __tmp1233 1))
(let __tmp2880 (Bop __tmp15 __tmp2878 __tmp2879))
(let __tmp2881 (Bop __tmp326 __tmp2877 __tmp2880))
(let __tmp2882 (Bop __tmp2361 __tmp2876 __tmp2881))
(let __tmp2883 (Single __tmp2882))
(let __tmp2884 (Get __tmp1233 4))
(let __tmp2885 (Single __tmp2884))
(let __tmp2886 (Concat __tmp2883 __tmp2885))
(let __tmp2887 (Get __tmp1251 0))
(let __tmp2888 (Get __tmp1251 2))
(let __tmp2889 (Get __tmp1251 3))
(let __tmp2890 (Get __tmp1251 1))
(let __tmp2891 (Bop __tmp15 __tmp2889 __tmp2890))
(let __tmp2892 (Bop __tmp326 __tmp2888 __tmp2891))
(let __tmp2893 (Bop __tmp2361 __tmp2887 __tmp2892))
(let __tmp2894 (Single __tmp2893))
(let __tmp2895 (Get __tmp1251 4))
(let __tmp2896 (Single __tmp2895))
(let __tmp2897 (Concat __tmp2894 __tmp2896))
(let __tmp2898 (Get __tmp1284 0))
(let __tmp2899 (Get __tmp1284 2))
(let __tmp2900 (Get __tmp1284 3))
(let __tmp2901 (Get __tmp1284 1))
(let __tmp2902 (Bop __tmp15 __tmp2900 __tmp2901))
(let __tmp2903 (Bop __tmp326 __tmp2899 __tmp2902))
(let __tmp2904 (Bop __tmp2361 __tmp2898 __tmp2903))
(let __tmp2905 (Single __tmp2904))
(let __tmp2906 (Get __tmp1284 4))
(let __tmp2907 (Single __tmp2906))
(let __tmp2908 (Concat __tmp2905 __tmp2907))
(let __tmp2909 (Get __tmp1581 0))
(let __tmp2910 (Get __tmp1581 2))
(let __tmp2911 (Get __tmp1581 3))
(let __tmp2912 (Get __tmp1581 1))
(let __tmp2913 (Bop __tmp15 __tmp2911 __tmp2912))
(let __tmp2914 (Bop __tmp326 __tmp2910 __tmp2913))
(let __tmp2915 (Bop __tmp2361 __tmp2909 __tmp2914))
(let __tmp2916 (Single __tmp2915))
(let __tmp2917 (Get __tmp1581 4))
(let __tmp2918 (Single __tmp2917))
(let __tmp2919 (Concat __tmp2916 __tmp2918))
(let __tmp2920 (Get __tmp1612 0))
(let __tmp2921 (Get __tmp1612 2))
(let __tmp2922 (Get __tmp1612 3))
(let __tmp2923 (Get __tmp1612 1))
(let __tmp2924 (Bop __tmp15 __tmp2922 __tmp2923))
(let __tmp2925 (Bop __tmp326 __tmp2921 __tmp2924))
(let __tmp2926 (Bop __tmp2361 __tmp2920 __tmp2925))
(let __tmp2927 (Single __tmp2926))
(let __tmp2928 (Get __tmp1612 4))
(let __tmp2929 (Single __tmp2928))
(let __tmp2930 (Concat __tmp2927 __tmp2929))
(let __tmp2931 (Get __tmp1629 0))
(let __tmp2932 (Get __tmp1629 2))
(let __tmp2933 (Get __tmp1629 3))
(let __tmp2934 (Get __tmp1629 1))
(let __tmp2935 (Bop __tmp15 __tmp2933 __tmp2934))
(let __tmp2936 (Bop __tmp326 __tmp2932 __tmp2935))
(let __tmp2937 (Bop __tmp2361 __tmp2931 __tmp2936))
(let __tmp2938 (Single __tmp2937))
(let __tmp2939 (Get __tmp1629 4))
(let __tmp2940 (Single __tmp2939))
(let __tmp2941 (Concat __tmp2938 __tmp2940))
(let __tmp2942 (Get __tmp1662 0))
(let __tmp2943 (Get __tmp1662 2))
(let __tmp2944 (Get __tmp1662 3))
(let __tmp2945 (Get __tmp1662 1))
(let __tmp2946 (Bop __tmp15 __tmp2944 __tmp2945))
(let __tmp2947 (Bop __tmp326 __tmp2943 __tmp2946))
(let __tmp2948 (Bop __tmp2361 __tmp2942 __tmp2947))
(let __tmp2949 (Single __tmp2948))
(let __tmp2950 (Get __tmp1662 4))
(let __tmp2951 (Single __tmp2950))
(let __tmp2952 (Concat __tmp2949 __tmp2951))
(let __tmp2953 (Get __tmp1980 0))
(let __tmp2954 (Get __tmp1980 2))
(let __tmp2955 (Get __tmp1980 3))
(let __tmp2956 (Get __tmp1980 1))
(let __tmp2957 (Bop __tmp15 __tmp2955 __tmp2956))
(let __tmp2958 (Bop __tmp326 __tmp2954 __tmp2957))
(let __tmp2959 (Bop __tmp2361 __tmp2953 __tmp2958))
(let __tmp2960 (Single __tmp2959))
(let __tmp2961 (Get __tmp1980 4))
(let __tmp2962 (Single __tmp2961))
(let __tmp2963 (Concat __tmp2960 __tmp2962))
(let __tmp2964 (Get __tmp2012 0))
(let __tmp2965 (Get __tmp2012 2))
(let __tmp2966 (Get __tmp2012 3))
(let __tmp2967 (Get __tmp2012 1))
(let __tmp2968 (Bop __tmp15 __tmp2966 __tmp2967))
(let __tmp2969 (Bop __tmp326 __tmp2965 __tmp2968))
(let __tmp2970 (Bop __tmp2361 __tmp2964 __tmp2969))
(let __tmp2971 (Single __tmp2970))
(let __tmp2972 (Get __tmp2012 4))
(let __tmp2973 (Single __tmp2972))
(let __tmp2974 (Concat __tmp2971 __tmp2973))
(let __tmp2975 (Get __tmp2029 0))
(let __tmp2976 (Get __tmp2029 2))
(let __tmp2977 (Get __tmp2029 3))
(let __tmp2978 (Get __tmp2029 1))
(let __tmp2979 (Bop __tmp15 __tmp2977 __tmp2978))
(let __tmp2980 (Bop __tmp326 __tmp2976 __tmp2979))
(let __tmp2981 (Bop __tmp2361 __tmp2975 __tmp2980))
(let __tmp2982 (Single __tmp2981))
(let __tmp2983 (Get __tmp2029 4))
(let __tmp2984 (Single __tmp2983))
(let __tmp2985 (Concat __tmp2982 __tmp2984))
(let __tmp2986 (Get __tmp2062 0))
(let __tmp2987 (Get __tmp2062 2))
(let __tmp2988 (Get __tmp2062 3))
(let __tmp2989 (Get __tmp2062 1))
(let __tmp2990 (Bop __tmp15 __tmp2988 __tmp2989))
(let __tmp2991 (Bop __tmp326 __tmp2987 __tmp2990))
(let __tmp2992 (Bop __tmp2361 __tmp2986 __tmp2991))
(let __tmp2993 (Single __tmp2992))
(let __tmp2994 (Get __tmp2062 4))
(let __tmp2995 (Single __tmp2994))
(let __tmp2996 (Concat __tmp2993 __tmp2995))
(let __tmp2997 (InFunc " loop_ctx_13"))
(let __tmp2998 (Arg __tmp278 __tmp2997))
(let __tmp2999 (Get __tmp2998 1))
(let __tmp3000 (Get __tmp2998 5))
(let __tmp3001 (Bop __tmp293 __tmp2999 __tmp3000))
(let __tmp3002 (Get __tmp2998 2))
(let __tmp3003 (Bop __tmp292 __tmp3001 __tmp3002))
(let __tmp3004 (Single __tmp3003))
(let __tmp3005 (Get __tmp2998 21))
(let __tmp3006 (Single __tmp3005))
(let __tmp3007 (Get __tmp2998 0))
(let __tmp3008 (Single __tmp3007))
(let __tmp3009 (Concat __tmp3006 __tmp3008))
(let __tmp3010 (Concat __tmp3004 __tmp3009))
(let __tmp3011 (Call "fmod" __tmp3010))
(let __tmp3012 (Get __tmp3010 2))
(let __tmp3013 (Single __tmp3012))
(let __tmp3014 (Get __tmp3010 0))
(let __tmp3015 (Single __tmp3014))
(let __tmp3016 (Const __tmp125 __tmp278 __tmp2997))
(let __tmp3017 (Single __tmp3016))
(let __tmp3018 (Const __tmp104 __tmp278 __tmp2997))
(let __tmp3019 (Single __tmp3018))
(let __tmp3020 (Get __tmp3010 1))
(let __tmp3021 (Single __tmp3020))
(let __tmp3022 (Concat __tmp3019 __tmp3021))
(let __tmp3023 (Concat __tmp3017 __tmp3022))
(let __tmp3024 (Concat __tmp3015 __tmp3023))
(let __tmp3025 (Concat __tmp3013 __tmp3024))
(let __tmp3026 (InFunc " loop_ctx_37"))
(let __tmp3027 (Arg __tmp2410 __tmp3026))
(let __tmp3028 (Get __tmp3027 1))
(let __tmp3029 (Get __tmp3027 4))
(let __tmp3030 (Bop __tmp2405 __tmp3028 __tmp3029))
(let __tmp3031 (Single __tmp3030))
(let __tmp3032 (InIf true __tmp3030 __tmp3027))
(let __tmp3033 (Arg __tmp2410 __tmp3032))
(let __tmp3034 (Get __tmp3033 1))
(let __tmp3035 (Get __tmp3033 4))
(let __tmp3036 (Bop __tmp2417 __tmp3034 __tmp3035))
(let __tmp3037 (Get __tmp3033 3))
(let __tmp3038 (Bop __tmp2405 __tmp3036 __tmp3037))
(let __tmp3039 (Get __tmp3033 0))
(let __tmp3040 (Single __tmp3039))
(let __tmp3041 (Single __tmp3034))
(let __tmp3042 (Single __tmp3035))
(let __tmp3043 (Get __tmp3033 2))
(let __tmp3044 (Single __tmp3043))
(let __tmp3045 (Single __tmp3037))
(let __tmp3046 (Concat __tmp3045 __tmp3042))
(let __tmp3047 (Concat __tmp3044 __tmp3046))
(let __tmp3048 (Concat __tmp3042 __tmp3047))
(let __tmp3049 (Concat __tmp3041 __tmp3048))
(let __tmp3050 (Concat __tmp3040 __tmp3049))
(let __tmp3051 (InIf true __tmp3038 __tmp3050))
(let __tmp3052 (Arg __tmp2439 __tmp3051))
(let __tmp3053 (InFunc " loop_ctx_38"))
(let __tmp3054 (Arg __tmp2439 __tmp3053))
(let __tmp3055 (Get __tmp3054 1))
(let __tmp3056 (Get __tmp3054 2))
(let __tmp3057 (Get __tmp3054 3))
(let __tmp3058 (Bop __tmp293 __tmp3056 __tmp3057))
(let __tmp3059 (Bop __tmp2417 __tmp3055 __tmp3058))
(let __tmp3060 (Get __tmp3054 4))
(let __tmp3061 (Bop __tmp2405 __tmp3059 __tmp3060))
(let __tmp3062 (Single __tmp3061))
(let __tmp3063 (Get __tmp3054 0))
(let __tmp3064 (Single __tmp3063))
(let __tmp3065 (Single __tmp3055))
(let __tmp3066 (Single __tmp3058))
(let __tmp3067 (Single __tmp3057))
(let __tmp3068 (Concat __tmp3066 __tmp3067))
(let __tmp3069 (Single __tmp3060))
(let __tmp3070 (Concat __tmp3068 __tmp3069))
(let __tmp3071 (Get __tmp3054 5))
(let __tmp3072 (Single __tmp3071))
(let __tmp3073 (Concat __tmp3070 __tmp3072))
(let __tmp3074 (Concat __tmp3065 __tmp3073))
(let __tmp3075 (Concat __tmp3064 __tmp3074))
(let __tmp3076 (Concat __tmp3062 __tmp3075))
(let __tmp3077 (DoWhile __tmp3052 __tmp3076))
(let __tmp3078 (InIf false __tmp3038 __tmp3050))
(let __tmp3079 (Arg __tmp2439 __tmp3078))
(let __tmp3080 (If __tmp3038 __tmp3050 __tmp3077 __tmp3079))
(let __tmp3081 (Get __tmp3080 0))
(let __tmp3082 (Single __tmp3081))
(let __tmp3083 (Get __tmp3080 1))
(let __tmp3084 (Get __tmp3080 2))
(let __tmp3085 (Get __tmp3080 3))
(let __tmp3086 (Bop __tmp291 __tmp3084 __tmp3085))
(let __tmp3087 (Bop __tmp2417 __tmp3083 __tmp3086))
(let __tmp3088 (Single __tmp3087))
(let __tmp3089 (Single __tmp3085))
(let __tmp3090 (Get __tmp3080 4))
(let __tmp3091 (Single __tmp3090))
(let __tmp3092 (Concat __tmp3089 __tmp3091))
(let __tmp3093 (Get __tmp3080 5))
(let __tmp3094 (Single __tmp3093))
(let __tmp3095 (Concat __tmp3092 __tmp3094))
(let __tmp3096 (Concat __tmp3088 __tmp3095))
(let __tmp3097 (Concat __tmp3082 __tmp3096))
(let __tmp3098 (InIf false __tmp3030 __tmp3027))
(let __tmp3099 (Arg __tmp2410 __tmp3098))
(let __tmp3100 (If __tmp3030 __tmp3027 __tmp3097 __tmp3099))
(let __tmp3101 (Concat __tmp3031 __tmp3100))
(let __tmp3102 (DoWhile __tmp3025 __tmp3101))
(let __tmp3103 (Get __tmp3102 1))
(let __tmp3104 (Single __tmp3103))
(let __tmp3105 (Get __tmp3102 0))
(let __tmp3106 (Single __tmp3105))
(let __tmp3107 (Concat __tmp3104 __tmp3106))
(let __tmp3108 (Get __tmp2998 20))
(let __tmp3109 (Single __tmp3108))
(let __tmp3110 (Get __tmp2998 3))
(let __tmp3111 (Single __tmp3110))
(let __tmp3112 (Get __tmp2998 6))
(let __tmp3113 (Single __tmp3112))
(let __tmp3114 (Get __tmp2998 19))
(let __tmp3115 (Single __tmp3114))
(let __tmp3116 (Get __tmp3011 0))
(let __tmp3117 (Get __tmp2998 9))
(let __tmp3118 (Bop __tmp293 __tmp3117 __tmp3005))
(let __tmp3119 (Bop __tmp291 __tmp3116 __tmp3118))
(let __tmp3120 (Single __tmp3119))
(let __tmp3121 (Get __tmp3011 1))
(let __tmp3122 (Single __tmp3121))
(let __tmp3123 (Concat __tmp3120 __tmp3122))
(let __tmp3124 (Concat __tmp3115 __tmp3123))
(let __tmp3125 (Concat __tmp3113 __tmp3124))
(let __tmp3126 (Concat __tmp3111 __tmp3125))
(let __tmp3127 (Concat __tmp3109 __tmp3126))
(let __tmp3128 (Call "matrix_set" __tmp3127))
(let __tmp3129 (Get __tmp3127 0))
(let __tmp3130 (Single __tmp3129))
(let __tmp3131 (Get __tmp3127 1))
(let __tmp3132 (Single __tmp3131))
(let __tmp3133 (Get __tmp3127 2))
(let __tmp3134 (Single __tmp3133))
(let __tmp3135 (Get __tmp3127 3))
(let __tmp3136 (Single __tmp3135))
(let __tmp3137 (Get __tmp3127 5))
(let __tmp3138 (Single __tmp3137))
(let __tmp3139 (Concat __tmp3136 __tmp3138))
(let __tmp3140 (Concat __tmp3134 __tmp3139))
(let __tmp3141 (Concat __tmp3132 __tmp3140))
(let __tmp3142 (Concat __tmp3130 __tmp3141))
(let __tmp3143 (Call "matrix_loc" __tmp3142))
(let __tmp3144 (Get __tmp3143 0))
(let __tmp3145 (Get __tmp3127 4))
(let __tmp3146 (Get __tmp3143 1))
(let __tmp3147 (Top __tmp1189 __tmp3144 __tmp3145 __tmp3146))
(let __tmp3148 (Single __tmp3147))
(let __tmp3149 (InFunc " loop_ctx_14"))
(let __tmp3150 (Arg __tmp568 __tmp3149))
(let __tmp3151 (Get __tmp3150 1))
(let __tmp3152 (Get __tmp3150 5))
(let __tmp3153 (Get __tmp3150 2))
(let __tmp3154 (Bop __tmp292 __tmp3152 __tmp3153))
(let __tmp3155 (Bop __tmp293 __tmp3151 __tmp3154))
(let __tmp3156 (Get __tmp3150 11))
(let __tmp3157 (Bop __tmp292 __tmp3155 __tmp3156))
(let __tmp3158 (Single __tmp3157))
(let __tmp3159 (Get __tmp3150 18))
(let __tmp3160 (Single __tmp3159))
(let __tmp3161 (Get __tmp3150 0))
(let __tmp3162 (Single __tmp3161))
(let __tmp3163 (Concat __tmp3160 __tmp3162))
(let __tmp3164 (Concat __tmp3158 __tmp3163))
(let __tmp3165 (Call "fmod" __tmp3164))
(let __tmp3166 (Get __tmp3164 2))
(let __tmp3167 (Single __tmp3166))
(let __tmp3168 (Get __tmp3164 0))
(let __tmp3169 (Single __tmp3168))
(let __tmp3170 (Const __tmp125 __tmp568 __tmp3149))
(let __tmp3171 (Single __tmp3170))
(let __tmp3172 (Const __tmp104 __tmp568 __tmp3149))
(let __tmp3173 (Single __tmp3172))
(let __tmp3174 (Get __tmp3164 1))
(let __tmp3175 (Single __tmp3174))
(let __tmp3176 (Concat __tmp3173 __tmp3175))
(let __tmp3177 (Concat __tmp3171 __tmp3176))
(let __tmp3178 (Concat __tmp3169 __tmp3177))
(let __tmp3179 (Concat __tmp3167 __tmp3178))
(let __tmp3180 (InFunc " loop_ctx_39"))
(let __tmp3181 (Arg __tmp2410 __tmp3180))
(let __tmp3182 (Get __tmp3181 1))
(let __tmp3183 (Get __tmp3181 4))
(let __tmp3184 (Bop __tmp2405 __tmp3182 __tmp3183))
(let __tmp3185 (Single __tmp3184))
(let __tmp3186 (InIf true __tmp3184 __tmp3181))
(let __tmp3187 (Arg __tmp2410 __tmp3186))
(let __tmp3188 (Get __tmp3187 1))
(let __tmp3189 (Get __tmp3187 4))
(let __tmp3190 (Bop __tmp2417 __tmp3188 __tmp3189))
(let __tmp3191 (Get __tmp3187 3))
(let __tmp3192 (Bop __tmp2405 __tmp3190 __tmp3191))
(let __tmp3193 (Get __tmp3187 0))
(let __tmp3194 (Single __tmp3193))
(let __tmp3195 (Single __tmp3188))
(let __tmp3196 (Single __tmp3189))
(let __tmp3197 (Get __tmp3187 2))
(let __tmp3198 (Single __tmp3197))
(let __tmp3199 (Single __tmp3191))
(let __tmp3200 (Concat __tmp3199 __tmp3196))
(let __tmp3201 (Concat __tmp3198 __tmp3200))
(let __tmp3202 (Concat __tmp3196 __tmp3201))
(let __tmp3203 (Concat __tmp3195 __tmp3202))
(let __tmp3204 (Concat __tmp3194 __tmp3203))
(let __tmp3205 (InIf true __tmp3192 __tmp3204))
(let __tmp3206 (Arg __tmp2439 __tmp3205))
(let __tmp3207 (InFunc " loop_ctx_40"))
(let __tmp3208 (Arg __tmp2439 __tmp3207))
(let __tmp3209 (Get __tmp3208 1))
(let __tmp3210 (Get __tmp3208 2))
(let __tmp3211 (Get __tmp3208 3))
(let __tmp3212 (Bop __tmp293 __tmp3210 __tmp3211))
(let __tmp3213 (Bop __tmp2417 __tmp3209 __tmp3212))
(let __tmp3214 (Get __tmp3208 4))
(let __tmp3215 (Bop __tmp2405 __tmp3213 __tmp3214))
(let __tmp3216 (Single __tmp3215))
(let __tmp3217 (Get __tmp3208 0))
(let __tmp3218 (Single __tmp3217))
(let __tmp3219 (Single __tmp3209))
(let __tmp3220 (Single __tmp3212))
(let __tmp3221 (Single __tmp3211))
(let __tmp3222 (Concat __tmp3220 __tmp3221))
(let __tmp3223 (Single __tmp3214))
(let __tmp3224 (Concat __tmp3222 __tmp3223))
(let __tmp3225 (Get __tmp3208 5))
(let __tmp3226 (Single __tmp3225))
(let __tmp3227 (Concat __tmp3224 __tmp3226))
(let __tmp3228 (Concat __tmp3219 __tmp3227))
(let __tmp3229 (Concat __tmp3218 __tmp3228))
(let __tmp3230 (Concat __tmp3216 __tmp3229))
(let __tmp3231 (DoWhile __tmp3206 __tmp3230))
(let __tmp3232 (InIf false __tmp3192 __tmp3204))
(let __tmp3233 (Arg __tmp2439 __tmp3232))
(let __tmp3234 (If __tmp3192 __tmp3204 __tmp3231 __tmp3233))
(let __tmp3235 (Get __tmp3234 0))
(let __tmp3236 (Single __tmp3235))
(let __tmp3237 (Get __tmp3234 1))
(let __tmp3238 (Get __tmp3234 2))
(let __tmp3239 (Get __tmp3234 3))
(let __tmp3240 (Bop __tmp291 __tmp3238 __tmp3239))
(let __tmp3241 (Bop __tmp2417 __tmp3237 __tmp3240))
(let __tmp3242 (Single __tmp3241))
(let __tmp3243 (Single __tmp3239))
(let __tmp3244 (Get __tmp3234 4))
(let __tmp3245 (Single __tmp3244))
(let __tmp3246 (Concat __tmp3243 __tmp3245))
(let __tmp3247 (Get __tmp3234 5))
(let __tmp3248 (Single __tmp3247))
(let __tmp3249 (Concat __tmp3246 __tmp3248))
(let __tmp3250 (Concat __tmp3242 __tmp3249))
(let __tmp3251 (Concat __tmp3236 __tmp3250))
(let __tmp3252 (InIf false __tmp3184 __tmp3181))
(let __tmp3253 (Arg __tmp2410 __tmp3252))
(let __tmp3254 (If __tmp3184 __tmp3181 __tmp3251 __tmp3253))
(let __tmp3255 (Concat __tmp3185 __tmp3254))
(let __tmp3256 (DoWhile __tmp3179 __tmp3255))
(let __tmp3257 (Get __tmp3256 1))
(let __tmp3258 (Single __tmp3257))
(let __tmp3259 (Get __tmp3256 0))
(let __tmp3260 (Single __tmp3259))
(let __tmp3261 (Concat __tmp3258 __tmp3260))
(let __tmp3262 (Get __tmp3150 17))
(let __tmp3263 (Single __tmp3262))
(let __tmp3264 (Get __tmp3150 3))
(let __tmp3265 (Single __tmp3264))
(let __tmp3266 (Get __tmp3150 6))
(let __tmp3267 (Single __tmp3266))
(let __tmp3268 (Get __tmp3150 16))
(let __tmp3269 (Single __tmp3268))
(let __tmp3270 (Get __tmp3165 0))
(let __tmp3271 (Get __tmp3150 9))
(let __tmp3272 (Bop __tmp293 __tmp3271 __tmp3159))
(let __tmp3273 (Bop __tmp291 __tmp3270 __tmp3272))
(let __tmp3274 (Single __tmp3273))
(let __tmp3275 (Get __tmp3165 1))
(let __tmp3276 (Single __tmp3275))
(let __tmp3277 (Concat __tmp3274 __tmp3276))
(let __tmp3278 (Concat __tmp3269 __tmp3277))
(let __tmp3279 (Concat __tmp3267 __tmp3278))
(let __tmp3280 (Concat __tmp3265 __tmp3279))
(let __tmp3281 (Concat __tmp3263 __tmp3280))
(let __tmp3282 (Call "matrix_set" __tmp3281))
(let __tmp3283 (Get __tmp3281 0))
(let __tmp3284 (Single __tmp3283))
(let __tmp3285 (Get __tmp3281 1))
(let __tmp3286 (Single __tmp3285))
(let __tmp3287 (Get __tmp3281 2))
(let __tmp3288 (Single __tmp3287))
(let __tmp3289 (Get __tmp3281 3))
(let __tmp3290 (Single __tmp3289))
(let __tmp3291 (Get __tmp3281 5))
(let __tmp3292 (Single __tmp3291))
(let __tmp3293 (Concat __tmp3290 __tmp3292))
(let __tmp3294 (Concat __tmp3288 __tmp3293))
(let __tmp3295 (Concat __tmp3286 __tmp3294))
(let __tmp3296 (Concat __tmp3284 __tmp3295))
(let __tmp3297 (Call "matrix_loc" __tmp3296))
(let __tmp3298 (Get __tmp3297 0))
(let __tmp3299 (Get __tmp3281 4))
(let __tmp3300 (Get __tmp3297 1))
(let __tmp3301 (Top __tmp1189 __tmp3298 __tmp3299 __tmp3300))
(let __tmp3302 (Single __tmp3301))
(let __tmp3303 (InFunc " loop_ctx_15"))
(let __tmp3304 (Arg __tmp822 __tmp3303))
(let __tmp3305 (Get __tmp3304 1))
(let __tmp3306 (Get __tmp3304 5))
(let __tmp3307 (Get __tmp3304 15))
(let __tmp3308 (Bop __tmp292 __tmp3306 __tmp3307))
(let __tmp3309 (Bop __tmp293 __tmp3305 __tmp3308))
(let __tmp3310 (Single __tmp3309))
(let __tmp3311 (Get __tmp3304 14))
(let __tmp3312 (Single __tmp3311))
(let __tmp3313 (Get __tmp3304 0))
(let __tmp3314 (Single __tmp3313))
(let __tmp3315 (Concat __tmp3312 __tmp3314))
(let __tmp3316 (Concat __tmp3310 __tmp3315))
(let __tmp3317 (Call "fmod" __tmp3316))
(let __tmp3318 (Get __tmp3316 2))
(let __tmp3319 (Single __tmp3318))
(let __tmp3320 (Get __tmp3316 0))
(let __tmp3321 (Single __tmp3320))
(let __tmp3322 (Const __tmp125 __tmp822 __tmp3303))
(let __tmp3323 (Single __tmp3322))
(let __tmp3324 (Const __tmp104 __tmp822 __tmp3303))
(let __tmp3325 (Single __tmp3324))
(let __tmp3326 (Get __tmp3316 1))
(let __tmp3327 (Single __tmp3326))
(let __tmp3328 (Concat __tmp3325 __tmp3327))
(let __tmp3329 (Concat __tmp3323 __tmp3328))
(let __tmp3330 (Concat __tmp3321 __tmp3329))
(let __tmp3331 (Concat __tmp3319 __tmp3330))
(let __tmp3332 (InFunc " loop_ctx_41"))
(let __tmp3333 (Arg __tmp2410 __tmp3332))
(let __tmp3334 (Get __tmp3333 1))
(let __tmp3335 (Get __tmp3333 4))
(let __tmp3336 (Bop __tmp2405 __tmp3334 __tmp3335))
(let __tmp3337 (Single __tmp3336))
(let __tmp3338 (InIf true __tmp3336 __tmp3333))
(let __tmp3339 (Arg __tmp2410 __tmp3338))
(let __tmp3340 (Get __tmp3339 1))
(let __tmp3341 (Get __tmp3339 4))
(let __tmp3342 (Bop __tmp2417 __tmp3340 __tmp3341))
(let __tmp3343 (Get __tmp3339 3))
(let __tmp3344 (Bop __tmp2405 __tmp3342 __tmp3343))
(let __tmp3345 (Get __tmp3339 0))
(let __tmp3346 (Single __tmp3345))
(let __tmp3347 (Single __tmp3340))
(let __tmp3348 (Single __tmp3341))
(let __tmp3349 (Get __tmp3339 2))
(let __tmp3350 (Single __tmp3349))
(let __tmp3351 (Single __tmp3343))
(let __tmp3352 (Concat __tmp3351 __tmp3348))
(let __tmp3353 (Concat __tmp3350 __tmp3352))
(let __tmp3354 (Concat __tmp3348 __tmp3353))
(let __tmp3355 (Concat __tmp3347 __tmp3354))
(let __tmp3356 (Concat __tmp3346 __tmp3355))
(let __tmp3357 (InIf true __tmp3344 __tmp3356))
(let __tmp3358 (Arg __tmp2439 __tmp3357))
(let __tmp3359 (InFunc " loop_ctx_42"))
(let __tmp3360 (Arg __tmp2439 __tmp3359))
(let __tmp3361 (Get __tmp3360 1))
(let __tmp3362 (Get __tmp3360 2))
(let __tmp3363 (Get __tmp3360 3))
(let __tmp3364 (Bop __tmp293 __tmp3362 __tmp3363))
(let __tmp3365 (Bop __tmp2417 __tmp3361 __tmp3364))
(let __tmp3366 (Get __tmp3360 4))
(let __tmp3367 (Bop __tmp2405 __tmp3365 __tmp3366))
(let __tmp3368 (Single __tmp3367))
(let __tmp3369 (Get __tmp3360 0))
(let __tmp3370 (Single __tmp3369))
(let __tmp3371 (Single __tmp3361))
(let __tmp3372 (Single __tmp3364))
(let __tmp3373 (Single __tmp3363))
(let __tmp3374 (Concat __tmp3372 __tmp3373))
(let __tmp3375 (Single __tmp3366))
(let __tmp3376 (Concat __tmp3374 __tmp3375))
(let __tmp3377 (Get __tmp3360 5))
(let __tmp3378 (Single __tmp3377))
(let __tmp3379 (Concat __tmp3376 __tmp3378))
(let __tmp3380 (Concat __tmp3371 __tmp3379))
(let __tmp3381 (Concat __tmp3370 __tmp3380))
(let __tmp3382 (Concat __tmp3368 __tmp3381))
(let __tmp3383 (DoWhile __tmp3358 __tmp3382))
(let __tmp3384 (InIf false __tmp3344 __tmp3356))
(let __tmp3385 (Arg __tmp2439 __tmp3384))
(let __tmp3386 (If __tmp3344 __tmp3356 __tmp3383 __tmp3385))
(let __tmp3387 (Get __tmp3386 0))
(let __tmp3388 (Single __tmp3387))
(let __tmp3389 (Get __tmp3386 1))
(let __tmp3390 (Get __tmp3386 2))
(let __tmp3391 (Get __tmp3386 3))
(let __tmp3392 (Bop __tmp291 __tmp3390 __tmp3391))
(let __tmp3393 (Bop __tmp2417 __tmp3389 __tmp3392))
(let __tmp3394 (Single __tmp3393))
(let __tmp3395 (Single __tmp3391))
(let __tmp3396 (Get __tmp3386 4))
(let __tmp3397 (Single __tmp3396))
(let __tmp3398 (Concat __tmp3395 __tmp3397))
(let __tmp3399 (Get __tmp3386 5))
(let __tmp3400 (Single __tmp3399))
(let __tmp3401 (Concat __tmp3398 __tmp3400))
(let __tmp3402 (Concat __tmp3394 __tmp3401))
(let __tmp3403 (Concat __tmp3388 __tmp3402))
(let __tmp3404 (InIf false __tmp3336 __tmp3333))
(let __tmp3405 (Arg __tmp2410 __tmp3404))
(let __tmp3406 (If __tmp3336 __tmp3333 __tmp3403 __tmp3405))
(let __tmp3407 (Concat __tmp3337 __tmp3406))
(let __tmp3408 (DoWhile __tmp3331 __tmp3407))
(let __tmp3409 (Get __tmp3408 1))
(let __tmp3410 (Single __tmp3409))
(let __tmp3411 (Get __tmp3408 0))
(let __tmp3412 (Single __tmp3411))
(let __tmp3413 (Concat __tmp3410 __tmp3412))
(let __tmp3414 (Get __tmp3304 13))
(let __tmp3415 (Single __tmp3414))
(let __tmp3416 (Get __tmp3304 3))
(let __tmp3417 (Single __tmp3416))
(let __tmp3418 (Get __tmp3304 6))
(let __tmp3419 (Single __tmp3418))
(let __tmp3420 (Get __tmp3304 12))
(let __tmp3421 (Single __tmp3420))
(let __tmp3422 (Get __tmp3317 0))
(let __tmp3423 (Get __tmp3304 9))
(let __tmp3424 (Bop __tmp293 __tmp3423 __tmp3311))
(let __tmp3425 (Bop __tmp291 __tmp3422 __tmp3424))
(let __tmp3426 (Single __tmp3425))
(let __tmp3427 (Get __tmp3317 1))
(let __tmp3428 (Single __tmp3427))
(let __tmp3429 (Concat __tmp3426 __tmp3428))
(let __tmp3430 (Concat __tmp3421 __tmp3429))
(let __tmp3431 (Concat __tmp3419 __tmp3430))
(let __tmp3432 (Concat __tmp3417 __tmp3431))
(let __tmp3433 (Concat __tmp3415 __tmp3432))
(let __tmp3434 (Call "matrix_set" __tmp3433))
(let __tmp3435 (Get __tmp3433 0))
(let __tmp3436 (Single __tmp3435))
(let __tmp3437 (Get __tmp3433 1))
(let __tmp3438 (Single __tmp3437))
(let __tmp3439 (Get __tmp3433 2))
(let __tmp3440 (Single __tmp3439))
(let __tmp3441 (Get __tmp3433 3))
(let __tmp3442 (Single __tmp3441))
(let __tmp3443 (Get __tmp3433 5))
(let __tmp3444 (Single __tmp3443))
(let __tmp3445 (Concat __tmp3442 __tmp3444))
(let __tmp3446 (Concat __tmp3440 __tmp3445))
(let __tmp3447 (Concat __tmp3438 __tmp3446))
(let __tmp3448 (Concat __tmp3436 __tmp3447))
(let __tmp3449 (Call "matrix_loc" __tmp3448))
(let __tmp3450 (Get __tmp3449 0))
(let __tmp3451 (Get __tmp3433 4))
(let __tmp3452 (Get __tmp3449 1))
(let __tmp3453 (Top __tmp1189 __tmp3450 __tmp3451 __tmp3452))
(let __tmp3454 (Single __tmp3453))
(let __tmp3455 (InFunc " loop_ctx_16"))
(let __tmp3456 (Arg __tmp1033 __tmp3455))
(let __tmp3457 (Get __tmp3456 1))
(let __tmp3458 (Get __tmp3456 5))
(let __tmp3459 (Get __tmp3456 11))
(let __tmp3460 (Bop __tmp292 __tmp3458 __tmp3459))
(let __tmp3461 (Bop __tmp293 __tmp3457 __tmp3460))
(let __tmp3462 (Bop __tmp292 __tmp3461 __tmp3459))
(let __tmp3463 (Single __tmp3462))
(let __tmp3464 (Get __tmp3456 10))
(let __tmp3465 (Single __tmp3464))
(let __tmp3466 (Get __tmp3456 0))
(let __tmp3467 (Single __tmp3466))
(let __tmp3468 (Concat __tmp3465 __tmp3467))
(let __tmp3469 (Concat __tmp3463 __tmp3468))
(let __tmp3470 (Call "fmod" __tmp3469))
(let __tmp3471 (Get __tmp3469 2))
(let __tmp3472 (Single __tmp3471))
(let __tmp3473 (Get __tmp3469 0))
(let __tmp3474 (Single __tmp3473))
(let __tmp3475 (Const __tmp125 __tmp1033 __tmp3455))
(let __tmp3476 (Single __tmp3475))
(let __tmp3477 (Const __tmp104 __tmp1033 __tmp3455))
(let __tmp3478 (Single __tmp3477))
(let __tmp3479 (Get __tmp3469 1))
(let __tmp3480 (Single __tmp3479))
(let __tmp3481 (Concat __tmp3478 __tmp3480))
(let __tmp3482 (Concat __tmp3476 __tmp3481))
(let __tmp3483 (Concat __tmp3474 __tmp3482))
(let __tmp3484 (Concat __tmp3472 __tmp3483))
(let __tmp3485 (InFunc " loop_ctx_43"))
(let __tmp3486 (Arg __tmp2410 __tmp3485))
(let __tmp3487 (Get __tmp3486 1))
(let __tmp3488 (Get __tmp3486 4))
(let __tmp3489 (Bop __tmp2405 __tmp3487 __tmp3488))
(let __tmp3490 (Single __tmp3489))
(let __tmp3491 (InIf true __tmp3489 __tmp3486))
(let __tmp3492 (Arg __tmp2410 __tmp3491))
(let __tmp3493 (Get __tmp3492 1))
(let __tmp3494 (Get __tmp3492 4))
(let __tmp3495 (Bop __tmp2417 __tmp3493 __tmp3494))
(let __tmp3496 (Get __tmp3492 3))
(let __tmp3497 (Bop __tmp2405 __tmp3495 __tmp3496))
(let __tmp3498 (Get __tmp3492 0))
(let __tmp3499 (Single __tmp3498))
(let __tmp3500 (Single __tmp3493))
(let __tmp3501 (Single __tmp3494))
(let __tmp3502 (Get __tmp3492 2))
(let __tmp3503 (Single __tmp3502))
(let __tmp3504 (Single __tmp3496))
(let __tmp3505 (Concat __tmp3504 __tmp3501))
(let __tmp3506 (Concat __tmp3503 __tmp3505))
(let __tmp3507 (Concat __tmp3501 __tmp3506))
(let __tmp3508 (Concat __tmp3500 __tmp3507))
(let __tmp3509 (Concat __tmp3499 __tmp3508))
(let __tmp3510 (InIf true __tmp3497 __tmp3509))
(let __tmp3511 (Arg __tmp2439 __tmp3510))
(let __tmp3512 (InFunc " loop_ctx_44"))
(let __tmp3513 (Arg __tmp2439 __tmp3512))
(let __tmp3514 (Get __tmp3513 1))
(let __tmp3515 (Get __tmp3513 2))
(let __tmp3516 (Get __tmp3513 3))
(let __tmp3517 (Bop __tmp293 __tmp3515 __tmp3516))
(let __tmp3518 (Bop __tmp2417 __tmp3514 __tmp3517))
(let __tmp3519 (Get __tmp3513 4))
(let __tmp3520 (Bop __tmp2405 __tmp3518 __tmp3519))
(let __tmp3521 (Single __tmp3520))
(let __tmp3522 (Get __tmp3513 0))
(let __tmp3523 (Single __tmp3522))
(let __tmp3524 (Single __tmp3514))
(let __tmp3525 (Single __tmp3517))
(let __tmp3526 (Single __tmp3516))
(let __tmp3527 (Concat __tmp3525 __tmp3526))
(let __tmp3528 (Single __tmp3519))
(let __tmp3529 (Concat __tmp3527 __tmp3528))
(let __tmp3530 (Get __tmp3513 5))
(let __tmp3531 (Single __tmp3530))
(let __tmp3532 (Concat __tmp3529 __tmp3531))
(let __tmp3533 (Concat __tmp3524 __tmp3532))
(let __tmp3534 (Concat __tmp3523 __tmp3533))
(let __tmp3535 (Concat __tmp3521 __tmp3534))
(let __tmp3536 (DoWhile __tmp3511 __tmp3535))
(let __tmp3537 (InIf false __tmp3497 __tmp3509))
(let __tmp3538 (Arg __tmp2439 __tmp3537))
(let __tmp3539 (If __tmp3497 __tmp3509 __tmp3536 __tmp3538))
(let __tmp3540 (Get __tmp3539 0))
(let __tmp3541 (Single __tmp3540))
(let __tmp3542 (Get __tmp3539 1))
(let __tmp3543 (Get __tmp3539 2))
(let __tmp3544 (Get __tmp3539 3))
(let __tmp3545 (Bop __tmp291 __tmp3543 __tmp3544))
(let __tmp3546 (Bop __tmp2417 __tmp3542 __tmp3545))
(let __tmp3547 (Single __tmp3546))
(let __tmp3548 (Single __tmp3544))
(let __tmp3549 (Get __tmp3539 4))
(let __tmp3550 (Single __tmp3549))
(let __tmp3551 (Concat __tmp3548 __tmp3550))
(let __tmp3552 (Get __tmp3539 5))
(let __tmp3553 (Single __tmp3552))
(let __tmp3554 (Concat __tmp3551 __tmp3553))
(let __tmp3555 (Concat __tmp3547 __tmp3554))
(let __tmp3556 (Concat __tmp3541 __tmp3555))
(let __tmp3557 (InIf false __tmp3489 __tmp3486))
(let __tmp3558 (Arg __tmp2410 __tmp3557))
(let __tmp3559 (If __tmp3489 __tmp3486 __tmp3556 __tmp3558))
(let __tmp3560 (Concat __tmp3490 __tmp3559))
(let __tmp3561 (DoWhile __tmp3484 __tmp3560))
(let __tmp3562 (Get __tmp3561 1))
(let __tmp3563 (Single __tmp3562))
(let __tmp3564 (Get __tmp3561 0))
(let __tmp3565 (Single __tmp3564))
(let __tmp3566 (Concat __tmp3563 __tmp3565))
(let __tmp3567 (Get __tmp3456 7))
(let __tmp3568 (Single __tmp3567))
(let __tmp3569 (Get __tmp3456 3))
(let __tmp3570 (Single __tmp3569))
(let __tmp3571 (Get __tmp3456 6))
(let __tmp3572 (Single __tmp3571))
(let __tmp3573 (Get __tmp3456 8))
(let __tmp3574 (Single __tmp3573))
(let __tmp3575 (Get __tmp3470 0))
(let __tmp3576 (Get __tmp3456 9))
(let __tmp3577 (Bop __tmp293 __tmp3576 __tmp3464))
(let __tmp3578 (Bop __tmp291 __tmp3575 __tmp3577))
(let __tmp3579 (Single __tmp3578))
(let __tmp3580 (Get __tmp3470 1))
(let __tmp3581 (Single __tmp3580))
(let __tmp3582 (Concat __tmp3579 __tmp3581))
(let __tmp3583 (Concat __tmp3574 __tmp3582))
(let __tmp3584 (Concat __tmp3572 __tmp3583))
(let __tmp3585 (Concat __tmp3570 __tmp3584))
(let __tmp3586 (Concat __tmp3568 __tmp3585))
(let __tmp3587 (Call "matrix_set" __tmp3586))
(let __tmp3588 (Get __tmp3586 0))
(let __tmp3589 (Single __tmp3588))
(let __tmp3590 (Get __tmp3586 1))
(let __tmp3591 (Single __tmp3590))
(let __tmp3592 (Get __tmp3586 2))
(let __tmp3593 (Single __tmp3592))
(let __tmp3594 (Get __tmp3586 3))
(let __tmp3595 (Single __tmp3594))
(let __tmp3596 (Get __tmp3586 5))
(let __tmp3597 (Single __tmp3596))
(let __tmp3598 (Concat __tmp3595 __tmp3597))
(let __tmp3599 (Concat __tmp3593 __tmp3598))
(let __tmp3600 (Concat __tmp3591 __tmp3599))
(let __tmp3601 (Concat __tmp3589 __tmp3600))
(let __tmp3602 (Call "matrix_loc" __tmp3601))
(let __tmp3603 (Get __tmp3602 0))
(let __tmp3604 (Get __tmp3586 4))
(let __tmp3605 (Get __tmp3602 1))
(let __tmp3606 (Top __tmp1189 __tmp3603 __tmp3604 __tmp3605))
(let __tmp3607 (Single __tmp3606))
(let __tmp3608 (Get __tmp3142 0))
(let __tmp3609 (Get __tmp3142 2))
(let __tmp3610 (Get __tmp3142 3))
(let __tmp3611 (Get __tmp3142 1))
(let __tmp3612 (Bop __tmp15 __tmp3610 __tmp3611))
(let __tmp3613 (Bop __tmp326 __tmp3609 __tmp3612))
(let __tmp3614 (Bop __tmp2361 __tmp3608 __tmp3613))
(let __tmp3615 (Single __tmp3614))
(let __tmp3616 (Get __tmp3142 4))
(let __tmp3617 (Single __tmp3616))
(let __tmp3618 (Concat __tmp3615 __tmp3617))
(let __tmp3619 (Get __tmp3296 0))
(let __tmp3620 (Get __tmp3296 2))
(let __tmp3621 (Get __tmp3296 3))
(let __tmp3622 (Get __tmp3296 1))
(let __tmp3623 (Bop __tmp15 __tmp3621 __tmp3622))
(let __tmp3624 (Bop __tmp326 __tmp3620 __tmp3623))
(let __tmp3625 (Bop __tmp2361 __tmp3619 __tmp3624))
(let __tmp3626 (Single __tmp3625))
(let __tmp3627 (Get __tmp3296 4))
(let __tmp3628 (Single __tmp3627))
(let __tmp3629 (Concat __tmp3626 __tmp3628))
(let __tmp3630 (Get __tmp3448 0))
(let __tmp3631 (Get __tmp3448 2))
(let __tmp3632 (Get __tmp3448 3))
(let __tmp3633 (Get __tmp3448 1))
(let __tmp3634 (Bop __tmp15 __tmp3632 __tmp3633))
(let __tmp3635 (Bop __tmp326 __tmp3631 __tmp3634))
(let __tmp3636 (Bop __tmp2361 __tmp3630 __tmp3635))
(let __tmp3637 (Single __tmp3636))
(let __tmp3638 (Get __tmp3448 4))
(let __tmp3639 (Single __tmp3638))
(let __tmp3640 (Concat __tmp3637 __tmp3639))
(let __tmp3641 (Get __tmp3601 0))
(let __tmp3642 (Get __tmp3601 2))
(let __tmp3643 (Get __tmp3601 3))
(let __tmp3644 (Get __tmp3601 1))
(let __tmp3645 (Bop __tmp15 __tmp3643 __tmp3644))
(let __tmp3646 (Bop __tmp326 __tmp3642 __tmp3645))
(let __tmp3647 (Bop __tmp2361 __tmp3641 __tmp3646))
(let __tmp3648 (Single __tmp3647))
(let __tmp3649 (Get __tmp3601 4))
(let __tmp3650 (Single __tmp3649))
(let __tmp3651 (Concat __tmp3648 __tmp3650))
(let __tmp3652 (TCons __tmp172 __tmp3))
(let __tmp3653 (TCons __tmp172 __tmp3652))
(let __tmp3654 (TCons __tmp172 __tmp3653))
(let __tmp3655 (TCons __tmp21 __tmp3654))
(let __tmp3656 (TupleT __tmp3655))
(let __tmp3657 (InFunc "matrix_get"))
(let __tmp3658 (Arg __tmp3656 __tmp3657))
(let __tmp3659 (Call "matrix_loc" __tmp3658))
(let __tmp3660 (Get __tmp3658 0))
(let __tmp3661 (Get __tmp3658 2))
(let __tmp3662 (Get __tmp3658 3))
(let __tmp3663 (Get __tmp3658 1))
(let __tmp3664 (Bop __tmp15 __tmp3662 __tmp3663))
(let __tmp3665 (Bop __tmp326 __tmp3661 __tmp3664))
(let __tmp3666 (Bop __tmp2361 __tmp3660 __tmp3665))
(let __tmp3667 (Single __tmp3666))
(let __tmp3668 (Get __tmp3658 4))
(let __tmp3669 (Single __tmp3668))
(let __tmp3670 (Concat __tmp3667 __tmp3669))
(let __tmp3671 (TCons __tmp20 __tmp3))
(let __tmp3672 (TCons __tmp172 __tmp3671))
(let __tmp3673 (TCons __tmp172 __tmp3672))
(let __tmp3674 (TCons __tmp172 __tmp3673))
(let __tmp3675 (TCons __tmp21 __tmp3674))
(let __tmp3676 (TupleT __tmp3675))
(let __tmp3677 (InFunc "matrix_set"))
(let __tmp3678 (Arg __tmp3676 __tmp3677))
(let __tmp3679 (Get __tmp3678 0))
(let __tmp3680 (Single __tmp3679))
(let __tmp3681 (Get __tmp3678 1))
(let __tmp3682 (Single __tmp3681))
(let __tmp3683 (Get __tmp3678 2))
(let __tmp3684 (Single __tmp3683))
(let __tmp3685 (Get __tmp3678 3))
(let __tmp3686 (Single __tmp3685))
(let __tmp3687 (Get __tmp3678 5))
(let __tmp3688 (Single __tmp3687))
(let __tmp3689 (Concat __tmp3686 __tmp3688))
(let __tmp3690 (Concat __tmp3684 __tmp3689))
(let __tmp3691 (Concat __tmp3682 __tmp3690))
(let __tmp3692 (Concat __tmp3680 __tmp3691))
(let __tmp3693 (Call "matrix_loc" __tmp3692))
(let __tmp3694 (Get __tmp3692 0))
(let __tmp3695 (Get __tmp3692 2))
(let __tmp3696 (Get __tmp3692 3))
(let __tmp3697 (Get __tmp3692 1))
(let __tmp3698 (Bop __tmp15 __tmp3696 __tmp3697))
(let __tmp3699 (Bop __tmp326 __tmp3695 __tmp3698))
(let __tmp3700 (Bop __tmp2361 __tmp3694 __tmp3699))
(let __tmp3701 (Single __tmp3700))
(let __tmp3702 (Get __tmp3692 4))
(let __tmp3703 (Single __tmp3702))
(let __tmp3704 (Concat __tmp3701 __tmp3703))
(let __tmp3705 (InFunc "matrix_incr"))
(let __tmp3706 (Arg __tmp3676 __tmp3705))
(let __tmp3707 (Get __tmp3706 0))
(let __tmp3708 (Single __tmp3707))
(let __tmp3709 (Get __tmp3706 1))
(let __tmp3710 (Single __tmp3709))
(let __tmp3711 (Get __tmp3706 2))
(let __tmp3712 (Single __tmp3711))
(let __tmp3713 (Get __tmp3706 3))
(let __tmp3714 (Single __tmp3713))
(let __tmp3715 (Get __tmp3706 5))
(let __tmp3716 (Single __tmp3715))
(let __tmp3717 (Concat __tmp3714 __tmp3716))
(let __tmp3718 (Concat __tmp3712 __tmp3717))
(let __tmp3719 (Concat __tmp3710 __tmp3718))
(let __tmp3720 (Concat __tmp3708 __tmp3719))
(let __tmp3721 (Call "matrix_loc" __tmp3720))
(let __tmp3722 (Get __tmp3720 0))
(let __tmp3723 (Get __tmp3720 2))
(let __tmp3724 (Get __tmp3720 3))
(let __tmp3725 (Get __tmp3720 1))
(let __tmp3726 (Bop __tmp15 __tmp3724 __tmp3725))
(let __tmp3727 (Bop __tmp326 __tmp3723 __tmp3726))
(let __tmp3728 (Bop __tmp2361 __tmp3722 __tmp3727))
(let __tmp3729 (Single __tmp3728))
(let __tmp3730 (Get __tmp3720 4))
(let __tmp3731 (Single __tmp3730))
(let __tmp3732 (Concat __tmp3729 __tmp3731))
(let __tmp3733 (Print ))
(let __tmp3734 (Get __tmp2330 0))
(let __tmp3735 (Free ))
(let __tmp3736 (Get __tmp2322 2))
(let __tmp3737 (Get __tmp2322 3))
(let __tmp3738 (Get __tmp2322 4))
(let __tmp3739 (Get __tmp2322 5))
(let __tmp3740 (Get __tmp2322 6))
(let __tmp3741 (Get __tmp2322 7))
(let __tmp3742 (Get __tmp2330 1))
(let __tmp3743 (Bop __tmp3735 __tmp3741 __tmp3742))
(let __tmp3744 (Bop __tmp3735 __tmp3740 __tmp3743))
(let __tmp3745 (Bop __tmp3735 __tmp3739 __tmp3744))
(let __tmp3746 (Bop __tmp3735 __tmp3738 __tmp3745))
(let __tmp3747 (Bop __tmp3735 __tmp3737 __tmp3746))
(let __tmp3748 (Bop __tmp3735 __tmp3736 __tmp3747))
(let __tmp3749 (Bop __tmp3735 __tmp2323 __tmp3748))
(let __tmp3750 (Bop __tmp3733 __tmp3734 __tmp3749))
(let __tmp3751 (Single __tmp3750))
(let __tmp3752 (Function "main" __tmp4 __tmp4 __tmp3751))
(let __tmp3753 (TCons __tmp20 __tmp3672))
(let __tmp3754 (TCons __tmp172 __tmp3753))
(let __tmp3755 (TCons __tmp20 __tmp3754))
(let __tmp3756 (TCons __tmp172 __tmp3755))
(let __tmp3757 (TCons __tmp20 __tmp3756))
(let __tmp3758 (TCons __tmp172 __tmp3757))
(let __tmp3759 (TCons __tmp20 __tmp3758))
(let __tmp3760 (TCons __tmp172 __tmp3759))
(let __tmp3761 (TCons __tmp21 __tmp3760))
(let __tmp3762 (TCons __tmp21 __tmp3761))
(let __tmp3763 (TCons __tmp21 __tmp3762))
(let __tmp3764 (TCons __tmp21 __tmp3763))
(let __tmp3765 (TupleT __tmp3764))
(let __tmp3766 (InFunc "init"))
(let __tmp3767 (Arg __tmp3765 __tmp3766))
(let __tmp3768 (Get __tmp3767 14))
(let __tmp3769 (Single __tmp3768))
(let __tmp3770 (Const __tmp104 __tmp3765 __tmp3766))
(let __tmp3771 (Single __tmp3770))
(let __tmp3772 (Const __tmp107 __tmp3765 __tmp3766))
(let __tmp3773 (Single __tmp3772))
(let __tmp3774 (Const __tmp110 __tmp3765 __tmp3766))
(let __tmp3775 (Single __tmp3774))
(let __tmp3776 (Const __tmp113 __tmp3765 __tmp3766))
(let __tmp3777 (Single __tmp3776))
(let __tmp3778 (Get __tmp3767 3))
(let __tmp3779 (Single __tmp3778))
(let __tmp3780 (Get __tmp3767 10))
(let __tmp3781 (Single __tmp3780))
(let __tmp3782 (Const __tmp120 __tmp3765 __tmp3766))
(let __tmp3783 (Single __tmp3782))
(let __tmp3784 (Get __tmp3767 9))
(let __tmp3785 (Single __tmp3784))
(let __tmp3786 (Const __tmp125 __tmp3765 __tmp3766))
(let __tmp3787 (Single __tmp3786))
(let __tmp3788 (Get __tmp3767 12))
(let __tmp3789 (Single __tmp3788))
(let __tmp3790 (Get __tmp3767 2))
(let __tmp3791 (Single __tmp3790))
(let __tmp3792 (Get __tmp3767 11))
(let __tmp3793 (Single __tmp3792))
(let __tmp3794 (Const __tmp134 __tmp3765 __tmp3766))
(let __tmp3795 (Single __tmp3794))
(let __tmp3796 (Get __tmp3767 6))
(let __tmp3797 (Single __tmp3796))
(let __tmp3798 (Get __tmp3767 1))
(let __tmp3799 (Single __tmp3798))
(let __tmp3800 (Get __tmp3767 7))
(let __tmp3801 (Single __tmp3800))
(let __tmp3802 (Get __tmp3767 8))
(let __tmp3803 (Single __tmp3802))
(let __tmp3804 (Get __tmp3767 0))
(let __tmp3805 (Single __tmp3804))
(let __tmp3806 (Get __tmp3767 5))
(let __tmp3807 (Single __tmp3806))
(let __tmp3808 (Get __tmp3767 4))
(let __tmp3809 (Single __tmp3808))
(let __tmp3810 (Concat __tmp3807 __tmp3809))
(let __tmp3811 (Concat __tmp3805 __tmp3810))
(let __tmp3812 (Concat __tmp3803 __tmp3811))
(let __tmp3813 (Concat __tmp3801 __tmp3812))
(let __tmp3814 (Concat __tmp3799 __tmp3813))
(let __tmp3815 (Concat __tmp3797 __tmp3814))
(let __tmp3816 (Concat __tmp3795 __tmp3815))
(let __tmp3817 (Concat __tmp3793 __tmp3816))
(let __tmp3818 (Concat __tmp3791 __tmp3817))
(let __tmp3819 (Concat __tmp3789 __tmp3818))
(let __tmp3820 (Concat __tmp3787 __tmp3819))
(let __tmp3821 (Concat __tmp3785 __tmp3820))
(let __tmp3822 (Concat __tmp3783 __tmp3821))
(let __tmp3823 (Concat __tmp3781 __tmp3822))
(let __tmp3824 (Concat __tmp3779 __tmp3823))
(let __tmp3825 (Concat __tmp3777 __tmp3824))
(let __tmp3826 (Concat __tmp3775 __tmp3825))
(let __tmp3827 (Concat __tmp3773 __tmp3826))
(let __tmp3828 (Concat __tmp3771 __tmp3827))
(let __tmp3829 (Concat __tmp3769 __tmp3828))
(let __tmp3830 (InFunc " loop_ctx_12"))
(let __tmp3831 (Arg __tmp194 __tmp3830))
(let __tmp3832 (Get __tmp3831 3))
(let __tmp3833 (Get __tmp3831 20))
(let __tmp3834 (Bop __tmp171 __tmp3832 __tmp3833))
(let __tmp3835 (Single __tmp3834))
(let __tmp3836 (InIf true __tmp3834 __tmp3831))
(let __tmp3837 (Const __tmp110 __tmp194 __tmp3836))
(let __tmp3838 (Arg __tmp194 __tmp3836))
(let __tmp3839 (Get __tmp3838 17))
(let __tmp3840 (Bop __tmp171 __tmp3837 __tmp3839))
(let __tmp3841 (Get __tmp3838 0))
(let __tmp3842 (Single __tmp3841))
(let __tmp3843 (Get __tmp3838 1))
(let __tmp3844 (Single __tmp3843))
(let __tmp3845 (Get __tmp3838 2))
(let __tmp3846 (Single __tmp3845))
(let __tmp3847 (Get __tmp3838 3))
(let __tmp3848 (Single __tmp3847))
(let __tmp3849 (Get __tmp3838 4))
(let __tmp3850 (Single __tmp3849))
(let __tmp3851 (Const __tmp104 __tmp194 __tmp3836))
(let __tmp3852 (Single __tmp3851))
(let __tmp3853 (Single __tmp3837))
(let __tmp3854 (Get __tmp3838 5))
(let __tmp3855 (Single __tmp3854))
(let __tmp3856 (Get __tmp3838 6))
(let __tmp3857 (Single __tmp3856))
(let __tmp3858 (Get __tmp3838 7))
(let __tmp3859 (Single __tmp3858))
(let __tmp3860 (Get __tmp3838 8))
(let __tmp3861 (Single __tmp3860))
(let __tmp3862 (Get __tmp3838 9))
(let __tmp3863 (Single __tmp3862))
(let __tmp3864 (Get __tmp3838 10))
(let __tmp3865 (Single __tmp3864))
(let __tmp3866 (Get __tmp3838 11))
(let __tmp3867 (Single __tmp3866))
(let __tmp3868 (Get __tmp3838 12))
(let __tmp3869 (Single __tmp3868))
(let __tmp3870 (Get __tmp3838 13))
(let __tmp3871 (Single __tmp3870))
(let __tmp3872 (Get __tmp3838 14))
(let __tmp3873 (Single __tmp3872))
(let __tmp3874 (Get __tmp3838 15))
(let __tmp3875 (Single __tmp3874))
(let __tmp3876 (Get __tmp3838 16))
(let __tmp3877 (Single __tmp3876))
(let __tmp3878 (Single __tmp3839))
(let __tmp3879 (Get __tmp3838 18))
(let __tmp3880 (Single __tmp3879))
(let __tmp3881 (Get __tmp3838 19))
(let __tmp3882 (Single __tmp3881))
(let __tmp3883 (Get __tmp3838 20))
(let __tmp3884 (Single __tmp3883))
(let __tmp3885 (Concat __tmp3882 __tmp3884))
(let __tmp3886 (Concat __tmp3880 __tmp3885))
(let __tmp3887 (Concat __tmp3878 __tmp3886))
(let __tmp3888 (Concat __tmp3877 __tmp3887))
(let __tmp3889 (Concat __tmp3875 __tmp3888))
(let __tmp3890 (Concat __tmp3873 __tmp3889))
(let __tmp3891 (Concat __tmp3871 __tmp3890))
(let __tmp3892 (Concat __tmp3869 __tmp3891))
(let __tmp3893 (Concat __tmp3867 __tmp3892))
(let __tmp3894 (Concat __tmp3865 __tmp3893))
(let __tmp3895 (Concat __tmp3863 __tmp3894))
(let __tmp3896 (Concat __tmp3861 __tmp3895))
(let __tmp3897 (Concat __tmp3859 __tmp3896))
(let __tmp3898 (Concat __tmp3857 __tmp3897))
(let __tmp3899 (Concat __tmp3855 __tmp3898))
(let __tmp3900 (Concat __tmp3853 __tmp3899))
(let __tmp3901 (Concat __tmp3852 __tmp3900))
(let __tmp3902 (Concat __tmp3850 __tmp3901))
(let __tmp3903 (Concat __tmp3848 __tmp3902))
(let __tmp3904 (Concat __tmp3846 __tmp3903))
(let __tmp3905 (Concat __tmp3844 __tmp3904))
(let __tmp3906 (Concat __tmp3842 __tmp3905))
(let __tmp3907 (InIf true __tmp3840 __tmp3906))
(let __tmp3908 (Arg __tmp278 __tmp3907))
(let __tmp3909 (Single __tmp2999))
(let __tmp3910 (Single __tmp3002))
(let __tmp3911 (Get __tmp2998 4))
(let __tmp3912 (Single __tmp3911))
(let __tmp3913 (Bop __tmp292 __tmp3000 __tmp3002))
(let __tmp3914 (Single __tmp3913))
(let __tmp3915 (Bop __tmp326 __tmp3911 __tmp3112))
(let __tmp3916 (Single __tmp3915))
(let __tmp3917 (Get __tmp2998 7))
(let __tmp3918 (Single __tmp3917))
(let __tmp3919 (Get __tmp2998 8))
(let __tmp3920 (Single __tmp3919))
(let __tmp3921 (Single __tmp3117))
(let __tmp3922 (Get __tmp2998 10))
(let __tmp3923 (Single __tmp3922))
(let __tmp3924 (Get __tmp2998 11))
(let __tmp3925 (Single __tmp3924))
(let __tmp3926 (Get __tmp2998 12))
(let __tmp3927 (Single __tmp3926))
(let __tmp3928 (Get __tmp2998 13))
(let __tmp3929 (Single __tmp3928))
(let __tmp3930 (Get __tmp2998 14))
(let __tmp3931 (Single __tmp3930))
(let __tmp3932 (Get __tmp2998 15))
(let __tmp3933 (Single __tmp3932))
(let __tmp3934 (Get __tmp2998 16))
(let __tmp3935 (Single __tmp3934))
(let __tmp3936 (Get __tmp2998 17))
(let __tmp3937 (Single __tmp3936))
(let __tmp3938 (Get __tmp2998 18))
(let __tmp3939 (Single __tmp3938))
(let __tmp3940 (Concat __tmp3939 __tmp3115))
(let __tmp3941 (Concat __tmp3937 __tmp3940))
(let __tmp3942 (Concat __tmp3935 __tmp3941))
(let __tmp3943 (Concat __tmp3933 __tmp3942))
(let __tmp3944 (Concat __tmp3931 __tmp3943))
(let __tmp3945 (Concat __tmp3929 __tmp3944))
(let __tmp3946 (Concat __tmp3927 __tmp3945))
(let __tmp3947 (Concat __tmp3925 __tmp3946))
(let __tmp3948 (Concat __tmp3923 __tmp3947))
(let __tmp3949 (Concat __tmp3921 __tmp3948))
(let __tmp3950 (Concat __tmp3920 __tmp3949))
(let __tmp3951 (Get __tmp2998 22))
(let __tmp3952 (Single __tmp3951))
(let __tmp3953 (Concat __tmp3006 __tmp3952))
(let __tmp3954 (Concat __tmp3109 __tmp3953))
(let __tmp3955 (Concat __tmp3950 __tmp3954))
(let __tmp3956 (Concat __tmp3918 __tmp3955))
(let __tmp3957 (Concat __tmp3916 __tmp3956))
(let __tmp3958 (Concat __tmp3914 __tmp3957))
(let __tmp3959 (Concat __tmp3912 __tmp3958))
(let __tmp3960 (Concat __tmp3111 __tmp3959))
(let __tmp3961 (Concat __tmp3910 __tmp3960))
(let __tmp3962 (Concat __tmp3909 __tmp3961))
(let __tmp3963 (Concat __tmp3128 __tmp3962))
(let __tmp3964 (Get __tmp3963 6))
(let __tmp3965 (Get __tmp3963 19))
(let __tmp3966 (Bop __tmp171 __tmp3964 __tmp3965))
(let __tmp3967 (Single __tmp3966))
(let __tmp3968 (Concat __tmp3967 __tmp3963))
(let __tmp3969 (DoWhile __tmp3908 __tmp3968))
(let __tmp3970 (InIf false __tmp3840 __tmp3906))
(let __tmp3971 (Arg __tmp278 __tmp3970))
(let __tmp3972 (If __tmp3840 __tmp3906 __tmp3969 __tmp3971))
(let __tmp3973 (Get __tmp3972 0))
(let __tmp3974 (Single __tmp3973))
(let __tmp3975 (Get __tmp3972 1))
(let __tmp3976 (Get __tmp3972 2))
(let __tmp3977 (Bop __tmp292 __tmp3975 __tmp3976))
(let __tmp3978 (Single __tmp3977))
(let __tmp3979 (Single __tmp3976))
(let __tmp3980 (Bop __tmp326 __tmp3849 __tmp3847))
(let __tmp3981 (Single __tmp3980))
(let __tmp3982 (Get __tmp3972 7))
(let __tmp3983 (Single __tmp3982))
(let __tmp3984 (Get __tmp3972 9))
(let __tmp3985 (Single __tmp3984))
(let __tmp3986 (Get __tmp3972 10))
(let __tmp3987 (Single __tmp3986))
(let __tmp3988 (Get __tmp3972 11))
(let __tmp3989 (Single __tmp3988))
(let __tmp3990 (Get __tmp3972 13))
(let __tmp3991 (Single __tmp3990))
(let __tmp3992 (Get __tmp3972 14))
(let __tmp3993 (Single __tmp3992))
(let __tmp3994 (Get __tmp3972 15))
(let __tmp3995 (Single __tmp3994))
(let __tmp3996 (Get __tmp3972 17))
(let __tmp3997 (Single __tmp3996))
(let __tmp3998 (Get __tmp3972 18))
(let __tmp3999 (Single __tmp3998))
(let __tmp4000 (Concat __tmp3999 __tmp3878))
(let __tmp4001 (Concat __tmp3997 __tmp4000))
(let __tmp4002 (Concat __tmp3873 __tmp4001))
(let __tmp4003 (Concat __tmp3995 __tmp4002))
(let __tmp4004 (Concat __tmp3993 __tmp4003))
(let __tmp4005 (Concat __tmp3991 __tmp4004))
(let __tmp4006 (Concat __tmp3865 __tmp4005))
(let __tmp4007 (Concat __tmp3989 __tmp4006))
(let __tmp4008 (Concat __tmp3987 __tmp4007))
(let __tmp4009 (Concat __tmp3985 __tmp4008))
(let __tmp4010 (Concat __tmp3857 __tmp4009))
(let __tmp4011 (Concat __tmp3983 __tmp4010))
(let __tmp4012 (Concat __tmp3850 __tmp4011))
(let __tmp4013 (Concat __tmp3981 __tmp4012))
(let __tmp4014 (Concat __tmp3979 __tmp4013))
(let __tmp4015 (Concat __tmp3978 __tmp4014))
(let __tmp4016 (Concat __tmp3974 __tmp4015))
(let __tmp4017 (Get __tmp3972 20))
(let __tmp4018 (Single __tmp4017))
(let __tmp4019 (Get __tmp3972 21))
(let __tmp4020 (Single __tmp4019))
(let __tmp4021 (Concat __tmp4020 __tmp3884))
(let __tmp4022 (Concat __tmp4018 __tmp4021))
(let __tmp4023 (Concat __tmp4016 __tmp4022))
(let __tmp4024 (InIf false __tmp3834 __tmp3831))
(let __tmp4025 (Arg __tmp194 __tmp4024))
(let __tmp4026 (If __tmp3834 __tmp3831 __tmp4023 __tmp4025))
(let __tmp4027 (Concat __tmp3835 __tmp4026))
(let __tmp4028 (DoWhile __tmp3829 __tmp4027))
(let __tmp4029 (Get __tmp4028 0))
(let __tmp4030 (Single __tmp4029))
(let __tmp4031 (Get __tmp4028 2))
(let __tmp4032 (Single __tmp4031))
(let __tmp4033 (Get __tmp4028 5))
(let __tmp4034 (Single __tmp4033))
(let __tmp4035 (Get __tmp4028 7))
(let __tmp4036 (Single __tmp4035))
(let __tmp4037 (Get __tmp4028 8))
(let __tmp4038 (Single __tmp4037))
(let __tmp4039 (Get __tmp4028 9))
(let __tmp4040 (Single __tmp4039))
(let __tmp4041 (Get __tmp4028 11))
(let __tmp4042 (Single __tmp4041))
(let __tmp4043 (Get __tmp4028 12))
(let __tmp4044 (Single __tmp4043))
(let __tmp4045 (Get __tmp4028 13))
(let __tmp4046 (Single __tmp4045))
(let __tmp4047 (Get __tmp4028 15))
(let __tmp4048 (Single __tmp4047))
(let __tmp4049 (Get __tmp4028 16))
(let __tmp4050 (Single __tmp4049))
(let __tmp4051 (Concat __tmp4050 __tmp3803))
(let __tmp4052 (Concat __tmp4048 __tmp4051))
(let __tmp4053 (Concat __tmp3797 __tmp4052))
(let __tmp4054 (Concat __tmp4046 __tmp4053))
(let __tmp4055 (Concat __tmp4044 __tmp4054))
(let __tmp4056 (Concat __tmp4042 __tmp4055))
(let __tmp4057 (Concat __tmp3789 __tmp4056))
(let __tmp4058 (Concat __tmp4040 __tmp4057))
(let __tmp4059 (Concat __tmp4038 __tmp4058))
(let __tmp4060 (Concat __tmp4036 __tmp4059))
(let __tmp4061 (Concat __tmp3781 __tmp4060))
(let __tmp4062 (Concat __tmp4034 __tmp4061))
(let __tmp4063 (Concat __tmp3777 __tmp4062))
(let __tmp4064 (Concat __tmp3775 __tmp4063))
(let __tmp4065 (Concat __tmp4032 __tmp4064))
(let __tmp4066 (Concat __tmp3771 __tmp4065))
(let __tmp4067 (Concat __tmp4030 __tmp4066))
(let __tmp4068 (InFunc " loop_ctx_11"))
(let __tmp4069 (Arg __tmp493 __tmp4068))
(let __tmp4070 (Get __tmp4069 3))
(let __tmp4071 (Get __tmp4069 17))
(let __tmp4072 (Bop __tmp171 __tmp4070 __tmp4071))
(let __tmp4073 (Single __tmp4072))
(let __tmp4074 (InIf true __tmp4072 __tmp4069))
(let __tmp4075 (Const __tmp110 __tmp493 __tmp4074))
(let __tmp4076 (Arg __tmp493 __tmp4074))
(let __tmp4077 (Get __tmp4076 14))
(let __tmp4078 (Bop __tmp171 __tmp4075 __tmp4077))
(let __tmp4079 (Get __tmp4076 0))
(let __tmp4080 (Single __tmp4079))
(let __tmp4081 (Get __tmp4076 1))
(let __tmp4082 (Single __tmp4081))
(let __tmp4083 (Get __tmp4076 2))
(let __tmp4084 (Single __tmp4083))
(let __tmp4085 (Get __tmp4076 3))
(let __tmp4086 (Single __tmp4085))
(let __tmp4087 (Get __tmp4076 4))
(let __tmp4088 (Single __tmp4087))
(let __tmp4089 (Const __tmp104 __tmp493 __tmp4074))
(let __tmp4090 (Single __tmp4089))
(let __tmp4091 (Single __tmp4075))
(let __tmp4092 (Get __tmp4076 5))
(let __tmp4093 (Single __tmp4092))
(let __tmp4094 (Get __tmp4076 6))
(let __tmp4095 (Single __tmp4094))
(let __tmp4096 (Get __tmp4076 7))
(let __tmp4097 (Single __tmp4096))
(let __tmp4098 (Get __tmp4076 8))
(let __tmp4099 (Single __tmp4098))
(let __tmp4100 (Get __tmp4076 9))
(let __tmp4101 (Single __tmp4100))
(let __tmp4102 (Get __tmp4076 10))
(let __tmp4103 (Single __tmp4102))
(let __tmp4104 (Get __tmp4076 11))
(let __tmp4105 (Single __tmp4104))
(let __tmp4106 (Get __tmp4076 12))
(let __tmp4107 (Single __tmp4106))
(let __tmp4108 (Get __tmp4076 13))
(let __tmp4109 (Single __tmp4108))
(let __tmp4110 (Single __tmp4077))
(let __tmp4111 (Get __tmp4076 15))
(let __tmp4112 (Single __tmp4111))
(let __tmp4113 (Get __tmp4076 16))
(let __tmp4114 (Single __tmp4113))
(let __tmp4115 (Get __tmp4076 17))
(let __tmp4116 (Single __tmp4115))
(let __tmp4117 (Concat __tmp4114 __tmp4116))
(let __tmp4118 (Concat __tmp4112 __tmp4117))
(let __tmp4119 (Concat __tmp4110 __tmp4118))
(let __tmp4120 (Concat __tmp4109 __tmp4119))
(let __tmp4121 (Concat __tmp4107 __tmp4120))
(let __tmp4122 (Concat __tmp4105 __tmp4121))
(let __tmp4123 (Concat __tmp4103 __tmp4122))
(let __tmp4124 (Concat __tmp4101 __tmp4123))
(let __tmp4125 (Concat __tmp4099 __tmp4124))
(let __tmp4126 (Concat __tmp4097 __tmp4125))
(let __tmp4127 (Concat __tmp4095 __tmp4126))
(let __tmp4128 (Concat __tmp4093 __tmp4127))
(let __tmp4129 (Concat __tmp4091 __tmp4128))
(let __tmp4130 (Concat __tmp4090 __tmp4129))
(let __tmp4131 (Concat __tmp4088 __tmp4130))
(let __tmp4132 (Concat __tmp4086 __tmp4131))
(let __tmp4133 (Concat __tmp4084 __tmp4132))
(let __tmp4134 (Concat __tmp4082 __tmp4133))
(let __tmp4135 (Concat __tmp4080 __tmp4134))
(let __tmp4136 (InIf true __tmp4078 __tmp4135))
(let __tmp4137 (Arg __tmp568 __tmp4136))
(let __tmp4138 (Single __tmp3151))
(let __tmp4139 (Single __tmp3153))
(let __tmp4140 (Get __tmp3150 4))
(let __tmp4141 (Single __tmp4140))
(let __tmp4142 (Single __tmp3154))
(let __tmp4143 (Bop __tmp326 __tmp4140 __tmp3266))
(let __tmp4144 (Single __tmp4143))
(let __tmp4145 (Get __tmp3150 7))
(let __tmp4146 (Single __tmp4145))
(let __tmp4147 (Get __tmp3150 8))
(let __tmp4148 (Single __tmp4147))
(let __tmp4149 (Single __tmp3271))
(let __tmp4150 (Get __tmp3150 10))
(let __tmp4151 (Single __tmp4150))
(let __tmp4152 (Single __tmp3156))
(let __tmp4153 (Get __tmp3150 12))
(let __tmp4154 (Single __tmp4153))
(let __tmp4155 (Get __tmp3150 13))
(let __tmp4156 (Single __tmp4155))
(let __tmp4157 (Get __tmp3150 14))
(let __tmp4158 (Single __tmp4157))
(let __tmp4159 (Get __tmp3150 15))
(let __tmp4160 (Single __tmp4159))
(let __tmp4161 (Concat __tmp4160 __tmp3269))
(let __tmp4162 (Concat __tmp4158 __tmp4161))
(let __tmp4163 (Concat __tmp4156 __tmp4162))
(let __tmp4164 (Concat __tmp4154 __tmp4163))
(let __tmp4165 (Concat __tmp4152 __tmp4164))
(let __tmp4166 (Concat __tmp4151 __tmp4165))
(let __tmp4167 (Concat __tmp4149 __tmp4166))
(let __tmp4168 (Concat __tmp4148 __tmp4167))
(let __tmp4169 (Concat __tmp4146 __tmp4168))
(let __tmp4170 (Concat __tmp4144 __tmp4169))
(let __tmp4171 (Get __tmp3150 19))
(let __tmp4172 (Single __tmp4171))
(let __tmp4173 (Concat __tmp3160 __tmp4172))
(let __tmp4174 (Concat __tmp3263 __tmp4173))
(let __tmp4175 (Concat __tmp4170 __tmp4174))
(let __tmp4176 (Concat __tmp4142 __tmp4175))
(let __tmp4177 (Concat __tmp4141 __tmp4176))
(let __tmp4178 (Concat __tmp3265 __tmp4177))
(let __tmp4179 (Concat __tmp4139 __tmp4178))
(let __tmp4180 (Concat __tmp4138 __tmp4179))
(let __tmp4181 (Concat __tmp3282 __tmp4180))
(let __tmp4182 (Get __tmp4181 6))
(let __tmp4183 (Get __tmp4181 16))
(let __tmp4184 (Bop __tmp171 __tmp4182 __tmp4183))
(let __tmp4185 (Single __tmp4184))
(let __tmp4186 (Concat __tmp4185 __tmp4181))
(let __tmp4187 (DoWhile __tmp4137 __tmp4186))
(let __tmp4188 (InIf false __tmp4078 __tmp4135))
(let __tmp4189 (Arg __tmp568 __tmp4188))
(let __tmp4190 (If __tmp4078 __tmp4135 __tmp4187 __tmp4189))
(let __tmp4191 (Get __tmp4190 0))
(let __tmp4192 (Single __tmp4191))
(let __tmp4193 (Get __tmp4190 1))
(let __tmp4194 (Get __tmp4190 2))
(let __tmp4195 (Bop __tmp292 __tmp4193 __tmp4194))
(let __tmp4196 (Single __tmp4195))
(let __tmp4197 (Single __tmp4194))
(let __tmp4198 (Bop __tmp326 __tmp4087 __tmp4085))
(let __tmp4199 (Single __tmp4198))
(let __tmp4200 (Get __tmp4190 7))
(let __tmp4201 (Single __tmp4200))
(let __tmp4202 (Get __tmp4190 9))
(let __tmp4203 (Single __tmp4202))
(let __tmp4204 (Get __tmp4190 10))
(let __tmp4205 (Single __tmp4204))
(let __tmp4206 (Get __tmp4190 11))
(let __tmp4207 (Single __tmp4206))
(let __tmp4208 (Get __tmp4190 13))
(let __tmp4209 (Single __tmp4208))
(let __tmp4210 (Get __tmp4190 14))
(let __tmp4211 (Single __tmp4210))
(let __tmp4212 (Get __tmp4190 15))
(let __tmp4213 (Single __tmp4212))
(let __tmp4214 (Concat __tmp4213 __tmp4110))
(let __tmp4215 (Concat __tmp4211 __tmp4214))
(let __tmp4216 (Concat __tmp4209 __tmp4215))
(let __tmp4217 (Get __tmp4190 17))
(let __tmp4218 (Single __tmp4217))
(let __tmp4219 (Get __tmp4190 18))
(let __tmp4220 (Single __tmp4219))
(let __tmp4221 (Concat __tmp4220 __tmp4116))
(let __tmp4222 (Concat __tmp4218 __tmp4221))
(let __tmp4223 (Concat __tmp4216 __tmp4222))
(let __tmp4224 (Concat __tmp4103 __tmp4223))
(let __tmp4225 (Concat __tmp4207 __tmp4224))
(let __tmp4226 (Concat __tmp4205 __tmp4225))
(let __tmp4227 (Concat __tmp4203 __tmp4226))
(let __tmp4228 (Concat __tmp4095 __tmp4227))
(let __tmp4229 (Concat __tmp4201 __tmp4228))
(let __tmp4230 (Concat __tmp4088 __tmp4229))
(let __tmp4231 (Concat __tmp4199 __tmp4230))
(let __tmp4232 (Concat __tmp4197 __tmp4231))
(let __tmp4233 (Concat __tmp4196 __tmp4232))
(let __tmp4234 (Concat __tmp4192 __tmp4233))
(let __tmp4235 (InIf false __tmp4072 __tmp4069))
(let __tmp4236 (Arg __tmp493 __tmp4235))
(let __tmp4237 (If __tmp4072 __tmp4069 __tmp4234 __tmp4236))
(let __tmp4238 (Concat __tmp4073 __tmp4237))
(let __tmp4239 (DoWhile __tmp4067 __tmp4238))
(let __tmp4240 (Get __tmp4239 0))
(let __tmp4241 (Single __tmp4240))
(let __tmp4242 (Get __tmp4239 2))
(let __tmp4243 (Single __tmp4242))
(let __tmp4244 (Get __tmp4239 5))
(let __tmp4245 (Single __tmp4244))
(let __tmp4246 (Get __tmp4239 7))
(let __tmp4247 (Single __tmp4246))
(let __tmp4248 (Get __tmp4239 8))
(let __tmp4249 (Single __tmp4248))
(let __tmp4250 (Get __tmp4239 9))
(let __tmp4251 (Single __tmp4250))
(let __tmp4252 (Get __tmp4239 11))
(let __tmp4253 (Single __tmp4252))
(let __tmp4254 (Get __tmp4239 12))
(let __tmp4255 (Single __tmp4254))
(let __tmp4256 (Get __tmp4239 13))
(let __tmp4257 (Single __tmp4256))
(let __tmp4258 (Concat __tmp4257 __tmp3797))
(let __tmp4259 (Concat __tmp4255 __tmp4258))
(let __tmp4260 (Concat __tmp4253 __tmp4259))
(let __tmp4261 (Concat __tmp3789 __tmp4260))
(let __tmp4262 (Concat __tmp4251 __tmp4261))
(let __tmp4263 (Concat __tmp4249 __tmp4262))
(let __tmp4264 (Concat __tmp4247 __tmp4263))
(let __tmp4265 (Concat __tmp3781 __tmp4264))
(let __tmp4266 (Concat __tmp4245 __tmp4265))
(let __tmp4267 (Concat __tmp3777 __tmp4266))
(let __tmp4268 (Concat __tmp3775 __tmp4267))
(let __tmp4269 (Concat __tmp4243 __tmp4268))
(let __tmp4270 (Concat __tmp3771 __tmp4269))
(let __tmp4271 (Concat __tmp4241 __tmp4270))
(let __tmp4272 (InFunc " loop_ctx_10"))
(let __tmp4273 (Arg __tmp756 __tmp4272))
(let __tmp4274 (Get __tmp4273 3))
(let __tmp4275 (Get __tmp4273 14))
(let __tmp4276 (Bop __tmp171 __tmp4274 __tmp4275))
(let __tmp4277 (Single __tmp4276))
(let __tmp4278 (InIf true __tmp4276 __tmp4273))
(let __tmp4279 (Const __tmp110 __tmp756 __tmp4278))
(let __tmp4280 (Arg __tmp756 __tmp4278))
(let __tmp4281 (Get __tmp4280 10))
(let __tmp4282 (Bop __tmp171 __tmp4279 __tmp4281))
(let __tmp4283 (Get __tmp4280 0))
(let __tmp4284 (Single __tmp4283))
(let __tmp4285 (Get __tmp4280 1))
(let __tmp4286 (Single __tmp4285))
(let __tmp4287 (Get __tmp4280 2))
(let __tmp4288 (Single __tmp4287))
(let __tmp4289 (Get __tmp4280 3))
(let __tmp4290 (Single __tmp4289))
(let __tmp4291 (Get __tmp4280 4))
(let __tmp4292 (Single __tmp4291))
(let __tmp4293 (Const __tmp104 __tmp756 __tmp4278))
(let __tmp4294 (Single __tmp4293))
(let __tmp4295 (Single __tmp4279))
(let __tmp4296 (Get __tmp4280 5))
(let __tmp4297 (Single __tmp4296))
(let __tmp4298 (Get __tmp4280 6))
(let __tmp4299 (Single __tmp4298))
(let __tmp4300 (Get __tmp4280 7))
(let __tmp4301 (Single __tmp4300))
(let __tmp4302 (Get __tmp4280 8))
(let __tmp4303 (Single __tmp4302))
(let __tmp4304 (Get __tmp4280 9))
(let __tmp4305 (Single __tmp4304))
(let __tmp4306 (Single __tmp4281))
(let __tmp4307 (Get __tmp4280 11))
(let __tmp4308 (Single __tmp4307))
(let __tmp4309 (Get __tmp4280 12))
(let __tmp4310 (Single __tmp4309))
(let __tmp4311 (Get __tmp4280 13))
(let __tmp4312 (Single __tmp4311))
(let __tmp4313 (Get __tmp4280 14))
(let __tmp4314 (Single __tmp4313))
(let __tmp4315 (Concat __tmp4312 __tmp4314))
(let __tmp4316 (Concat __tmp4310 __tmp4315))
(let __tmp4317 (Concat __tmp4308 __tmp4316))
(let __tmp4318 (Concat __tmp4306 __tmp4317))
(let __tmp4319 (Concat __tmp4305 __tmp4318))
(let __tmp4320 (Concat __tmp4303 __tmp4319))
(let __tmp4321 (Concat __tmp4301 __tmp4320))
(let __tmp4322 (Concat __tmp4299 __tmp4321))
(let __tmp4323 (Concat __tmp4297 __tmp4322))
(let __tmp4324 (Concat __tmp4295 __tmp4323))
(let __tmp4325 (Concat __tmp4294 __tmp4324))
(let __tmp4326 (Concat __tmp4292 __tmp4325))
(let __tmp4327 (Concat __tmp4290 __tmp4326))
(let __tmp4328 (Concat __tmp4288 __tmp4327))
(let __tmp4329 (Concat __tmp4286 __tmp4328))
(let __tmp4330 (Concat __tmp4284 __tmp4329))
(let __tmp4331 (InIf true __tmp4282 __tmp4330))
(let __tmp4332 (Arg __tmp822 __tmp4331))
(let __tmp4333 (Single __tmp3305))
(let __tmp4334 (Get __tmp3304 2))
(let __tmp4335 (Single __tmp4334))
(let __tmp4336 (Get __tmp3304 4))
(let __tmp4337 (Single __tmp4336))
(let __tmp4338 (Bop __tmp292 __tmp3306 __tmp4334))
(let __tmp4339 (Single __tmp4338))
(let __tmp4340 (Bop __tmp326 __tmp4336 __tmp3418))
(let __tmp4341 (Single __tmp4340))
(let __tmp4342 (Get __tmp3304 7))
(let __tmp4343 (Single __tmp4342))
(let __tmp4344 (Get __tmp3304 8))
(let __tmp4345 (Single __tmp4344))
(let __tmp4346 (Single __tmp3423))
(let __tmp4347 (Get __tmp3304 10))
(let __tmp4348 (Single __tmp4347))
(let __tmp4349 (Get __tmp3304 11))
(let __tmp4350 (Single __tmp4349))
(let __tmp4351 (Concat __tmp4350 __tmp3421))
(let __tmp4352 (Concat __tmp4348 __tmp4351))
(let __tmp4353 (Concat __tmp4346 __tmp4352))
(let __tmp4354 (Concat __tmp4345 __tmp4353))
(let __tmp4355 (Single __tmp3307))
(let __tmp4356 (Get __tmp3304 16))
(let __tmp4357 (Single __tmp4356))
(let __tmp4358 (Concat __tmp4355 __tmp4357))
(let __tmp4359 (Concat __tmp3312 __tmp4358))
(let __tmp4360 (Concat __tmp3415 __tmp4359))
(let __tmp4361 (Concat __tmp4354 __tmp4360))
(let __tmp4362 (Concat __tmp4343 __tmp4361))
(let __tmp4363 (Concat __tmp4341 __tmp4362))
(let __tmp4364 (Concat __tmp4339 __tmp4363))
(let __tmp4365 (Concat __tmp4337 __tmp4364))
(let __tmp4366 (Concat __tmp3417 __tmp4365))
(let __tmp4367 (Concat __tmp4335 __tmp4366))
(let __tmp4368 (Concat __tmp4333 __tmp4367))
(let __tmp4369 (Concat __tmp3434 __tmp4368))
(let __tmp4370 (Get __tmp4369 6))
(let __tmp4371 (Get __tmp4369 12))
(let __tmp4372 (Bop __tmp171 __tmp4370 __tmp4371))
(let __tmp4373 (Single __tmp4372))
(let __tmp4374 (Concat __tmp4373 __tmp4369))
(let __tmp4375 (DoWhile __tmp4332 __tmp4374))
(let __tmp4376 (InIf false __tmp4282 __tmp4330))
(let __tmp4377 (Arg __tmp822 __tmp4376))
(let __tmp4378 (If __tmp4282 __tmp4330 __tmp4375 __tmp4377))
(let __tmp4379 (Get __tmp4378 0))
(let __tmp4380 (Single __tmp4379))
(let __tmp4381 (Get __tmp4378 1))
(let __tmp4382 (Get __tmp4378 2))
(let __tmp4383 (Bop __tmp292 __tmp4381 __tmp4382))
(let __tmp4384 (Single __tmp4383))
(let __tmp4385 (Single __tmp4382))
(let __tmp4386 (Bop __tmp326 __tmp4291 __tmp4289))
(let __tmp4387 (Single __tmp4386))
(let __tmp4388 (Get __tmp4378 7))
(let __tmp4389 (Single __tmp4388))
(let __tmp4390 (Get __tmp4378 9))
(let __tmp4391 (Single __tmp4390))
(let __tmp4392 (Get __tmp4378 10))
(let __tmp4393 (Single __tmp4392))
(let __tmp4394 (Get __tmp4378 11))
(let __tmp4395 (Single __tmp4394))
(let __tmp4396 (Concat __tmp4395 __tmp4306))
(let __tmp4397 (Concat __tmp4393 __tmp4396))
(let __tmp4398 (Concat __tmp4391 __tmp4397))
(let __tmp4399 (Get __tmp4378 13))
(let __tmp4400 (Single __tmp4399))
(let __tmp4401 (Get __tmp4378 14))
(let __tmp4402 (Single __tmp4401))
(let __tmp4403 (Get __tmp4378 15))
(let __tmp4404 (Single __tmp4403))
(let __tmp4405 (Concat __tmp4404 __tmp4314))
(let __tmp4406 (Concat __tmp4402 __tmp4405))
(let __tmp4407 (Concat __tmp4400 __tmp4406))
(let __tmp4408 (Concat __tmp4398 __tmp4407))
(let __tmp4409 (Concat __tmp4299 __tmp4408))
(let __tmp4410 (Concat __tmp4389 __tmp4409))
(let __tmp4411 (Concat __tmp4292 __tmp4410))
(let __tmp4412 (Concat __tmp4387 __tmp4411))
(let __tmp4413 (Concat __tmp4385 __tmp4412))
(let __tmp4414 (Concat __tmp4384 __tmp4413))
(let __tmp4415 (Concat __tmp4380 __tmp4414))
(let __tmp4416 (InIf false __tmp4276 __tmp4273))
(let __tmp4417 (Arg __tmp756 __tmp4416))
(let __tmp4418 (If __tmp4276 __tmp4273 __tmp4415 __tmp4417))
(let __tmp4419 (Concat __tmp4277 __tmp4418))
(let __tmp4420 (DoWhile __tmp4271 __tmp4419))
(let __tmp4421 (Get __tmp4420 0))
(let __tmp4422 (Single __tmp4421))
(let __tmp4423 (Get __tmp4420 2))
(let __tmp4424 (Single __tmp4423))
(let __tmp4425 (Get __tmp4420 5))
(let __tmp4426 (Single __tmp4425))
(let __tmp4427 (Get __tmp4420 7))
(let __tmp4428 (Single __tmp4427))
(let __tmp4429 (Get __tmp4420 8))
(let __tmp4430 (Single __tmp4429))
(let __tmp4431 (Get __tmp4420 9))
(let __tmp4432 (Single __tmp4431))
(let __tmp4433 (Concat __tmp4432 __tmp3789))
(let __tmp4434 (Concat __tmp4430 __tmp4433))
(let __tmp4435 (Concat __tmp4428 __tmp4434))
(let __tmp4436 (Concat __tmp3781 __tmp4435))
(let __tmp4437 (Concat __tmp4426 __tmp4436))
(let __tmp4438 (Concat __tmp3777 __tmp4437))
(let __tmp4439 (Concat __tmp3775 __tmp4438))
(let __tmp4440 (Concat __tmp4424 __tmp4439))
(let __tmp4441 (Concat __tmp3771 __tmp4440))
(let __tmp4442 (Concat __tmp4422 __tmp4441))
(let __tmp4443 (InFunc " loop_ctx_9"))
(let __tmp4444 (Arg __tmp979 __tmp4443))
(let __tmp4445 (Get __tmp4444 3))
(let __tmp4446 (Get __tmp4444 10))
(let __tmp4447 (Bop __tmp171 __tmp4445 __tmp4446))
(let __tmp4448 (Single __tmp4447))
(let __tmp4449 (InIf true __tmp4447 __tmp4444))
(let __tmp4450 (Const __tmp110 __tmp979 __tmp4449))
(let __tmp4451 (Arg __tmp979 __tmp4449))
(let __tmp4452 (Get __tmp4451 6))
(let __tmp4453 (Bop __tmp171 __tmp4450 __tmp4452))
(let __tmp4454 (Get __tmp4451 0))
(let __tmp4455 (Single __tmp4454))
(let __tmp4456 (Get __tmp4451 1))
(let __tmp4457 (Single __tmp4456))
(let __tmp4458 (Get __tmp4451 2))
(let __tmp4459 (Single __tmp4458))
(let __tmp4460 (Get __tmp4451 3))
(let __tmp4461 (Single __tmp4460))
(let __tmp4462 (Get __tmp4451 4))
(let __tmp4463 (Single __tmp4462))
(let __tmp4464 (Const __tmp104 __tmp979 __tmp4449))
(let __tmp4465 (Single __tmp4464))
(let __tmp4466 (Single __tmp4450))
(let __tmp4467 (Get __tmp4451 5))
(let __tmp4468 (Single __tmp4467))
(let __tmp4469 (Single __tmp4452))
(let __tmp4470 (Get __tmp4451 7))
(let __tmp4471 (Single __tmp4470))
(let __tmp4472 (Get __tmp4451 8))
(let __tmp4473 (Single __tmp4472))
(let __tmp4474 (Get __tmp4451 9))
(let __tmp4475 (Single __tmp4474))
(let __tmp4476 (Get __tmp4451 10))
(let __tmp4477 (Single __tmp4476))
(let __tmp4478 (Concat __tmp4475 __tmp4477))
(let __tmp4479 (Concat __tmp4473 __tmp4478))
(let __tmp4480 (Concat __tmp4471 __tmp4479))
(let __tmp4481 (Concat __tmp4469 __tmp4480))
(let __tmp4482 (Concat __tmp4468 __tmp4481))
(let __tmp4483 (Concat __tmp4466 __tmp4482))
(let __tmp4484 (Concat __tmp4465 __tmp4483))
(let __tmp4485 (Concat __tmp4463 __tmp4484))
(let __tmp4486 (Concat __tmp4461 __tmp4485))
(let __tmp4487 (Concat __tmp4459 __tmp4486))
(let __tmp4488 (Concat __tmp4457 __tmp4487))
(let __tmp4489 (Concat __tmp4455 __tmp4488))
(let __tmp4490 (InIf true __tmp4453 __tmp4489))
(let __tmp4491 (Arg __tmp1033 __tmp4490))
(let __tmp4492 (Single __tmp3457))
(let __tmp4493 (Get __tmp3456 2))
(let __tmp4494 (Single __tmp4493))
(let __tmp4495 (Get __tmp3456 4))
(let __tmp4496 (Single __tmp4495))
(let __tmp4497 (Bop __tmp292 __tmp3458 __tmp4493))
(let __tmp4498 (Single __tmp4497))
(let __tmp4499 (Bop __tmp326 __tmp4495 __tmp3571))
(let __tmp4500 (Single __tmp4499))
(let __tmp4501 (Single __tmp3576))
(let __tmp4502 (Single __tmp3459))
(let __tmp4503 (Get __tmp3456 12))
(let __tmp4504 (Single __tmp4503))
(let __tmp4505 (Concat __tmp4502 __tmp4504))
(let __tmp4506 (Concat __tmp3465 __tmp4505))
(let __tmp4507 (Concat __tmp4501 __tmp4506))
(let __tmp4508 (Concat __tmp3574 __tmp4507))
(let __tmp4509 (Concat __tmp3568 __tmp4508))
(let __tmp4510 (Concat __tmp4500 __tmp4509))
(let __tmp4511 (Concat __tmp4498 __tmp4510))
(let __tmp4512 (Concat __tmp4496 __tmp4511))
(let __tmp4513 (Concat __tmp3570 __tmp4512))
(let __tmp4514 (Concat __tmp4494 __tmp4513))
(let __tmp4515 (Concat __tmp4492 __tmp4514))
(let __tmp4516 (Concat __tmp3587 __tmp4515))
(let __tmp4517 (Get __tmp4516 6))
(let __tmp4518 (Get __tmp4516 8))
(let __tmp4519 (Bop __tmp171 __tmp4517 __tmp4518))
(let __tmp4520 (Single __tmp4519))
(let __tmp4521 (Concat __tmp4520 __tmp4516))
(let __tmp4522 (DoWhile __tmp4491 __tmp4521))
(let __tmp4523 (InIf false __tmp4453 __tmp4489))
(let __tmp4524 (Arg __tmp1033 __tmp4523))
(let __tmp4525 (If __tmp4453 __tmp4489 __tmp4522 __tmp4524))
(let __tmp4526 (Get __tmp4525 0))
(let __tmp4527 (Single __tmp4526))
(let __tmp4528 (Get __tmp4525 1))
(let __tmp4529 (Get __tmp4525 2))
(let __tmp4530 (Bop __tmp292 __tmp4528 __tmp4529))
(let __tmp4531 (Single __tmp4530))
(let __tmp4532 (Single __tmp4529))
(let __tmp4533 (Bop __tmp326 __tmp4462 __tmp4460))
(let __tmp4534 (Single __tmp4533))
(let __tmp4535 (Get __tmp4525 7))
(let __tmp4536 (Single __tmp4535))
(let __tmp4537 (Get __tmp4525 9))
(let __tmp4538 (Single __tmp4537))
(let __tmp4539 (Get __tmp4525 10))
(let __tmp4540 (Single __tmp4539))
(let __tmp4541 (Get __tmp4525 11))
(let __tmp4542 (Single __tmp4541))
(let __tmp4543 (Concat __tmp4542 __tmp4477))
(let __tmp4544 (Concat __tmp4540 __tmp4543))
(let __tmp4545 (Concat __tmp4538 __tmp4544))
(let __tmp4546 (Concat __tmp4469 __tmp4545))
(let __tmp4547 (Concat __tmp4536 __tmp4546))
(let __tmp4548 (Concat __tmp4463 __tmp4547))
(let __tmp4549 (Concat __tmp4534 __tmp4548))
(let __tmp4550 (Concat __tmp4532 __tmp4549))
(let __tmp4551 (Concat __tmp4531 __tmp4550))
(let __tmp4552 (Concat __tmp4527 __tmp4551))
(let __tmp4553 (InIf false __tmp4447 __tmp4444))
(let __tmp4554 (Arg __tmp979 __tmp4553))
(let __tmp4555 (If __tmp4447 __tmp4444 __tmp4552 __tmp4554))
(let __tmp4556 (Concat __tmp4448 __tmp4555))
(let __tmp4557 (DoWhile __tmp4442 __tmp4556))
(let __tmp4558 (Get __tmp4557 0))
(let __tmp4559 (Single __tmp4558))
(let __tmp4560 (Function "init" __tmp3765 __tmp4 __tmp4559))
(let __tmp4561 (TupleT __tmp3653))
(let __tmp4562 (TCons __tmp21 __tmp3))
(let __tmp4563 (TupleT __tmp4562))
(let __tmp4564 (InFunc "matrix_new"))
(let __tmp4565 (Arg __tmp4561 __tmp4564))
(let __tmp4566 (Get __tmp4565 1))
(let __tmp4567 (Get __tmp4565 0))
(let __tmp4568 (Bop __tmp15 __tmp4566 __tmp4567))
(let __tmp4569 (Get __tmp4565 2))
(let __tmp4570 (Alloc 0 __tmp4568 __tmp4569 __tmp21))
(let __tmp4571 (Function "matrix_new" __tmp4561 __tmp4563 __tmp4570))
(let __tmp4572 (InFunc "matrix_loc"))
(let __tmp4573 (Arg __tmp3656 __tmp4572))
(let __tmp4574 (Get __tmp4573 0))
(let __tmp4575 (Get __tmp4573 2))
(let __tmp4576 (Get __tmp4573 3))
(let __tmp4577 (Get __tmp4573 1))
(let __tmp4578 (Bop __tmp15 __tmp4576 __tmp4577))
(let __tmp4579 (Bop __tmp326 __tmp4575 __tmp4578))
(let __tmp4580 (Bop __tmp2361 __tmp4574 __tmp4579))
(let __tmp4581 (Single __tmp4580))
(let __tmp4582 (Get __tmp4573 4))
(let __tmp4583 (Single __tmp4582))
(let __tmp4584 (Concat __tmp4581 __tmp4583))
(let __tmp4585 (Function "matrix_loc" __tmp3656 __tmp4563 __tmp4584))
(let __tmp4586 (TupleT __tmp3671))
(let __tmp4587 (Get __tmp3659 0))
(let __tmp4588 (Get __tmp3659 1))
(let __tmp4589 (Bop __tmp1235 __tmp4587 __tmp4588))
(let __tmp4590 (Function "matrix_get" __tmp3656 __tmp4586 __tmp4589))
(let __tmp4591 (Get __tmp3693 0))
(let __tmp4592 (Get __tmp3678 4))
(let __tmp4593 (Get __tmp3693 1))
(let __tmp4594 (Top __tmp1189 __tmp4591 __tmp4592 __tmp4593))
(let __tmp4595 (Single __tmp4594))
(let __tmp4596 (Function "matrix_set" __tmp3676 __tmp4 __tmp4595))
(let __tmp4597 (Get __tmp3721 0))
(let __tmp4598 (Get __tmp3721 1))
(let __tmp4599 (Bop __tmp1235 __tmp4597 __tmp4598))
(let __tmp4600 (Get __tmp4599 0))
(let __tmp4601 (Get __tmp3706 4))
(let __tmp4602 (Bop __tmp292 __tmp4600 __tmp4601))
(let __tmp4603 (Get __tmp4599 1))
(let __tmp4604 (Top __tmp1189 __tmp4597 __tmp4602 __tmp4603))
(let __tmp4605 (Single __tmp4604))
(let __tmp4606 (Function "matrix_incr" __tmp3676 __tmp4 __tmp4605))
(let __tmp4607 (TCons __tmp21 __tmp3653))
(let __tmp4608 (TupleT __tmp4607))
(let __tmp4609 (InFunc "matrix_sum"))
(let __tmp4610 (Const __tmp110 __tmp4608 __tmp4609))
(let __tmp4611 (Arg __tmp4608 __tmp4609))
(let __tmp4612 (Get __tmp4611 1))
(let __tmp4613 (Get __tmp4611 2))
(let __tmp4614 (Bop __tmp15 __tmp4612 __tmp4613))
(let __tmp4615 (Bop __tmp171 __tmp4610 __tmp4614))
(let __tmp4616 (Get __tmp4611 3))
(let __tmp4617 (Single __tmp4616))
(let __tmp4618 (Const __tmp104 __tmp4608 __tmp4609))
(let __tmp4619 (Single __tmp4618))
(let __tmp4620 (Single __tmp4610))
(let __tmp4621 (Const __tmp113 __tmp4608 __tmp4609))
(let __tmp4622 (Single __tmp4621))
(let __tmp4623 (Get __tmp4611 0))
(let __tmp4624 (Single __tmp4623))
(let __tmp4625 (Single __tmp4614))
(let __tmp4626 (Concat __tmp4624 __tmp4625))
(let __tmp4627 (Concat __tmp4622 __tmp4626))
(let __tmp4628 (Concat __tmp4620 __tmp4627))
(let __tmp4629 (Concat __tmp4619 __tmp4628))
(let __tmp4630 (Concat __tmp4617 __tmp4629))
(let __tmp4631 (InIf true __tmp4615 __tmp4630))
(let __tmp4632 (Arg __tmp2350 __tmp4631))
(let __tmp4633 (InFunc " loop_ctx_17"))
(let __tmp4634 (Arg __tmp2350 __tmp4633))
(let __tmp4635 (Get __tmp4634 2))
(let __tmp4636 (Get __tmp4634 3))
(let __tmp4637 (Bop __tmp326 __tmp4635 __tmp4636))
(let __tmp4638 (Get __tmp4634 5))
(let __tmp4639 (Bop __tmp171 __tmp4637 __tmp4638))
(let __tmp4640 (Single __tmp4639))
(let __tmp4641 (Get __tmp4634 4))
(let __tmp4642 (Bop __tmp2361 __tmp4641 __tmp4635))
(let __tmp4643 (Get __tmp4634 0))
(let __tmp4644 (Bop __tmp1235 __tmp4642 __tmp4643))
(let __tmp4645 (Get __tmp4644 1))
(let __tmp4646 (Single __tmp4645))
(let __tmp4647 (Get __tmp4634 1))
(let __tmp4648 (Get __tmp4644 0))
(let __tmp4649 (Bop __tmp292 __tmp4647 __tmp4648))
(let __tmp4650 (Single __tmp4649))
(let __tmp4651 (Single __tmp4637))
(let __tmp4652 (Single __tmp4636))
(let __tmp4653 (Concat __tmp4651 __tmp4652))
(let __tmp4654 (Single __tmp4641))
(let __tmp4655 (Concat __tmp4653 __tmp4654))
(let __tmp4656 (Single __tmp4638))
(let __tmp4657 (Concat __tmp4655 __tmp4656))
(let __tmp4658 (Concat __tmp4650 __tmp4657))
(let __tmp4659 (Concat __tmp4646 __tmp4658))
(let __tmp4660 (Concat __tmp4640 __tmp4659))
(let __tmp4661 (DoWhile __tmp4632 __tmp4660))
(let __tmp4662 (InIf false __tmp4615 __tmp4630))
(let __tmp4663 (Arg __tmp2350 __tmp4662))
(let __tmp4664 (If __tmp4615 __tmp4630 __tmp4661 __tmp4663))
(let __tmp4665 (Get __tmp4664 1))
(let __tmp4666 (Single __tmp4665))
(let __tmp4667 (Get __tmp4664 0))
(let __tmp4668 (Single __tmp4667))
(let __tmp4669 (Concat __tmp4666 __tmp4668))
(let __tmp4670 (Function "matrix_sum" __tmp4608 __tmp4586 __tmp4669))
(let __tmp4671 (TCons __tmp20 __tmp3671))
(let __tmp4672 (TupleT __tmp4671))
(let __tmp4673 (InFunc "fmod"))
(let __tmp4674 (Arg __tmp4672 __tmp4673))
(let __tmp4675 (Get __tmp4674 2))
(let __tmp4676 (Single __tmp4675))
(let __tmp4677 (Get __tmp4674 0))
(let __tmp4678 (Single __tmp4677))
(let __tmp4679 (Const __tmp125 __tmp4672 __tmp4673))
(let __tmp4680 (Single __tmp4679))
(let __tmp4681 (Const __tmp104 __tmp4672 __tmp4673))
(let __tmp4682 (Single __tmp4681))
(let __tmp4683 (Get __tmp4674 1))
(let __tmp4684 (Single __tmp4683))
(let __tmp4685 (Concat __tmp4682 __tmp4684))
(let __tmp4686 (Concat __tmp4680 __tmp4685))
(let __tmp4687 (Concat __tmp4678 __tmp4686))
(let __tmp4688 (Concat __tmp4676 __tmp4687))
(let __tmp4689 (InFunc " loop_ctx_18"))
(let __tmp4690 (Arg __tmp2410 __tmp4689))
(let __tmp4691 (Get __tmp4690 1))
(let __tmp4692 (Get __tmp4690 4))
(let __tmp4693 (Bop __tmp2405 __tmp4691 __tmp4692))
(let __tmp4694 (Single __tmp4693))
(let __tmp4695 (InIf true __tmp4693 __tmp4690))
(let __tmp4696 (Arg __tmp2410 __tmp4695))
(let __tmp4697 (Get __tmp4696 1))
(let __tmp4698 (Get __tmp4696 4))
(let __tmp4699 (Bop __tmp2417 __tmp4697 __tmp4698))
(let __tmp4700 (Get __tmp4696 3))
(let __tmp4701 (Bop __tmp2405 __tmp4699 __tmp4700))
(let __tmp4702 (Get __tmp4696 0))
(let __tmp4703 (Single __tmp4702))
(let __tmp4704 (Single __tmp4697))
(let __tmp4705 (Single __tmp4698))
(let __tmp4706 (Get __tmp4696 2))
(let __tmp4707 (Single __tmp4706))
(let __tmp4708 (Single __tmp4700))
(let __tmp4709 (Concat __tmp4708 __tmp4705))
(let __tmp4710 (Concat __tmp4707 __tmp4709))
(let __tmp4711 (Concat __tmp4705 __tmp4710))
(let __tmp4712 (Concat __tmp4704 __tmp4711))
(let __tmp4713 (Concat __tmp4703 __tmp4712))
(let __tmp4714 (InIf true __tmp4701 __tmp4713))
(let __tmp4715 (Arg __tmp2439 __tmp4714))
(let __tmp4716 (InFunc " loop_ctx_19"))
(let __tmp4717 (Arg __tmp2439 __tmp4716))
(let __tmp4718 (Get __tmp4717 1))
(let __tmp4719 (Get __tmp4717 2))
(let __tmp4720 (Get __tmp4717 3))
(let __tmp4721 (Bop __tmp293 __tmp4719 __tmp4720))
(let __tmp4722 (Bop __tmp2417 __tmp4718 __tmp4721))
(let __tmp4723 (Get __tmp4717 4))
(let __tmp4724 (Bop __tmp2405 __tmp4722 __tmp4723))
(let __tmp4725 (Single __tmp4724))
(let __tmp4726 (Get __tmp4717 0))
(let __tmp4727 (Single __tmp4726))
(let __tmp4728 (Single __tmp4718))
(let __tmp4729 (Single __tmp4721))
(let __tmp4730 (Single __tmp4720))
(let __tmp4731 (Concat __tmp4729 __tmp4730))
(let __tmp4732 (Single __tmp4723))
(let __tmp4733 (Concat __tmp4731 __tmp4732))
(let __tmp4734 (Get __tmp4717 5))
(let __tmp4735 (Single __tmp4734))
(let __tmp4736 (Concat __tmp4733 __tmp4735))
(let __tmp4737 (Concat __tmp4728 __tmp4736))
(let __tmp4738 (Concat __tmp4727 __tmp4737))
(let __tmp4739 (Concat __tmp4725 __tmp4738))
(let __tmp4740 (DoWhile __tmp4715 __tmp4739))
(let __tmp4741 (InIf false __tmp4701 __tmp4713))
(let __tmp4742 (Arg __tmp2439 __tmp4741))
(let __tmp4743 (If __tmp4701 __tmp4713 __tmp4740 __tmp4742))
(let __tmp4744 (Get __tmp4743 0))
(let __tmp4745 (Single __tmp4744))
(let __tmp4746 (Get __tmp4743 1))
(let __tmp4747 (Get __tmp4743 2))
(let __tmp4748 (Get __tmp4743 3))
(let __tmp4749 (Bop __tmp291 __tmp4747 __tmp4748))
(let __tmp4750 (Bop __tmp2417 __tmp4746 __tmp4749))
(let __tmp4751 (Single __tmp4750))
(let __tmp4752 (Single __tmp4748))
(let __tmp4753 (Get __tmp4743 4))
(let __tmp4754 (Single __tmp4753))
(let __tmp4755 (Concat __tmp4752 __tmp4754))
(let __tmp4756 (Get __tmp4743 5))
(let __tmp4757 (Single __tmp4756))
(let __tmp4758 (Concat __tmp4755 __tmp4757))
(let __tmp4759 (Concat __tmp4751 __tmp4758))
(let __tmp4760 (Concat __tmp4745 __tmp4759))
(let __tmp4761 (InIf false __tmp4693 __tmp4690))
(let __tmp4762 (Arg __tmp2410 __tmp4761))
(let __tmp4763 (If __tmp4693 __tmp4690 __tmp4760 __tmp4762))
(let __tmp4764 (Concat __tmp4694 __tmp4763))
(let __tmp4765 (DoWhile __tmp4688 __tmp4764))
(let __tmp4766 (Get __tmp4765 1))
(let __tmp4767 (Single __tmp4766))
(let __tmp4768 (Get __tmp4765 0))
(let __tmp4769 (Single __tmp4768))
(let __tmp4770 (Concat __tmp4767 __tmp4769))
(let __tmp4771 (Function "fmod" __tmp4672 __tmp4586 __tmp4770))
(let __tmp4772 (InLoop __tmp1411 __tmp1447))
(let __tmp4773 (InLoop __tmp1370 __tmp1484))
(let __tmp4774 (InLoop __tmp1311 __tmp1517))
(let __tmp4775 (InLoop __tmp1802 __tmp1838))
(let __tmp4776 (InLoop __tmp1761 __tmp1878))
(let __tmp4777 (InLoop __tmp1701 __tmp1914))
(let __tmp4778 (InLoop __tmp2205 __tmp2241))
(let __tmp4779 (InLoop __tmp2164 __tmp2283))
(let __tmp4780 (InLoop __tmp2103 __tmp2321))
(let __tmp4781 (InLoop __tmp3908 __tmp3968))
(let __tmp4782 (InLoop __tmp3829 __tmp4027))
(let __tmp4783 (InLoop __tmp4137 __tmp4186))
(let __tmp4784 (InLoop __tmp4067 __tmp4238))
(let __tmp4785 (InLoop __tmp4332 __tmp4374))
(let __tmp4786 (InLoop __tmp4271 __tmp4419))
(let __tmp4787 (InLoop __tmp4491 __tmp4521))
(let __tmp4788 (InLoop __tmp4442 __tmp4556))
(let __tmp4789 (InLoop __tmp4632 __tmp4660))
(let __tmp4790 (InLoop __tmp4715 __tmp4739))
(let __tmp4791 (InLoop __tmp4688 __tmp4764))
(let __tmp4792 (InLoop __tmp280 __tmp380))
(let __tmp4793 (InLoop __tmp170 __tmp439))
(let __tmp4794 (InLoop __tmp570 __tmp657))
(let __tmp4795 (InLoop __tmp479 __tmp709))
(let __tmp4796 (InLoop __tmp824 __tmp902))
(let __tmp4797 (InLoop __tmp742 __tmp947))
(let __tmp4798 (InLoop __tmp1035 __tmp1102))
(let __tmp4799 (InLoop __tmp970 __tmp1137))
(let __tmp4800 (InLoop __tmp2352 __tmp2381))
(let __tmp4801 (InLoop __tmp2441 __tmp2465))
(let __tmp4802 (InLoop __tmp2404 __tmp2490))
(let __tmp4803 (InLoop __tmp2557 __tmp2581))
(let __tmp4804 (InLoop __tmp2530 __tmp2606))
(let __tmp4805 (InLoop __tmp2673 __tmp2697))
(let __tmp4806 (InLoop __tmp2646 __tmp2722))
(let __tmp4807 (InLoop __tmp2789 __tmp2813))
(let __tmp4808 (InLoop __tmp2762 __tmp2838))
(let __tmp4809 (InLoop __tmp3052 __tmp3076))
(let __tmp4810 (InLoop __tmp3025 __tmp3101))
(let __tmp4811 (InLoop __tmp3206 __tmp3230))
(let __tmp4812 (InLoop __tmp3179 __tmp3255))
(let __tmp4813 (InLoop __tmp3358 __tmp3382))
(let __tmp4814 (InLoop __tmp3331 __tmp3407))
(let __tmp4815 (InLoop __tmp3511 __tmp3535))
(let __tmp4816 (InLoop __tmp3484 __tmp3560))
(FunctionHasType "main" (TupleT (TCons (StateT) (TNil))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "init" (TupleT (TCons (PointerT (FloatT)) (TCons (PointerT (FloatT)) (TCons (PointerT (FloatT)) (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (FloatT) (TCons (IntT) (TCons (FloatT) (TCons (IntT) (TCons (FloatT) (TCons (IntT) (TCons (FloatT) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil))))))))))))))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "matrix_new" (TupleT (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))) (TupleT (TCons (PointerT (FloatT)) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_loc" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))))) (TupleT (TCons (PointerT (FloatT)) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_get" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_set" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil)))))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "matrix_incr" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil)))))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "matrix_sum" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil)))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))
(FunctionHasType "fmod" (TupleT (TCons (FloatT) (TCons (FloatT) (TCons (StateT) (TNil))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))


    ; Loop context unions
    (union __tmp1218 __tmp4772)
(union __tmp1164 __tmp4773)
(union __tmp1319 __tmp4774)
(union __tmp1597 __tmp4775)
(union __tmp1543 __tmp4776)
(union __tmp1710 __tmp4777)
(union __tmp1997 __tmp4778)
(union __tmp1942 __tmp4779)
(union __tmp2113 __tmp4780)
(union __tmp2997 __tmp4781)
(union __tmp3830 __tmp4782)
(union __tmp3149 __tmp4783)
(union __tmp4068 __tmp4784)
(union __tmp3303 __tmp4785)
(union __tmp4272 __tmp4786)
(union __tmp3455 __tmp4787)
(union __tmp4443 __tmp4788)
(union __tmp4633 __tmp4789)
(union __tmp4716 __tmp4790)
(union __tmp4689 __tmp4791)
(union __tmp281 __tmp4792)
(union __tmp195 __tmp4793)
(union __tmp571 __tmp4794)
(union __tmp494 __tmp4795)
(union __tmp825 __tmp4796)
(union __tmp757 __tmp4797)
(union __tmp1036 __tmp4798)
(union __tmp980 __tmp4799)
(union __tmp2353 __tmp4800)
(union __tmp2442 __tmp4801)
(union __tmp2411 __tmp4802)
(union __tmp2558 __tmp4803)
(union __tmp2531 __tmp4804)
(union __tmp2674 __tmp4805)
(union __tmp2647 __tmp4806)
(union __tmp2790 __tmp4807)
(union __tmp2763 __tmp4808)
(union __tmp3053 __tmp4809)
(union __tmp3026 __tmp4810)
(union __tmp3207 __tmp4811)
(union __tmp3180 __tmp4812)
(union __tmp3359 __tmp4813)
(union __tmp3332 __tmp4814)
(union __tmp3512 __tmp4815)
(union __tmp3485 __tmp4816)

    ; Function inlining unions
     
(union __tmp14 __tmp22)
(InlinedCall "matrix_new" __tmp13)
(subsume (Call "matrix_new" __tmp13))


(union __tmp30 __tmp35)
(InlinedCall "matrix_new" __tmp29)
(subsume (Call "matrix_new" __tmp29))


(union __tmp43 __tmp48)
(InlinedCall "matrix_new" __tmp42)
(subsume (Call "matrix_new" __tmp42))


(union __tmp56 __tmp61)
(InlinedCall "matrix_new" __tmp55)
(subsume (Call "matrix_new" __tmp55))


(union __tmp101 __tmp1140)
(InlinedCall "init" __tmp100)
(subsume (Call "init" __tmp100))


(union __tmp1143 __tmp1148)
(InlinedCall "matrix_new" __tmp1142)
(subsume (Call "matrix_new" __tmp1142))


(union __tmp1188 __tmp1209)
(InlinedCall "matrix_set" __tmp1187)
(subsume (Call "matrix_set" __tmp1187))


(union __tmp1234 __tmp1239)
(InlinedCall "matrix_get" __tmp1233)
(subsume (Call "matrix_get" __tmp1233))


(union __tmp1252 __tmp1256)
(InlinedCall "matrix_get" __tmp1251)
(subsume (Call "matrix_get" __tmp1251))


(union __tmp1270 __tmp1294)
(InlinedCall "matrix_incr" __tmp1269)
(subsume (Call "matrix_incr" __tmp1269))


(union __tmp1523 __tmp1528)
(InlinedCall "matrix_new" __tmp1522)
(subsume (Call "matrix_new" __tmp1522))


(union __tmp1567 __tmp1587)
(InlinedCall "matrix_set" __tmp1566)
(subsume (Call "matrix_set" __tmp1566))


(union __tmp1613 __tmp1617)
(InlinedCall "matrix_get" __tmp1612)
(subsume (Call "matrix_get" __tmp1612))


(union __tmp1630 __tmp1634)
(InlinedCall "matrix_get" __tmp1629)
(subsume (Call "matrix_get" __tmp1629))


(union __tmp1648 __tmp1672)
(InlinedCall "matrix_incr" __tmp1647)
(subsume (Call "matrix_incr" __tmp1647))


(union __tmp1920 __tmp1925)
(InlinedCall "matrix_new" __tmp1919)
(subsume (Call "matrix_new" __tmp1919))


(union __tmp1966 __tmp1986)
(InlinedCall "matrix_set" __tmp1965)
(subsume (Call "matrix_set" __tmp1965))


(union __tmp2013 __tmp2017)
(InlinedCall "matrix_get" __tmp2012)
(subsume (Call "matrix_get" __tmp2012))


(union __tmp2030 __tmp2034)
(InlinedCall "matrix_get" __tmp2029)
(subsume (Call "matrix_get" __tmp2029))


(union __tmp2048 __tmp2072)
(InlinedCall "matrix_incr" __tmp2047)
(subsume (Call "matrix_incr" __tmp2047))


(union __tmp2330 __tmp2390)
(InlinedCall "matrix_sum" __tmp2329)
(subsume (Call "matrix_sum" __tmp2329))


(union __tmp306 __tmp2496)
(InlinedCall "fmod" __tmp305)
(subsume (Call "fmod" __tmp305))


(union __tmp319 __tmp2516)
(InlinedCall "matrix_set" __tmp318)
(subsume (Call "matrix_set" __tmp318))


(union __tmp595 __tmp2612)
(InlinedCall "fmod" __tmp594)
(subsume (Call "fmod" __tmp594))


(union __tmp608 __tmp2632)
(InlinedCall "matrix_set" __tmp607)
(subsume (Call "matrix_set" __tmp607))


(union __tmp847 __tmp2728)
(InlinedCall "fmod" __tmp846)
(subsume (Call "fmod" __tmp846))


(union __tmp860 __tmp2748)
(InlinedCall "matrix_set" __tmp859)
(subsume (Call "matrix_set" __tmp859))


(union __tmp1059 __tmp2844)
(InlinedCall "fmod" __tmp1058)
(subsume (Call "fmod" __tmp1058))


(union __tmp1072 __tmp2864)
(InlinedCall "matrix_set" __tmp1071)
(subsume (Call "matrix_set" __tmp1071))


(union __tmp1204 __tmp2875)
(InlinedCall "matrix_loc" __tmp1203)
(subsume (Call "matrix_loc" __tmp1203))


(union __tmp1236 __tmp2886)
(InlinedCall "matrix_loc" __tmp1233)
(subsume (Call "matrix_loc" __tmp1233))


(union __tmp1253 __tmp2897)
(InlinedCall "matrix_loc" __tmp1251)
(subsume (Call "matrix_loc" __tmp1251))


(union __tmp1285 __tmp2908)
(InlinedCall "matrix_loc" __tmp1284)
(subsume (Call "matrix_loc" __tmp1284))


(union __tmp1582 __tmp2919)
(InlinedCall "matrix_loc" __tmp1581)
(subsume (Call "matrix_loc" __tmp1581))


(union __tmp1614 __tmp2930)
(InlinedCall "matrix_loc" __tmp1612)
(subsume (Call "matrix_loc" __tmp1612))


(union __tmp1631 __tmp2941)
(InlinedCall "matrix_loc" __tmp1629)
(subsume (Call "matrix_loc" __tmp1629))


(union __tmp1663 __tmp2952)
(InlinedCall "matrix_loc" __tmp1662)
(subsume (Call "matrix_loc" __tmp1662))


(union __tmp1981 __tmp2963)
(InlinedCall "matrix_loc" __tmp1980)
(subsume (Call "matrix_loc" __tmp1980))


(union __tmp2014 __tmp2974)
(InlinedCall "matrix_loc" __tmp2012)
(subsume (Call "matrix_loc" __tmp2012))


(union __tmp2031 __tmp2985)
(InlinedCall "matrix_loc" __tmp2029)
(subsume (Call "matrix_loc" __tmp2029))


(union __tmp2063 __tmp2996)
(InlinedCall "matrix_loc" __tmp2062)
(subsume (Call "matrix_loc" __tmp2062))


(union __tmp3011 __tmp3107)
(InlinedCall "fmod" __tmp3010)
(subsume (Call "fmod" __tmp3010))


(union __tmp3128 __tmp3148)
(InlinedCall "matrix_set" __tmp3127)
(subsume (Call "matrix_set" __tmp3127))


(union __tmp3165 __tmp3261)
(InlinedCall "fmod" __tmp3164)
(subsume (Call "fmod" __tmp3164))


(union __tmp3282 __tmp3302)
(InlinedCall "matrix_set" __tmp3281)
(subsume (Call "matrix_set" __tmp3281))


(union __tmp3317 __tmp3413)
(InlinedCall "fmod" __tmp3316)
(subsume (Call "fmod" __tmp3316))


(union __tmp3434 __tmp3454)
(InlinedCall "matrix_set" __tmp3433)
(subsume (Call "matrix_set" __tmp3433))


(union __tmp3470 __tmp3566)
(InlinedCall "fmod" __tmp3469)
(subsume (Call "fmod" __tmp3469))


(union __tmp3587 __tmp3607)
(InlinedCall "matrix_set" __tmp3586)
(subsume (Call "matrix_set" __tmp3586))


(union __tmp3143 __tmp3618)
(InlinedCall "matrix_loc" __tmp3142)
(subsume (Call "matrix_loc" __tmp3142))


(union __tmp3297 __tmp3629)
(InlinedCall "matrix_loc" __tmp3296)
(subsume (Call "matrix_loc" __tmp3296))


(union __tmp3449 __tmp3640)
(InlinedCall "matrix_loc" __tmp3448)
(subsume (Call "matrix_loc" __tmp3448))


(union __tmp3602 __tmp3651)
(InlinedCall "matrix_loc" __tmp3601)
(subsume (Call "matrix_loc" __tmp3601))


(union __tmp3659 __tmp3670)
(InlinedCall "matrix_loc" __tmp3658)
(subsume (Call "matrix_loc" __tmp3658))


(union __tmp3693 __tmp3704)
(InlinedCall "matrix_loc" __tmp3692)
(subsume (Call "matrix_loc" __tmp3692))


(union __tmp3721 __tmp3732)
(InlinedCall "matrix_loc" __tmp3720)
(subsume (Call "matrix_loc" __tmp3720))

) :ruleset initialization)
(run initialization 1) 

; Schedule

(run-schedule
    (saturate
      
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

      passthrough
      state-edge-passthrough)
    (repeat 2
        
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

        all-optimizations
    )

    (repeat 4
        
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

        cheap-optimizations
    )

    (saturate
      
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

      passthrough
      state-edge-passthrough)
    add-to-debug-expr
)

(print-size)

