
; Prologue
; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

; use TmpType for helpers where the type doesn't matter
; these shouldn't appear in values in the program, only intermediate terms (such as in ivt.egg permutations)
(constructor TmpType () Type)

(constructor TNil () TypeList)
(constructor TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Assumptions
; =================================

(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf bool Expr Expr)
)



; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(constructor Arg (Type Assumption) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool)
  (Float f64))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(constructor Const (Constant Type Assumption) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(constructor Empty (Type Assumption) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write)
  (Select))
(datatype BinaryOp
  ;; Bitwise operators
  (Bitand)
  ;; integer operators
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (Smin)
  (Smax)
  (Shl)
  (Shr)
  ;; float operators 
  (FAdd)
  (FSub)
  (FDiv)
  (FMul)
  (FLessThan)
  (FGreaterThan) 
  (FLessEq)
  (FGreaterEq)
  (FEq)
  (Fmin)
  (Fmax)
  ;; logical operators
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Neg)
  (Abs)
  (Not))

; Operators
(constructor Top   (TernaryOp Expr Expr Expr) Expr)
(constructor Bop   (BinaryOp Expr Expr) Expr)
(constructor Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(constructor Get   (Expr i64) Expr)
; (Alloc id amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns (pointer to the allocated memory, state edge)
(constructor Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(constructor Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(constructor Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 expr1       expr2
(constructor Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; pred must be an integer
;                 pred  inputs   branches     chosen
(constructor Switch (Expr  Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred inputs   then else
(constructor If (Expr Expr     Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple 
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(constructor DoWhile (Expr    Expr)                   Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(constructor Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(constructor Function (String Type      Type       Expr)      Expr)

; to get the type of a funciton, look in this table
; since we might not be optimizing the entire program
(relation FunctionHasType (String Type Type))

; Rulesets
(ruleset always-run)
(ruleset is-resolved)
(ruleset error-checking)
(ruleset memory)
(ruleset memory-helpers)
(ruleset smem)

;; Initliazation
(relation bop->string (BinaryOp String))
(relation uop->string (UnaryOp String))
(relation top->string (TernaryOp String))
(bop->string (Add) "Add")
(bop->string (Sub) "Sub")
(bop->string (Div) "Div")
(bop->string (Mul) "Mul")
(bop->string (LessThan) "LessThan")
(bop->string (GreaterThan) "GreaterThan")
(bop->string (LessEq) "LessEq")
(bop->string (GreaterEq) "GreaterEq")
(bop->string (Eq) "Eq")
(bop->string (FAdd) "FAdd")
(bop->string (FSub) "FSub")
(bop->string (FDiv) "FDiv")
(bop->string (FMul) "FMul")
(bop->string (FLessThan) "FLessThan")
(bop->string (FGreaterThan) "FGreaterThan")
(bop->string (FLessEq) "FLessEq")
(bop->string (FGreaterEq) "FGreaterEq")
(bop->string (FEq) "FEq")
(bop->string (And) "And")
(bop->string (Or) "Or")
(bop->string (Load) "Load")
(bop->string (PtrAdd) "PtrAdd")
(bop->string (Print) "Print")
(bop->string (Free) "Free")

;; If anything is put in the DebugExpr relation, we'll extract them instead of the original program.
;; These can then be visualized using the `optimized-rvsdg` run mode
(relation DebugExpr (Expr))

; TERMS
(datatype Term)
(datatype ListTerm (TermCons Term ListTerm) (TermNil))

; TODO: Will probably need ctx so that we can resubstitute?
; (datatype TermAssumption
;   ; Assume nothing
;   (InFunc String)
;   ; The term is in a loop with `input` and `pred_output`.
;   ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
;   ;      input    pred_output
;   (InLoop Term     Term)
;   ; Branch of the switch, and what the predicate is, and what the input is
;   (InSwitch i64 Term Term)
;   ; If the predicate was true, and what the predicate is, and what the input is
;   (InIf bool Term Term)
; )

(constructor TermArg () Term)

(constructor TermConst (Constant) Term)

(constructor TermEmpty () Term)

; Term Operators
(constructor TermTop (TernaryOp Term Term Term) Term)
(constructor TermBop (BinaryOp Term Term) Term)
(constructor TermUop (UnaryOp Term) Term)
(constructor TermGet (Term i64) Term)
(constructor TermAlloc (i64 Term Term BaseType) Term)
(constructor TermCall (String Term) Term)

; Tuple Operators
(constructor TermSingle (Term) Term)
(constructor TermConcat (Term Term) Term)

; Control Flow (TODO? Not sure if needed)
; (constructor TermSwitch (Term Term ListTerm) Term)
; (constructor TermIf (Term Term Term Term) Term)

; (constructor TermDoWhile (Term Term) Term)


(ruleset never)
(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(constructor TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64 :no-merge)
(constructor TypeList-ith (TypeList i64) BaseType :unextractable)
;; Don't match on TypeList-ith because it is now lazily instantiated!
(rule () ((set (TypeList-length (TNil)) 0)) :ruleset type-helpers)
(rule ((= lst (TCons hd tl))
       (= len (TypeList-length tl)))
      ((set (TypeList-length lst) (+ 1 len))) :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) 0) hd :ruleset type-helpers)
(rewrite (TypeList-ith (TCons hd tl) i) (TypeList-ith tl (- i 1)) 
      :when ((> i 0)) 
      :ruleset type-helpers)

(rule ((TypeList-ith list i)
       (= (TypeList-length list) n)
       (>= i n))
      ((panic "TypeList-ith out of bounds")) :ruleset type-helpers)

(relation HasType (Expr Type))


;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      (
       (panic "type mismatch- check RUST_LOG=info for expressions that mismatched"))
      :ruleset error-checking)


(rule ((= (Const c1 ty1 ctx1) (Const c2 ty2 ctx2))
       (= ctx1 (InFunc name))
       (!= c1 c2))
      ((panic "Unsoundness detected: const values differ at top level"))
      :ruleset error-checking)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1 ctx) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset error-checking)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset error-checking)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType branch ty)
       (HasType inputs ty2)
       (!= ty ty2))
      ((panic "switch branches then branch has incorrect input type"))
      :ruleset error-checking)
;; demand with one fewer branches
(rule ((= lhs (Switch pred inputs (Cons branch rest))))
      ((Switch pred inputs rest))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType t ty2)
       (!= ty ty2))
      ((panic "if branches then branch has incorrect input type"))
      :ruleset error-checking)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType e ty2)
       (!= ty ty2))
      ((panic "if branches else branch has incorrect input type"))
      :ruleset error-checking)


(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty ctx)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty ctx)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Float b) ty ctx)))
      ((HasType lhs (Base (FloatT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty ctx)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not)"))
      :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
      (HasType e (Base (IntT)))
) (
      (HasType lhs (Base (IntT)))
) :ruleset type-analysis)

(rule (
      (= lhs (Uop (Neg) e))
) (
      (ExpectType e (Base (IntT)) "(Neg)")
) :ruleset type-analysis)

(rule (
        (= lhs (Uop (Abs) e))
        (HasType e (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Abs) e)))
      ((ExpectType e (Base (IntT)) "(Abs)"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset error-checking)

(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset error-checking)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset error-checking)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Top (Select) pred v1 v2))
      )
      ((ExpectType pred (Base (BoolT)) "(Select)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty)
        (HasType v2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Select) pred v1 v2))
        (HasType v1 ty1)
        (HasType v2 ty2)
        (!= ty1 ty2)
      )
      ((panic "(Select) branches had different types"))
      :ruleset error-checking)


; Binary ops

;; Operators that have type Type -> Type -> Type
;; Note we only do this generic matching for binary
;; operator since there's a lot of them.
;; In the future we can also extend to other constructs.
(relation bop-of-type (BinaryOp Type))
(bop-of-type (Bitand) (Base (IntT)))
(bop-of-type (Add) (Base (IntT)))
(bop-of-type (Sub) (Base (IntT)))
(bop-of-type (Div) (Base (IntT)))
(bop-of-type (Mul) (Base (IntT)))
(bop-of-type (FAdd) (Base (FloatT)))
(bop-of-type (FSub) (Base (FloatT)))
(bop-of-type (FDiv) (Base (FloatT)))
(bop-of-type (FMul) (Base (FloatT)))

(rule (
        (= lhs (Bop op e1 e2))
        (bop-of-type op ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop op e1 e2))
       (bop-of-type op ty)
       (bop->string op op-str))
      (
        (ExpectType e1 ty op-str)
        (ExpectType e2 ty op-str)
      )
      :ruleset type-analysis)  

;; Operators that have type Float -> Float -> Bool
(relation bpred-of-type (BinaryOp Type))
(bpred-of-type (FLessThan) (Base (FloatT)))
(bpred-of-type (FLessEq) (Base (FloatT)))
(bpred-of-type (FGreaterThan) (Base (FloatT)))
(bpred-of-type (FGreaterEq) (Base (FloatT)))
(bpred-of-type (FEq) (Base (FloatT)))
(bpred-of-type (LessThan) (Base (IntT)))
(bpred-of-type (LessEq) (Base (IntT)))
(bpred-of-type (GreaterThan) (Base (IntT)))
(bpred-of-type (GreaterEq) (Base (IntT)))
(bpred-of-type (Eq) (Base (IntT)))
(bpred-of-type (And) (Base (BoolT)))
(bpred-of-type (Or) (Base (BoolT)))

(rule (
        (= lhs (Bop pred e1 e2))
        (bpred-of-type pred ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop pred e1 e2))
       (bpred-of-type pred ty)
       (bop->string pred pred-str))
      (
        (ExpectType e1 ty pred-str)
        (ExpectType e2 ty pred-str)
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base ty)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write)"))
      :ruleset type-analysis)
      
       

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i)))) 
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset error-checking)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset error-checking)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset error-checking)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred inputs then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset error-checking)



(rule ((= lhs (Switch pred inputs branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred inputs (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred inputs (Cons branch rest)))
      ((Switch pred inputs rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred inputs rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred inputs rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset error-checking)

(rule ((Arg ty ctx))
      (
        (HasType (Arg ty ctx) ty)
        (HasArgType (Arg ty ctx) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset error-checking)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (FunctionHasType name in-ty out-ty)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; find which types are pure
(relation PureBaseType (BaseType))
(relation PureType (Type))
(relation PureTypeList (TypeList))

(PureBaseType (IntT))
(PureBaseType (BoolT))
(rule ((Base ty)
       (PureBaseType ty))
      ((PureType (Base ty)))
      :ruleset type-analysis)
(rule ((TupleT tylist)
       (PureTypeList tylist))
      ((PureType (TupleT tylist)))
      :ruleset type-analysis)
(rule ((TNil))
      ((PureTypeList (TNil)))
      :ruleset type-analysis)
(rule ((TCons hd tl)
       (PureBaseType hd)
       (PureTypeList tl))
      ((PureTypeList (TCons hd tl)))
      :ruleset type-analysis)

(function ListExpr-length (ListExpr) i64 :no-merge)
(constructor ListExpr-ith (ListExpr i64) Expr :unextractable)
(constructor ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(constructor Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred inputs branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :no-merge)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)


;; Leading expressions are tuples that are used as a whole
;; during optimization and are matched in the query.
(relation leading-Expr (Expr))
(relation leading-Expr-list (ListExpr))

(rule ((= e (DoWhile inputs pred_out)))
      ((leading-Expr e)
       (leading-Expr inputs)
       (leading-Expr pred_out))
      :ruleset always-run)
(rule ((= e (If cond inputs thn els)))
       ((leading-Expr e)
        (leading-Expr inputs)
        (leading-Expr thn)
        (leading-Expr els))
       :ruleset always-run)
(rule ((= e (Switch pred inputs branch)))
      ((leading-Expr e)
       (leading-Expr-list branch)
       (leading-Expr inputs))
       :ruleset always-run)
(rule ((leading-Expr-list (Cons hd tl)))
      ((leading-Expr hd)
       (leading-Expr-list tl))
      :ruleset always-run)
(rule ((= e (Arg t a)))
      ((leading-Expr e))
      :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((leading-Expr tuple)
       (> (tuple-length tuple) 0))
      ((Get tuple 0))
      :ruleset always-run)
;; next get
(rule ((leading-Expr tuple)
       (= len (tuple-length tuple))
       (= ith (Get tuple i))
       (< (+ i 1) len)
       )
       ((Get tuple (+ 1 i)))
       :ruleset always-run)

(constructor List-suffix (Expr i64) Expr)
(rule ((Get x i))
      ((union (List-suffix x 0) x))
      :ruleset always-run)
(rule ((= (List-suffix x n) (Concat (Single hd) tl)))
      ((union (List-suffix x (+ n 1)) tl))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Concat (Single e) rest)))
      ((union lhs e))
      :ruleset always-run)
(rule ((= lhs (Get x i))
       (= (List-suffix x i) (Single e)))
      ((union lhs e))
      :ruleset always-run)

;; A temporary context.
;; Be sure to delete at the end of all actions or else!!!
;; This is safer than using a persistant context, since we may miss an important part of the query.
(constructor TmpCtx () Assumption)

(rule ((TmpCtx))
  ((panic "TmpCtx should not exist outside rule body"))
  :ruleset always-run)


(ruleset subsume-after-helpers)
;; After running the `saturating` ruleset, these if statements can be subsumed
(relation ToSubsumeIf (Expr Expr Expr Expr))
;; Workaround of https://github.com/egraphs-good/egglog/issues/462
;; Make sure the if we are subsuming is present
(rule ((ToSubsumeIf a b c d)
       (If a b c d))
      ((subsume (If a b c d)))
      :ruleset subsume-after-helpers)

(ruleset add-to-debug-expr)

(ruleset terms)
;; helpers keeps track of the new best extracted terms
(ruleset terms-helpers)
;; helpers-helpers runs `Smaller` rules, resolving the merge function for helpers
(ruleset terms-helpers-helpers)

(sort TermAndCost)
(constructor Smaller (TermAndCost TermAndCost) TermAndCost)

(function ExtractedExpr (Expr) TermAndCost
  :merge (Smaller old new))
;; potential extractions- use so that when the costs are equal, we don't change the term
;; this preserves egglog's timestamp of when the last time ExtractedExpr was changed, fixing a big performance problem
(relation PotentialExtractedExpr (Expr TermAndCost))

(constructor TCPair (Term i64) TermAndCost)

(constructor NoTerm () Term)

;; set extracted expr to default value
(rule ((PotentialExtractedExpr expr termandcost))
      ((set (ExtractedExpr expr) (TCPair (NoTerm) 10000000000000000)))
      :ruleset terms-helpers)

;; set extracted expr to new value as long as not equal
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (= (ExtractedExpr expr) (TCPair oldterm oldcost))
       (< cost oldcost))
      ((set (ExtractedExpr expr) (TCPair term cost)))
      :ruleset terms-helpers)

;; if the cost is negative panic, terms got too big
(rule ((PotentialExtractedExpr expr (TCPair term cost))
       (< cost 0))
      ((panic "Negative cost"))
      :ruleset terms-helpers)

;; Resolve Smaller
(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (< cost1 cost2)
      )
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)

(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (> cost1 cost2) 
      )
      ((union lhs (TCPair t2 cost2)))
      :ruleset terms-helpers-helpers)


(rule (
        (= lhs (Smaller (TCPair t1 cost1) (TCPair t2 cost2)))
        (= cost1 cost2) 
      )
      ;; arbitrarily pick first one
      ((union lhs (TCPair t1 cost1)))
      :ruleset terms-helpers-helpers)


; Compute smallest Expr bottom-up
(rule ((= lhs (Const c ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermConst c) 1)))
      :ruleset terms)

(rule ((= lhs (Arg ty ass)))
      ((PotentialExtractedExpr lhs (TCPair (TermArg) 1)))
      :ruleset terms)

(rule (
        (= lhs (Bop o e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermBop o t1 t2) (+ 1 (+ c1 c2)))))
      :ruleset terms)

(rule (
        (= lhs (Top o e1 e2 e3))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (= (TCPair t3 c3) (ExtractedExpr e3))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermTop o t1 t2 t3) (+ (+ 1 c1) (+ c2 c3)))))
      :ruleset terms)

(rule (
        (= lhs (Uop o e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ((PotentialExtractedExpr lhs (TCPair (TermUop o t1) (+ 1 c1))))
      :ruleset terms)

(rule (
        (= lhs (Get tup i))
        (= (TCPair t1 c1) (ExtractedExpr tup))
      )
      ; cost of the get is the same as the  cost of the whole tuple
      ((PotentialExtractedExpr lhs (TCPair (TermGet t1 i) c1)))
      :ruleset terms)

; todo Alloc

; todo Call

(rule (
        (= lhs (Single e1))
        (= (TCPair t1 c1) (ExtractedExpr e1))
      )
      ; cost of single is same as cost of the element
      ((PotentialExtractedExpr lhs (TCPair (TermSingle t1) c1)))
      :ruleset terms)

(rule (
        (= lhs (Concat e1 e2))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t2 c2) (ExtractedExpr e2))
      )
      ; cost of concat is sum of the costs
      ((PotentialExtractedExpr lhs (TCPair (TermConcat t1 t2) (+ c1 c2))))
      :ruleset terms)


; todo Control flow - not sure if needed
; (rule (
;         (= lhs (If pred inputs thn els))
;         (= (TCPair t1 c1) (ExtractedExpr pred))
;         (= (TCPair t2 c2) (ExtractedExpr inputs))
;         (= (TCPair t3 c3) (ExtractedExpr thn))
;         (= (TCPair t4 c4) (ExtractedExpr els))
;       )
;       ; cost of if is 10 + cost of pred + cost of input + max of branch costs
;       ((PotentialExtractedExpr lhs (TCPair (TermIf t1 t2 t3 t4) (+ 10 (+ (+ c1 c2) (max c3 c4))))))
;       :ruleset terms)

(sort Node)
;; store a particular if node for later
;; stored as the if eclass, pred, inputs, then, else
(constructor IfNode (Expr Expr Expr Expr Expr) Node)

(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Function _name _tyin _tyout _out))) ((ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Top _op _x _y _z))) ((ExprIsValid _x)
(ExprIsValid _y)
(ExprIsValid _z)) :ruleset always-run)
(rule ((ExprIsValid (Bop _op _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Uop _op _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Concat _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Single _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _inputs _branches))) ((ExprIsValid _pred)
(ExprIsValid _inputs)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (If _pred _input _then _else))) ((ExprIsValid _pred)
(ExprIsValid _input)
(ExprIsValid _then)
(ExprIsValid _else)) :ruleset always-run)
(rule ((ExprIsValid (DoWhile _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Call _func _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(rule ((ExprIsValid (Alloc _id _e _state _ty))) ((ExprIsValid _e)
(ExprIsValid _state)) :ruleset always-run)
(relation ExprIsResolved (Expr))
(relation ListExprIsResolved (ListExpr))
(rule ((= lhs (Function _name _tyin _tyout _out)) (ExprIsResolved _out)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Const _n _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Top _op _x _y _z)) (ExprIsResolved _x)
(ExprIsResolved _y)
(ExprIsResolved _z)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Bop _op _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Uop _op _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Get _tup _i)) (ExprIsResolved _tup)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Concat _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Single _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Switch _pred _inputs _branches)) (ExprIsResolved _pred)
(ExprIsResolved _inputs)
(ListExprIsResolved _branches)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (If _pred _input _then _else)) (ExprIsResolved _pred)
(ExprIsResolved _input)
(ExprIsResolved _then)
(ExprIsResolved _else)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (DoWhile _in _pred-and-output)) (ExprIsResolved _in)
(ExprIsResolved _pred-and-output)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Arg _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Call _func _arg)) (ExprIsResolved _arg)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Empty _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Cons _hd _tl)) (ExprIsResolved _hd)
(ListExprIsResolved _tl)) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Nil)) ) ((ListExprIsResolved lhs)) :ruleset is-resolved)
(rule ((= lhs (Alloc _id _e _state _ty)) (ExprIsResolved _e)
(ExprIsResolved _state)) ((ExprIsResolved lhs)) :ruleset is-resolved)
(relation BodyContainsExpr (Expr Expr))
(relation BodyContainsListExpr (Expr ListExpr))
(rule ((Function _name _tyin _tyout _out)) ((BodyContainsExpr (Function _name _tyin _tyout _out) _out)) :ruleset always-run)
(rule ((If _pred _input _then _else)) ((BodyContainsExpr (If _pred _input _then _else) _then) (BodyContainsExpr (If _pred _input _then _else) _else)) :ruleset always-run)
(rule ((DoWhile _in _pred-and-output)) ((BodyContainsExpr (DoWhile _in _pred-and-output) _pred-and-output)) :ruleset always-run)
(rule ((BodyContainsExpr body (Top _op _x _y _z))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y) (BodyContainsExpr body _z)) :ruleset always-run)
(rule ((BodyContainsExpr body (Bop _op _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Uop _op _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Get _tup _i))) ((BodyContainsExpr body _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body (Concat _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Single _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Switch _pred _inputs _branches))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _inputs)) :ruleset always-run)
(rule ((BodyContainsExpr body (If _pred _input _then _else))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _input)) :ruleset always-run)
(rule ((BodyContainsExpr body (DoWhile _in _pred-and-output))) ((BodyContainsExpr body _in)) :ruleset always-run)
(rule ((BodyContainsExpr body (Call _func _arg))) ((BodyContainsExpr body _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body (Cons _hd _tl))) ((BodyContainsExpr body _hd)) :ruleset always-run)
(rule ((BodyContainsExpr body (Alloc _id _e _state _ty))) ((BodyContainsExpr body _e) (BodyContainsExpr body _state)) :ruleset always-run)
(relation ExprIsPure (Expr))
(relation ListExprIsPure (ListExpr))
(relation BinaryOpIsPure (BinaryOp))
(relation UnaryOpIsPure (UnaryOp))
(relation TernaryOpIsPure (TernaryOp))
(TernaryOpIsPure (Select))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (Smax))
(BinaryOpIsPure (Smin))
(BinaryOpIsPure (Shl))
(BinaryOpIsPure (Shr))
(BinaryOpIsPure (FAdd))
(BinaryOpIsPure (FSub))
(BinaryOpIsPure (FMul))
(BinaryOpIsPure (FDiv))
(BinaryOpIsPure (FEq))
(BinaryOpIsPure (FLessThan))
(BinaryOpIsPure (FGreaterThan))
(BinaryOpIsPure (FLessEq))
(BinaryOpIsPure (FGreaterEq))
(BinaryOpIsPure (Fmax))
(BinaryOpIsPure (Fmin))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(BinaryOpIsPure (Bitand))
(UnaryOpIsPure (Not))
(UnaryOpIsPure (Abs))
(UnaryOpIsPure (Neg))

(rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
        ((ExprIsPure (Function _name _tyin _tyout _out)))
        :ruleset always-run)

(rule ((Const _n _ty _ctx))
        ((ExprIsPure (Const _n _ty _ctx)))
        :ruleset always-run)

(rule ((Top _op _x _y _z) (TernaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
        ((ExprIsPure (Top _op _x _y _z)))
        :ruleset always-run)

(rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Bop _op _x _y)))
        :ruleset always-run)

(rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
        ((ExprIsPure (Uop _op _x)))
        :ruleset always-run)

(rule ((Get _tup _i) (ExprIsPure _tup))
        ((ExprIsPure (Get _tup _i)))
        :ruleset always-run)

(rule (
        (= lhs (Get (Arg (TupleT tylist) _ctx) i))
        (!= (TypeList-ith tylist i) (StateT))
      )
      ((ExprIsPure lhs))
      :ruleset always-run)

(rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
        ((ExprIsPure (Concat _x _y)))
        :ruleset always-run)

(rule ((Single _x) (ExprIsPure _x))
        ((ExprIsPure (Single _x)))
        :ruleset always-run)

(rule ((Switch _pred _inputs _branches) (ExprIsPure _pred) (ExprIsPure _inputs) (ListExprIsPure _branches))
        ((ExprIsPure (Switch _pred _inputs _branches)))
        :ruleset always-run)

(rule ((If _pred _input _then _else) (ExprIsPure _pred) (ExprIsPure _input) (ExprIsPure _then) (ExprIsPure _else))
        ((ExprIsPure (If _pred _input _then _else)))
        :ruleset always-run)

(rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
        ((ExprIsPure (DoWhile _in _pred-and-output)))
        :ruleset always-run)

; state edge is not pure!
; (rule ((Arg _ty _ctx))
;         ((ExprIsPure (Arg _ty _ctx)))
;         :ruleset always-run)

(rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
        ((ExprIsPure (Call _f _arg)))
        :ruleset always-run)

(rule ((Empty _ty _ctx))
        ((ExprIsPure (Empty _ty _ctx)))
        :ruleset always-run)

(rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
        ((ListExprIsPure (Cons _hd _tl)))
        :ruleset always-run)

(rule ((Nil))
        ((ListExprIsPure (Nil)))
        :ruleset always-run)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)

(constructor AddContext (Assumption Expr) Expr :unextractable)
(constructor AddContextList (Assumption ListExpr) ListExpr :unextractable)

;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (AddContext ctx inner))
   (= inner (AddContext ctx expr)))
  ((union lhs inner))
  :ruleset context)


;; ############################## Base cases- leaf nodes

;; replace existing contexts that are around leaf nodes
;; AddContext assumes the new context is more specific than the old one
(rule ((= lhs (AddContext ctx (Arg ty oldctx))))
      ((union lhs (Arg ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Const c ty oldctx))))
      ((union lhs (Const c ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Empty ty oldctx))))
      ((union lhs (Empty ty ctx)))
      :ruleset context)




;; ######################################### Operators
(rewrite (AddContext ctx (Top op c1 c2 c3))
         (Top op
           (AddContext ctx c1)
           (AddContext ctx c2)
           (AddContext ctx c3))
               :ruleset context)
(rewrite (AddContext ctx (Bop op c1 c2))
         (Bop op
           (AddContext ctx c1)
           (AddContext ctx c2))
               :ruleset context)
(rewrite (AddContext ctx (Uop op c1))
         (Uop op (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Get c1 index))
         (Get (AddContext ctx c1) index)
               :ruleset context)
(rewrite (AddContext ctx (Alloc id c1 state ty))
         (Alloc id (AddContext ctx c1) (AddContext ctx state) ty)
         :ruleset context)
(rewrite (AddContext ctx (Call name c1))
         (Call name (AddContext ctx c1))
         :ruleset context)

(rewrite (AddContext ctx (Single c1))
         (Single (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Concat c1 c2))
         (Concat
           (AddContext ctx c1)
           (AddContext ctx c2))
         :ruleset context)

;; ################################### List operators

(rewrite (AddContextList ctx (Nil))
         (Nil)
         :ruleset context)

(rewrite (AddContextList ctx (Cons c1 rest))
         (Cons (AddContext ctx c1)
               (AddContextList ctx rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (AddContext ctx (Switch pred inputs branches))
         (Switch (AddContext ctx pred)
                 (AddContext ctx inputs)
                 branches)
         :ruleset context)

;; For stop at region, still add context to inputs
(rule ((= lhs (AddContext ctx (If pred inputs c1 c2))))
      ((union lhs
         (If (AddContext ctx pred)
             (AddContext ctx inputs)
             c1
             c2)))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (AddContext ctx (DoWhile inputs outputs))))
      ((union lhs
        (DoWhile
          (AddContext ctx inputs)
          outputs)))
       :ruleset context)


(ruleset term-subst)


; Instantiate the term as an Expr in the provided context
; where references to (Arg) in the term are replaced by Expr
(constructor TermSubst (Assumption Expr Term) Expr :unextractable)

; type rule to get the arg type of a substitution
(rule (
        (= lhs (TermSubst ctx e1 term))
        (HasArgType e1 ty)       
      )
      ((HasArgType lhs ty))
      :ruleset term-subst)


; leaf node
; replace the context
(rule ((= lhs (TermSubst ctx e (TermArg))))
      ((union lhs (AddContext ctx e)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConst c)))
       (HasArgType e newty))
      ((union lhs (Const c newty ctx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermEmpty)))
       (HasArgType e newty))
      ((union lhs (Empty newty ctx)))
      :ruleset term-subst)

; Operators
(rule ((= lhs (TermSubst ctx e (TermTop op t1 t2 t3))))
      ((union lhs (Top op (TermSubst ctx e t1)
                          (TermSubst ctx e t2)
                          (TermSubst ctx e t3))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermBop op t1 t2))))
      ((union lhs (Bop op (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermUop op t1))))
      ((union lhs (Uop op (TermSubst ctx e t1))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermGet t idx))))
      ((union lhs (Get (TermSubst ctx e t) idx)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermAlloc id t1 t2 ty))))
      ((union lhs (Alloc id (TermSubst ctx e t1)
                            (TermSubst ctx e t2)
                            ty)))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermCall name t))))
      ((union lhs (Call name (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermSingle t))))
      ((union lhs (Single (TermSubst ctx e t))))
      :ruleset term-subst)

(rule ((= lhs (TermSubst ctx e (TermConcat t1 t2))))
      ((union lhs (Concat (TermSubst ctx e t1)
                          (TermSubst ctx e t2))))
      :ruleset term-subst)

; Control Flow
; TODO
;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(constructor Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(constructor DelayedSubstUnion (Expr Expr) Expr :unextractable)

;; add a type rule to get the arg type of a substitution
;; this enables nested substitutions
(rule ((= lhs (Subst assum to in))
       (HasArgType to ty))
      ((HasArgType lhs ty))
      :ruleset subst)

;; Substitution typechecks only when the type of the
;; argument matches the type of the substitution.
(rule ((Subst assum to in)
       (HasArgType in ty)
       (HasType to ty2)
       (!= ty ty2)
       ;; tmptype disables typechecking
       (!= ty (TmpType))
       (!= ty2 (TmpType)))
      (
       (panic "Substitution type mismatch! Argument type must match type of substituted term"))
       :ruleset subst)


;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to e))
       (= e (Arg _ty _oldctx))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Const c _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Const c newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)
(rule ((= lhs (Subst assum to e))
       (= e (Empty _ty _oldctx))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Empty newty assum))
      (subsume (Subst assum to e)))
      :ruleset subst)

;; Operators
(rule ((= e (Top op c1 c2 c3))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Top op (Subst assum to c1)
                 (Subst assum to c2)
                 (Subst assum to c3)))
       (subsume (Subst assum to e)))
         :ruleset subst)

(rule ((= e (Bop op c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Bop op (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Uop op c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Uop op (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)    

(rule ((= e (Get c1 index))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Get (Subst assum to c1) index))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Alloc id c1 c2 ty))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Alloc id (Subst assum to c1)
                   (Subst assum to c2)
                   ty))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Call name c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Call name (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)


;; Tuple operators
(rule ((= e (Single c1))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Single (Subst assum to c1)))
       (subsume (Subst assum to e)))
         :ruleset subst)
(rule ((= e (Concat c1 c2))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (Concat (Subst assum to c1)
                 (Subst assum to c2)))
       (subsume (Subst assum to e)))
         :ruleset subst)

;; Control flow
(rule ((= lhs (Subst assum to inner))
       (= inner (Switch pred inputs c1))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 c1))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= lhs (Subst assum to inner))
       (= inner (If pred inputs c1 c2))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2))
       (subsume (Subst assum to inner)))
         :ruleset subst)
(rule ((= e (DoWhile in out))
       (= lhs (Subst assum to e))
       (ExprIsResolved e)
       (ExprIsResolved to))
      ((DelayedSubstUnion lhs
         (DoWhile (Subst assum to in)
                  out))
       (subsume (Subst assum to e)))
      :ruleset subst)

;; substitute into function (convenience for testing)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :when ((ExprIsResolved body))
         :ruleset subst)



;; ########################### Apply subst unions

(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)

; We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

(rule ((Arg ty ctx))
      ((ContextOf (Arg ty ctx) ctx))
      :ruleset always-run)
(rule ((Const c ty ctx))
      ((ContextOf (Const c ty ctx) ctx))
      :ruleset always-run)
(rule ((Empty ty ctx))
      ((ContextOf (Empty ty ctx) ctx))
        :ruleset always-run)

; Error checking - each expr should only have a single context
(rule ((ContextOf x ctx1)
       (ContextOf x ctx2)
       (!= ctx1 ctx2))
     (
         (panic "Equivalent expressions have nonequivalent context, breaking the single context invariant.")
     )
     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred inputs branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred inputs branches) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf pred ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((If pred inputs then else) (ContextOf inputs ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run) 

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(ruleset canon)

; Commutativity
(rewrite (Bop (Add) x y) (Bop (Add) y x) :ruleset canon)
(rewrite (Bop (Mul) x y) (Bop (Mul) y x) :ruleset canon)
(rewrite (Bop (Eq) x y) (Bop (Eq) y x) :ruleset canon)
(rewrite (Bop (And) x y) (Bop (And) y x) :ruleset canon)
(rewrite (Bop (Or) x y) (Bop (Or) y x) :ruleset canon)

; Canonicalize to <
; x > y ==> y < x
(rewrite (Bop (GreaterThan) x y) (Bop (LessThan) y x) :ruleset canon)

; x >= y ==> y < x + 1
; x >= y ==> y - 1 < x
(rule (
        (= lhs (Bop (GreaterEq) x y))
        (HasArgType x ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) y (Bop (Add) x (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) y (Const (Int 1) ty ctx)) x))
      )
      :ruleset canon)

; x <= y ==> x < y + 1
; x <= y ==> x - 1 < y
(rule (
        (= lhs (Bop (LessEq) x y))
        (HasArgType y ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) x (Bop (Add) y (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) x (Const (Int 1) ty ctx)) y))
      )
      :ruleset canon)


; Make Concats right-deep
(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)
; Simplify Concat's with empty
(rewrite (Concat (Empty ty ctx) x)
         x
         :ruleset always-run)
(rewrite (Concat x (Empty ty ctx))
         x
         :ruleset always-run)

; Make a tuple that is a sub-range of another tuple
;                   tuple start len
(constructor SubTuple (Expr  i64   i64) Expr :unextractable)

(rewrite (SubTuple expr x 0)
         (Empty ty ctx)
         :when ((HasArgType expr ty) (ContextOf expr ctx))
         :ruleset always-run)

(rewrite (SubTuple expr x 1)
         (Single (Get expr x))
         :ruleset always-run)

(rewrite (SubTuple expr a b)
         (Concat (Single (Get expr a)) (SubTuple expr (+ a 1) (- b 1)))
         :when ((> b 1))
         :ruleset always-run)

; Some of our rules (like ivt.egg) match on `Concat`.
; These may be missing if a tuple is used directly (i.e. (DoWhile inputs (If pred thn else))).
; So add these concats for every region in the database
(rule ((= lhs (DoWhile inputs body))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (If pred inputs thn els))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Switch pred inputs bodies))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)
(rule ((= lhs (Arg ty ctx))
       (= size (tuple-length lhs)))
      ((union lhs (SubTuple lhs 0 size)))
      :ruleset always-run)

; Also figure out what existing expressions are subtuples of other things
; this helps remove concat layers
(rule ((Get expr i))
      ((union (Single (Get expr i))
              (SubTuple expr i 1)))
      :ruleset always-run)

(rewrite (Concat (SubTuple expr a b)
                 (SubTuple expr (+ a b) c))
         (SubTuple expr a (+ b c))
         :ruleset always-run)
;; a subtuple which is the entire tuple is the tuple itself
;; this removes unecessary layers of concat
(rewrite (SubTuple expr 0 len)
         expr
         :when ((= len (tuple-length expr)))
         :ruleset always-run)

; Helper functions to remove one element from a tuple or type list
;                           tuple    idx
(constructor TupleRemoveAt    (Expr     i64) Expr     :unextractable)
(rewrite (TupleRemoveAt tuple idx)
         (Concat (SubTuple tuple 0 idx)
                 (SubTuple tuple (+ idx 1) (- len (+ idx 1))))
         :when ((= len (tuple-length tuple)))
         :ruleset always-run)
(rule ((TupleRemoveAt tuple idx)
       (= len (tuple-length tuple))
       (>= idx len))
      ((panic "Index out of bounds for TupleRemoveAt")) :ruleset always-run)

(constructor TypeListRemoveAt (TypeList i64) TypeList :unextractable)
(rule ((TypeListRemoveAt (TNil) _idx))
      ((panic "Index out of bounds for TypeListRemoveAt.")) :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) 0)
         xs
         :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) idx)
         (TCons x (TypeListRemoveAt xs (- idx 1)))
         :when ((> idx 0))
         :ruleset type-helpers)

;; Compute the tree size of program, not dag size
(function Expr-size (Expr) i64 :merge (min old new) )
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(rule ((= expr (Function name tyin tyout out)) 
       (= sum (Expr-size out))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty assum))) 
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Top op x y z))
       (= sum (+ (Expr-size z) (+ (Expr-size y) (Expr-size x)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Bop op x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i)) 
       (= sum (Expr-size tup))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred inputs branches)) 
       (= sum  (+ (Expr-size inputs) (+ (ListExpr-size branches) (Expr-size pred)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred inputs then else)) 
       (= sum (+ (Expr-size inputs) (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output)) 
       (= sum (+ (Expr-size pred-and-output) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty assum))) 
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg)) 
       (= sum (Expr-size arg))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty assum)) ((set (Expr-size (Empty ty assum)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl)) 
       (= sum (+ (ListExpr-size tl) (Expr-size hd)))) 
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil)) 
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc id e state ty)) ;; do state edge's expr should be counted?
        (= sum (Expr-size e))) 
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

;; Like Subst but for dropping inputs to a region
;; See subst.egg for more implementation documentation

(ruleset drop)
(ruleset apply-drop-unions)
(ruleset cleanup-drop)

;; (DropAt ctx idx in) removes all references to `(Get (Arg ...) idx)` in `in`.
;; It also replaces the leaf contexts with `ctx` and fixes up argument types,
;; as well as updating `(Get (Arg ...) j)` to `(Get (Arg ...) (- j 1))` for j > idx.
(constructor DropAt (Assumption i64 Expr) Expr :unextractable)
(constructor DelayedDropUnion (Expr Expr) Expr :unextractable)

;; Helper that precomputes the arg type that we need
(constructor DropAtInternal (Type Assumption i64 Expr) Expr :unextractable)
(rule ((= lhs (DropAt ctx idx in))
       (HasArgType in (TupleT oldty)))

      ((let newty (TupleT (TypeListRemoveAt oldty idx)))
       (union lhs (DropAtInternal newty ctx idx in)))
      :ruleset drop)

;; Leaves
(rule ((= lhs (DropAtInternal newty newctx idx (Const c oldty oldctx))))
      ((DelayedDropUnion lhs (Const c newty newctx)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Empty oldty oldctx))))
      ((DelayedDropUnion lhs (Empty newty newctx)))
      :ruleset drop)
; get stuck on purpose if `i = idx` or if we find a bare `Arg`
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (< i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) i)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (> i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) (- i 1))))
      :ruleset drop)

;; Operators
(rule ((= lhs (DropAtInternal newty newctx idx (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedDropUnion lhs (Top op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            (DropAtInternal newty newctx idx c3))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedDropUnion lhs (Bop op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedDropUnion lhs (Uop op
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; this is okay because we get stuck at `Arg`s
(rule ((= lhs (DropAtInternal newty newctx idx (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedDropUnion lhs (Get
            (DropAtInternal newty newctx idx c1)
            index)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedDropUnion lhs (Alloc id
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            ty)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedDropUnion lhs (Call name
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; Tuple operators
(rule ((= lhs (DropAtInternal newty newctx idx (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedDropUnion lhs (Single
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedDropUnion lhs (Concat
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

;; Control flow
(rule ((= lhs (DropAtInternal newty newctx idx (Switch pred inputs c1)))
       (ExprIsResolved (Switch pred inputs c1)))
      ((DelayedDropUnion lhs (Switch
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (If pred inputs c1 c2)))
       (ExprIsResolved (If pred inputs c1 c2)))
      ((DelayedDropUnion lhs (If
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1
            c2)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedDropUnion lhs (DoWhile
            (DropAtInternal newty newctx idx in)
            out)))
      :ruleset drop)

(rewrite (DropAtInternal newty newctx idx (Function name inty outty body))
         (Function name inty outty (DropAtInternal newty newctx idx body))
         :when ((ExprIsResolved body))
         :ruleset drop)



;; ########################### Apply drop unions

(rule ((DelayedDropUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-drop-unions)

;; ########################### Cleanup Dropat, DropAtInternal and DelayedDropUnion

(rule ((ExprIsResolved (DropAt newctx idx in)))
      ((subsume (DropAt newctx idx in)))
      :ruleset cleanup-drop)

(rule ((ExprIsResolved (DropAtInternal newty newctx idx in)))
      ((subsume (DropAtInternal newty newctx idx in)))
      :ruleset cleanup-drop)

(rule ((DelayedDropUnion lhs rhs))
      ((subsume (DelayedDropUnion lhs rhs)))
      :ruleset cleanup-drop)

(ruleset interval-analysis)
(ruleset interval-rewrite)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (Dead) ;; a bound on dead code, so any value can be chosen
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :merge (bound-max old new))
(function hi-bound (Expr) Bound :merge (bound-min old new))

; if lo > hi, we have proven that this code is dead (as long as all our rules are sound)
; In this case, interval analysis might start going crazy and fail to saturate
; So we immediately set the bounds to (Dead)
(rule (
         (= (IntB lo) (lo-bound expr))
         (= (IntB hi) (hi-bound expr))
         (> lo hi)
       ) 
       ((set (lo-bound expr) (Dead))
        (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)
(rule (
      (= (BoolB true) (lo-bound expr))
      (= (BoolB false) (hi-bound expr))
      ) 
      ((set (lo-bound expr) (Dead))
       (set (hi-bound expr) (Dead)))
       :ruleset interval-analysis)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)
(rewrite (bound-max (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-max anything (Dead))
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min (Dead) anything)
         (Dead)
         :ruleset interval-analysis)
(rewrite (bound-min anything (Dead))
         (Dead)
         :ruleset interval-analysis)

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (lo-bound lhs) (IntB (+ la lb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (IntB (+ ha hb))))
      :ruleset interval-analysis)

; - a b interval is (- la hb) (- ha lb)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (lo-bound lhs) (IntB (- la hb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (hi-bound lhs) (IntB (- ha lb))))
      :ruleset interval-analysis)

; Multiplication for two constants
; TODO: Make fancier interval analysis
(rule (
       (= lhs (Bop (Mul) a b))
       (= (IntB x) (lo-bound a))
       (= (IntB x) (hi-bound a))
       (= (IntB y) (lo-bound b))
       (= (IntB y) (hi-bound b))
      )
      (
       (set (lo-bound lhs) (IntB (* x y)))
       (set (hi-bound lhs) (IntB (* x y)))
      )
      :ruleset interval-analysis)

; negative * negative is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (< hi-x 0)
        (< hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; negative * positive is negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (< hi-x 0) ; x < 0 (x is negative)
        (> lo-y 0) ; y > 0 (y is positive)
      )
      ((set (hi-bound lhs) (IntB -1)))
      :ruleset interval-analysis)

; positive * positive is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (> lo-x 0)
        (> lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 1)))
      :ruleset interval-analysis)

; non-positive * non-positive is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (<= hi-x 0)
        (<= hi-y 0) 
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-positive * non-negative is non-positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (<= hi-x 0) ; x <= 0 (x is non-positive)
        (>= lo-y 0) ; y >= 0 (y is non-negative)
      )
      ((set (hi-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; non-negative * non-negative is non-negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (>= lo-x 0)
        (>= lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      (
       (set (lo-bound lhs) (BoolB (bool-< ha lb)))
      )
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (BoolB (bool-< la hb))))
      :ruleset interval-analysis)

; Abs
; abs(x) = x if x >= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB lx) (lo-bound x))
        (>= lx 0)
      )
      ((union lhs x))
      :ruleset interval-rewrite)

; abs(x) = -x if x <= 0
(rule (
        (= lhs (Uop (Abs) x))
        (= (IntB hx) (hi-bound x))
        (<= hx 0)
        (HasArgType lhs ty)
        (ContextOf lhs ctx)
      )
      ((union lhs (Bop (Sub) (Const (Int 0) ty ctx) x)))
      :ruleset interval-rewrite)

; =================================
; Conditionals
; =================================
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-rewrite)

; if the predicate is false, merge with else branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB false) (hi-bound cond))
      )
      ((union lhs (Subst if_ctx inputs els)))
      :ruleset interval-rewrite)

; lo-bound of If is the min of the lower bounds
; hi-bound of If is the max of the upper bounds
(rule (
        (= lhs (If cond inputs thn els))
        (= lo-thn (lo-bound thn))
        (= lo-els (lo-bound els))
      )
      ((set (lo-bound lhs) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound thn))
       (= hi-els (hi-bound els))
      )
      ((set (hi-bound lhs) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; If the If takes a tuple
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was true, so we know expr is at most (hi-bound value) - 1
      ((set (hi-bound (Get ctx i)) (IntB (- v 1))))
      :ruleset interval-analysis)
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was false, so we know expr is at least (lo-bound value)
      ((set (lo-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was true, so we know expr is at least (lo-bound value) + 1
      ((set (lo-bound (Get ctx i)) (IntB (+ v 1)))) 
      :ruleset interval-analysis)
(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was false, so we know expr is at most (hi-bound value)
      ((set (hi-bound (Get ctx i)) (IntB v))) 
      :ruleset interval-analysis)

;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)

; (if (a == b) thn els)
; in the thn branch, we know that a has the same bounds as b
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx  (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB lo) (lo-bound val))
      )
      ((set (lo-bound (Get ctx i)) (IntB lo)))
      :ruleset interval-analysis)
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB hi) (hi-bound val))
      )
      ((set (hi-bound (Get ctx i)) (IntB hi)))
      :ruleset interval-analysis)


(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)


(ruleset switch_rewrite)
(ruleset always-switch-rewrite)

; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)

; if a < b then b else a ~~> (max a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then b else a
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) j))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) i))
      )
      ((union (Get if_e k) (Bop (Smax) a b)))
      :ruleset switch_rewrite) 

; if pred then a else b ~~> (select pred a b)
; where a and b are inputs to the region
(rule (
       (= if_e (If pred inputs thn els))
       (= a (Get inputs i))
       (= b (Get inputs j))

       ; if pred then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))

       ; If i = j, then the arg is just passed through the if, and we
       ; don't need a select. This will get handled by the passthrough rules.
       (!= i j)
       )
       (
       (union (Get if_e k) (Top (Select) pred a b))
       )
       :ruleset switch_rewrite)

(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)
       (= (Get thn i) (Const x _ty (InIf true pred inputs)))
       (= (Get els i) (Const y _ty (InIf false pred inputs)))
      )
      ((union (Get if_e i) (Top (Select) pred (Const x ty ctx) (Const y ty ctx))))
      :ruleset switch_rewrite)

; if pred then A else Const -> select pred A Const
; where A is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       ; input to the if
       (= a (Get inputs i))
       (= (Get thn k) (Get (Arg _ty (InIf true pred inputs)) i))

       (= els_out (Get els k))
       (= (IntB y) (lo-bound els_out))
       (= (IntB y) (hi-bound els_out))
       )
       (
       (union (Get if_e k) (Top (Select) pred a (Const (Int y) ty ctx)))
       )
       :ruleset switch_rewrite
)

; if pred then Const else B -> select pred Const B
; where B is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       (= thn_out (Get thn k))
       (= (IntB y) (lo-bound thn_out))
       (= (IntB y) (hi-bound thn_out))

       ; input to the if
       (= b (Get inputs i))
       (= (Get els k) (Get (Arg _ty (InIf false pred inputs)) i))
      )
      (
       (union (Get if_e k) (Top (Select) pred (Const (Int y) ty ctx) b))
      )
      :ruleset switch_rewrite
)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf true  a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let inner_X (AddContext (InIf true  inner_pred sub_arg_true) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_true) Y))
       (let outer_Y (Subst      (InIf false a          outer_ins) sub_arg_false Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

; if (a or b) X Y ~~> if a X (if b X Y)
(rule ((= lhs (If (Bop (Or) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf false a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let outer_X (Subst      (InIf true  a          outer_ins) sub_arg_true X))
       (let inner_X (AddContext (InIf true  inner_pred sub_arg_false) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_false) Y))

       (let inner (If inner_pred sub_arg_false inner_X inner_Y))
       (union lhs (If a          outer_ins     outer_X inner  )))

       :ruleset switch_rewrite)

(rewrite (If (Const (Bool true)  ty ctx) ins thn els)
         (Subst ctx ins thn)
         :ruleset always-switch-rewrite)

(rewrite (If (Const (Bool false) ty ctx) ins thn els)
         (Subst ctx ins els)
         :ruleset always-switch-rewrite)

(ruleset select_opt)


;; inlined (Get thn i) makes the query faster ):
(rule
       (
        (= if_e (If pred inputs thn els))

        (ExprIsPure (Get thn i))
        (ExprIsPure (Get els i))
        
        (> 10 (Expr-size (Get thn i))) ; TODO: Tune these size limits
        (> 10 (Expr-size (Get els i)))
        (= (TCPair t1 c1) (ExtractedExpr (Get thn i)))
        (= (TCPair t2 c2) (ExtractedExpr (Get els i)))

        (ContextOf if_e ctx)
       )
       (
        (union (Get if_e i)
               (Top (Select) pred (TermSubst ctx inputs t1) (TermSubst ctx inputs t2)))
       )
       :ruleset select_opt
)
; Simple rewrites that don't do a ton with control flow.

(ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 0) ty ctx)) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) (Const (Int 1) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 1) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int 0) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Add) e (Const (Int 0) ty ctx) ) e :ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (* i j)) ty ctx) :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (+ i j)) ty ctx) :ruleset peepholes)

(rewrite (Bop (And) (Const (Bool true) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool true) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (And) (Const (Bool false) ty ctx) e) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool false) ty ctx)) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool false) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool false) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool true) ty ctx) e) (Const (Bool true) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool true) ty ctx)) (Const (Bool true) ty ctx) :ruleset peepholes)

(rule (
        (= expr (Bop (Sub) x x))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Const (Int 0) ty ctx)))
      :ruleset peepholes)

; (x - y) + z => x + (z - y)
(rewrite (Bop (Add) (Bop (Sub) x y) z) (Bop (Add) x (Bop (Sub) z y)) :ruleset peepholes)

; (a + b) - c => a + (b - c)
(rewrite (Bop (Sub) (Bop (Add) a b) c) (Bop (Add) a (Bop (Sub) b c)) :ruleset peepholes)

; (a * x) + a => a * (x + 1)
(rule (
        (= expr (Bop (Add) (Bop (Mul) a x) a))
        (HasArgType expr ty)
        (ContextOf expr ctx)
      )
      ((union expr (Bop (Mul) a (Bop (Add) x (Const (Int 1) ty ctx)))))
      :ruleset peepholes)

(rewrite (Top (Select) pred x x) x :ruleset peepholes)

; constant fold `(x + const1) + const2` even when x is not constant
(rewrite (Bop (Add) (Bop (Add) x (Const (Int i) ty ctx)) (Const (Int j) ty ctx))
         (Bop (Add) x (Const (Int (+ i j)) ty ctx))
         :ruleset peepholes)

; ptradd(ptradd(p, x), y) => ptradd(p, x + y)
(rewrite (Bop (PtrAdd) (Bop (PtrAdd) p x) y)
         (Bop (PtrAdd) p (Bop (Add) x y))
         :ruleset peepholes)

(datatype IntOrInfinity
    (Infinity)
    (NegInfinity)
    (I i64))

(constructor MaxIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MaxIntOrInfinity (Infinity) _) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity _ (Infinity)) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity (NegInfinity) x) x :ruleset always-run)
(rewrite (MaxIntOrInfinity x (NegInfinity)) x :ruleset always-run)
(rewrite (MaxIntOrInfinity (I x) (I y)) (I (max x y)) :ruleset always-run)

(constructor MinIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MinIntOrInfinity (NegInfinity) _) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity _ (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity (Infinity) x) x :ruleset always-run)
(rewrite (MinIntOrInfinity x (Infinity)) x :ruleset always-run)
(rewrite (MinIntOrInfinity (I x) (I y)) (I (min x y)) :ruleset always-run)

(constructor AddIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (AddIntOrInfinity (Infinity) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (Infinity) (I _)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (I _)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I x) (I y)) (I (+ x y)) :ruleset always-run)

(datatype IntInterval (MkIntInterval IntOrInfinity IntOrInfinity))

(constructor UnionIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (UnionIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MinIntOrInfinity lo1 lo2) (MaxIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor IntersectIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (IntersectIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MaxIntOrInfinity lo1 lo2) (MinIntOrInfinity hi1 hi2))
         :ruleset always-run)

(constructor AddIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (AddIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (AddIntOrInfinity lo1 lo2)
                        (AddIntOrInfinity hi1 hi2))
         :ruleset always-run)


(datatype List<i64+IntInterval> 
  (Nil-List<i64+IntInterval>)
  (Cons-List<i64+IntInterval> i64 IntInterval List<i64+IntInterval>))

(function Length-List<i64+IntInterval> (List<i64+IntInterval>) i64 :no-merge)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((IsEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(relation IsNonEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((IsNonEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(constructor RevConcat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (RevConcat-List<i64+IntInterval> (Nil-List<i64+IntInterval>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<i64+IntInterval> (Cons-List<i64+IntInterval> hd0 hd1 tl) l)
         (RevConcat-List<i64+IntInterval> tl (Cons-List<i64+IntInterval> hd0 hd1 l))
         :ruleset always-run)

(constructor Rev-List<i64+IntInterval> (List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Rev-List<i64+IntInterval> m)
         (RevConcat-List<i64+IntInterval> m (Nil-List<i64+IntInterval>))
         :ruleset always-run)

(constructor Concat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Concat-List<i64+IntInterval> x y)
         (RevConcat-List<i64+IntInterval> (Rev-List<i64+IntInterval> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<i64+IntInterval> (List<i64+IntInterval>))
(relation SuffixAt-List<i64+IntInterval> (List<i64+IntInterval> i64 List<i64+IntInterval>))
(relation At-List<i64+IntInterval> (List<i64+IntInterval> i64 i64 IntInterval))
(rule ((DemandAt-List<i64+IntInterval> x))
      ((SuffixAt-List<i64+IntInterval> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<i64+IntInterval> x i (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((SuffixAt-List<i64+IntInterval> x (+ i 1) tl)
       (At-List<i64+IntInterval> x i hd0 hd1))
      :ruleset always-run)

(constructor Union-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor UnionHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Union-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (UnionHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; both m1 and m2 empty
  (rewrite (UnionHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)
  ; take from m1 when m2 empty and vice versa
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      res)
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      tl
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      (Nil-List<i64+IntInterval>)
      res)
    (UnionHelper-List<i64+IntInterval>
      tl
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)

  ; when both nonempty and smallest key different, take smaller key
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 l2 (Cons-List<i64+IntInterval> k1 a1 res))))
        :ruleset always-run)
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f
           (UnionHelper-List<i64+IntInterval> l1 tl2 (Cons-List<i64+IntInterval> k2 b1 res))))
        :ruleset always-run)

  ; when shared smallest key, union interval
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 tl2
             (Cons-List<i64+IntInterval> k (UnionIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor Intersect-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (constructor IntersectHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Intersect-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (IntersectHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; m1 or m2 empty
  (rewrite (IntersectHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) m2 res)
           res
           :ruleset always-run)
  (rewrite (IntersectHelper-List<i64+IntInterval> m1 (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)

  ; when both nonempty and smallest key different, drop smaller key
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)

(datatype MyBool (MyTrue) (MyFalse))

(constructor IntIntervalValid (IntInterval) MyBool)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyTrue)
         :when ((<= lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyFalse)
         :when ((> lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (NegInfinity) _))
         (MyTrue)
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval _ (Infinity)))
         (MyTrue)
         :ruleset always-run)

(constructor ConsIfNonEmpty (i64 IntInterval List<i64+IntInterval>)
          List<i64+IntInterval>
          :cost 100)
(rule ((ConsIfNonEmpty k v tl))
      ((IntIntervalValid v))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyTrue) (IntIntervalValid v)))
      ((union f (Cons-List<i64+IntInterval> k v tl)))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyFalse) (IntIntervalValid v)))
      ((union f tl))
      :ruleset always-run)

  ; when shared smallest key, intersect interval
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (IntersectHelper-List<i64+IntInterval> tl1 tl2
             (ConsIfNonEmpty k (IntersectIntInterval a1 b1) res))))
        :ruleset always-run)

(constructor AddIntIntervalToAll (IntInterval List<i64+IntInterval>)
                              List<i64+IntInterval>)
(rewrite (AddIntIntervalToAll _ (Nil-List<i64+IntInterval>))
         (Nil-List<i64+IntInterval>)
         :ruleset always-run)
(rewrite (AddIntIntervalToAll x (Cons-List<i64+IntInterval> allocid offset tl))
         (Cons-List<i64+IntInterval> allocid (AddIntInterval x offset)
           (AddIntIntervalToAll x tl))
         :ruleset always-run)

(datatype PtrPointees
  (PointsTo List<i64+IntInterval>)
  (PointsAnywhere))

(constructor AddIntIntervalToPtrPointees (IntInterval PtrPointees) PtrPointees)
(rewrite (AddIntIntervalToPtrPointees interval (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (AddIntIntervalToPtrPointees interval (PointsTo l))
         (PointsTo (AddIntIntervalToAll interval l))
         :ruleset always-run)

(constructor Union-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Union-PtrPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Union-List<i64+IntInterval> x y))
         :ruleset always-run)
(constructor Intersect-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Intersect-PtrPointees (PointsAnywhere) x)
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees x (PointsAnywhere))
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Intersect-List<i64+IntInterval> x y))
         :ruleset always-run)

(relation PointsNowhere-PtrPointees (PtrPointees))
(rule ((= f (PointsTo x))
       (IsEmpty-List<i64+IntInterval> x))
      ((PointsNowhere-PtrPointees f))
      :ruleset always-run)


(datatype List<PtrPointees> 
  (Nil-List<PtrPointees>)
  (Cons-List<PtrPointees> PtrPointees List<PtrPointees>))

(function Length-List<PtrPointees> (List<PtrPointees>) i64 :no-merge)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((IsEmpty-List<PtrPointees> x))
      :ruleset always-run)

(relation IsNonEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Cons-List<PtrPointees> hd0 tl)))
      ((IsNonEmpty-List<PtrPointees> x))
      :ruleset always-run)

(constructor RevConcat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (RevConcat-List<PtrPointees> (Nil-List<PtrPointees>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<PtrPointees> (Cons-List<PtrPointees> hd0 tl) l)
         (RevConcat-List<PtrPointees> tl (Cons-List<PtrPointees> hd0 l))
         :ruleset always-run)

(constructor Rev-List<PtrPointees> (List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Rev-List<PtrPointees> m)
         (RevConcat-List<PtrPointees> m (Nil-List<PtrPointees>))
         :ruleset always-run)

(constructor Concat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Concat-List<PtrPointees> x y)
         (RevConcat-List<PtrPointees> (Rev-List<PtrPointees> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<PtrPointees> (List<PtrPointees>))
(relation SuffixAt-List<PtrPointees> (List<PtrPointees> i64 List<PtrPointees>))
(relation At-List<PtrPointees> (List<PtrPointees> i64 PtrPointees))
(rule ((DemandAt-List<PtrPointees> x))
      ((SuffixAt-List<PtrPointees> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<PtrPointees> x i (Cons-List<PtrPointees> hd0 tl)))
      ((SuffixAt-List<PtrPointees> x (+ i 1) tl)
       (At-List<PtrPointees> x i hd0))
      :ruleset always-run)

(relation All<PointsNowhere-PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (PointsNowhere-PtrPointees hd0)
       (All<PointsNowhere-PtrPointees> tl))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
        


(constructor Zip<Union-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Union-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Union-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Union-PtrPointees x0 y0)
            (Zip<Union-PtrPointees> tl1 tl2))
         :when ((= (Length-List<PtrPointees> tl1) (Length-List<PtrPointees> tl2)))
         :ruleset always-run)

(constructor Zip<Intersect-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Intersect-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Intersect-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Intersect-PtrPointees x0 y0)
            (Zip<Intersect-PtrPointees> tl1 tl2))
         :ruleset always-run)


(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(constructor ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset memory-helpers)
(constructor ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset memory-helpers)
(relation ExprSet-contains (ExprSet Expr))
(constructor ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset memory-helpers)
(function ExprSet-length (ExprSet) i64 :no-merge)


; ============================
; Pointees
; ============================


; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))

(constructor UnwrapPtrPointsTo (Pointees) PtrPointees)
(rewrite (UnwrapPtrPointsTo (PtrPointsTo x))
         x
         :ruleset memory-helpers)
(constructor UnwrapTuplePointsTo (Pointees) List<PtrPointees>)
(rewrite (UnwrapTuplePointsTo (TuplePointsTo x))
         x
         :ruleset memory-helpers)

(relation PointsNowhere (Pointees))
(rule ((= f (PtrPointsTo x))
       (PointsNowhere-PtrPointees x))
      ((PointsNowhere f))
      :ruleset memory-helpers)
(rule ((= f (TuplePointsTo l))
       (All<PointsNowhere-PtrPointees> l))
      ((PointsNowhere f))
      :ruleset memory-helpers)

(constructor UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Union-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (UnionPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Union-PtrPointees> x y))
         :when ((= (Length-List<PtrPointees> x) (Length-List<PtrPointees> y)))
         :ruleset memory-helpers)
(constructor IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Intersect-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (IntersectPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Intersect-PtrPointees> x y))
         :ruleset memory-helpers)

(constructor GetPointees (Pointees i64) Pointees)
(rule ((= f (GetPointees (TuplePointsTo l) i))
       (At-List<PtrPointees> l i x))
      ((union f (PtrPointsTo x)))
      :ruleset memory-helpers)

(constructor PointeesDropFirst (Pointees) Pointees)
(rewrite (PointeesDropFirst (TuplePointsTo (Cons-List<PtrPointees> hd tl)))
         (TuplePointsTo tl)
         :ruleset memory-helpers)

; ============================
; Resolved
; ============================

; Resolved checks if an e-class contains a term containing only constructors and
; primitives; i.e. whether equality is decideable
(relation Resolved-IntOrInfinity (IntOrInfinity))
(rule ((= f (I _)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (Infinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (NegInfinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)

(relation Resolved-IntInterval (IntInterval))
(rule ((= f (MkIntInterval lo hi))
       (Resolved-IntOrInfinity lo)
       (Resolved-IntOrInfinity hi))
      ((Resolved-IntInterval f))
      :ruleset memory-helpers)

(relation Resolved-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= f (Nil-List<i64+IntInterval>)))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<i64+IntInterval> allocid offsets tl))
       (Resolved-List<i64+IntInterval> tl)
       (Resolved-IntInterval offsets))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)

(relation Resolved-PtrPointees (PtrPointees))
(rule ((= f (PointsAnywhere)))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)
(rule ((= f (PointsTo x))
       (Resolved-List<i64+IntInterval> x))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)

(relation Resolved-List<PtrPointees> (List<PtrPointees>))
(rule ((= f (Nil-List<PtrPointees>)))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<PtrPointees> hd tl))
       (Resolved-List<PtrPointees> tl)
       (Resolved-PtrPointees hd))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)

(relation Resolved-Pointees (Pointees))
(rule ((= f (TuplePointsTo x))
       (Resolved-List<PtrPointees> x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)
(rule ((= f (PtrPointsTo x))
       (Resolved-PtrPointees x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)


;;;;;

(constructor BaseTypeToPtrPointees (BaseType) PtrPointees :cost 100)
(rewrite (BaseTypeToPtrPointees (PointerT _))
         (PointsAnywhere)
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (IntT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (StateT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (BoolT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)

(constructor TypeListToList<PtrPointees> (TypeList) List<PtrPointees> :cost 1000)
(rewrite (TypeListToList<PtrPointees> (TNil))
         (Nil-List<PtrPointees>)
         :ruleset memory-helpers)
(rewrite (TypeListToList<PtrPointees> (TCons hd tl))
         (Cons-List<PtrPointees>
            (BaseTypeToPtrPointees hd)
            (TypeListToList<PtrPointees> tl))
         :ruleset memory-helpers)

(constructor TypeToPointees (Type) Pointees :cost 1000)
(rewrite (TypeToPointees (TupleT tylist))
         (TuplePointsTo (TypeListToList<PtrPointees> tylist))
         :ruleset memory-helpers)
(rewrite (TypeToPointees (Base basety))
         (PtrPointsTo (BaseTypeToPtrPointees basety))
         :ruleset memory-helpers)

; ============================
; Update PointerishType
; ============================

(relation PointerishType (Type))
(relation PointerishTypeList (TypeList))

(rule ((= f (Base (PointerT ty))))
      ((PointerishType f))
      :ruleset always-run)

(rule ((= f (TCons (PointerT ty) tl)))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TCons hd tl))
       (PointerishTypeList tl))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TupleT l))
       (PointerishTypeList l))
      ((PointerishType f))
      :ruleset always-run)

; ============================
; Update PointsToCells
; ============================

;                             arg pointees  result pointees
(constructor PointsToCells (Expr Pointees)     Pointees :unextractable) 

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (TypeToPointees in-ty)))
      :ruleset memory-helpers)

; Demand PointsToCells along state edge and pointer-typed values
(rule ((PointsToCells (Bop (Print) e state) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Top (Write) ptr val state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Alloc id sz state ty) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Free) ptr state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Get x i) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Concat x y) ap))
      ((PointsToCells x ap)
       (PointsToCells y ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Single x) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)

; Compute and propagate PointsToCells
(rewrite (PointsToCells concat-x-y aps)
         (TuplePointsTo (Concat-List<PtrPointees>
           (UnwrapTuplePointsTo (PointsToCells x aps))
           (UnwrapTuplePointsTo (PointsToCells y aps))))
         :when ((= concat-x-y (Concat x y))
                (HasType concat-x-y ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells get-x-i aps)
         (GetPointees (PointsToCells x aps) i)
         :when ((= get-x-i (Get x i))
                (HasType get-x-i ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Single x) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (UnwrapPtrPointsTo (PointsToCells x aps))
             (Nil-List<PtrPointees>)))
         :when ((HasType (Single x) ty) (PointerishType ty))
         :ruleset memory-helpers) 

(rewrite (PointsToCells (Arg ty_ ctx) aps)
         aps
         :when ((HasType (Arg ty_ ctx) ty) (PointerishType ty))
         :ruleset memory-helpers)

; Allow non-pointer types to resolve
(rule ((PointsToCells x aps)
       (HasType x ty))
      ((TypeToPointees ty))
      :ruleset memory-helpers)
(rule ((= f (PointsToCells x aps))
       (HasType x ty)
       (= pointees (TypeToPointees ty))
       (PointsNowhere pointees))
      ((union f pointees))
      :ruleset memory-helpers)

(rewrite (PointsToCells (Bop (PtrAdd) x e) aps)
         (PtrPointsTo
           (AddIntIntervalToPtrPointees
             (MkIntInterval (I lo) (I hi))
             (UnwrapPtrPointsTo (PointsToCells x aps))))
         :when ((= (IntB lo) (lo-bound e))
                (= (IntB hi) (hi-bound e)))
         :ruleset memory-helpers)

(rewrite (PointsToCells (If c inputs t e) aps)
         (UnionPointees
           (PointsToCells t (PointsToCells inputs aps))
           (PointsToCells e (PointsToCells inputs aps)))
         :when ((HasType (If c inputs t e) ty) (PointerishType ty))
         :ruleset memory)

(rewrite (PointsToCells (Alloc id sz state ty) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (PointsTo
               (Cons-List<i64+IntInterval>
                 id
                 (MkIntInterval (I 0) (I 0))
                 (Nil-List<i64+IntInterval>)))
             (Cons-List<PtrPointees>
               (PointsTo (Nil-List<i64+IntInterval>)) ; state output points to nothing
               (Nil-List<PtrPointees>))))
         :ruleset memory-helpers)

; arg pointees * loop in * loop out * i64 -> result pointees
(constructor PointsToCellsAtIter (Pointees Expr Expr i64) Pointees)

; compute first two
(rule ((= e (DoWhile inputs pred-body))
       (PointsToCells e aps))
      ((set (PointsToCellsAtIter aps inputs pred-body 0)
            (PointsToCells inputs aps))
       (set (PointsToCellsAtIter aps inputs pred-body 1)
            (UnionPointees
              (PointsToCellsAtIter aps inputs pred-body 0)
              (PointeesDropFirst
                (PointsToCells pred-body (PointsToCellsAtIter aps inputs pred-body 0))))))
      :ruleset memory-helpers)

; avoid quadratic query
(function succ (i64) i64 :no-merge)
(rule ((PointsToCellsAtIter aps inputs pred-body i))
      ((set (succ i) (+ i 1)))
      :ruleset memory-helpers)

; Note that this rule is bounded by ruleset memory
(rule ((= pointees0 (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees1 (PointsToCellsAtIter aps inputs pred-body (succ i)))
       (Resolved-Pointees pointees0)
       (Resolved-Pointees pointees1)
       (!= pointees0 pointees1))
      ((set (PointsToCellsAtIter aps inputs pred-body (+ i 2))
            (UnionPointees
              pointees1
              (PointeesDropFirst
                (PointsToCells pred-body pointees1)))))
      :ruleset memory)

(rule ((= pointees (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees (PointsToCellsAtIter aps inputs pred-body (succ i))))
      ((set (PointsToCells (DoWhile inputs pred-body) aps)
            pointees))
      :ruleset memory)

(rule ((PtrPointsTo (PointsTo l)))
      ((DemandAt-List<i64+IntInterval> l))
      :ruleset memory-helpers)
(rule ((TuplePointsTo l))
      ((DemandAt-List<PtrPointees> l))
      :ruleset memory-helpers)

; ============================
; Update DontAlias
; ============================

(relation DemandDontAlias (Expr Expr Pointees))
;                    pointer, pointer, arg pointees
(relation DontAlias (Expr Expr Pointees))


(rule ((DemandDontAlias ptr1 ptr2 arg-pointees)
       (BodyContainsExpr body ptr1)
       (BodyContainsExpr body ptr2)
       (HasType ptr1 (Base (PointerT ty)))
       (HasType ptr2 (Base (PointerT ty)))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset memory-helpers)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((DontAlias ptr1 ptr2 arg-pointees))
      :ruleset memory-helpers)

; ============================
; Update PointsToExpr
; ============================

;                       program point, pointer
(constructor PointsToExpr (Expr           Expr) Expr :unextractable)

; After a load, the ptr points to the loaded value
(rule ((= f (Bop (Load) ptr state)))
      ((set (PointsToExpr (Get f 1) ptr) (Get f 0)))
      :ruleset memory-helpers)

; If we load and we already know what the pointer points to
; TODO this rule breaks the weakly linear invariant
; when a previous load may not be on the path
;(rule ((= e (Bop (Load) addr state))
;       (= v (PointsToExpr state addr)))
;      ((union (Get e 0) v)
;       (union (Get e 1) state))
;       :ruleset memory-helpers)

; Loads and prints don't affect what what pointers already point to
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Load) any-addr state)))
      ((let new-state (Get e 1))
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Print) any-val state)))
      ((let new-state e)
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)

; Writes don't affect what a pointer points to if it writes to another pointer
; guaranteed to not alias.
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr)))
      ((DemandDontAlias addr otheraddr (TypeToPointees argty)))
      :ruleset memory-helpers)
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr))
       (DontAlias addr otheraddr (TypeToPointees argty)))
      ((set (PointsToExpr e otheraddr) otherdata))
      :ruleset memory-helpers)

; For a write, mark the given expression as containing `data`.
(rule ((= e (Top (Write) addr data state)))
      ((union (PointsToExpr e addr) data))
      :ruleset memory-helpers)

; ============================
; Update CellHasValues (currently unused)
; ============================

; ;                       program point, cell
; (constructor CellHasValues (Expr i64) ExprSet :merge (ExprSet-intersect old new))

; ; At the time of an alloc, a cell doesn't contain any values
; (rule ((= f (Alloc id amt state ty)))
      ; ((set (CellHasValues (Get f 1) id) (ES (set-empty))))
      ; :ruleset memory-helpers)

; ; These two rules find (Write ptr val state) where 
; ; ptr points to cells given no assumptions about where (Arg) points.
; ; TODO: make sensitive to offsets
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty))
      ; ((TypeToPointees argty))
      ; :ruleset memory-helpers)
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty)
       ; (= (PtrPointsTo (PointsTo cells)) (PointsToCells ptr (TypeToPointees argty)))
       ; (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       ; (= vals (CellHasValues state cell)))
      ; ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      ; :ruleset memory-helpers)


(ruleset mem-simple)

; ============================
; NoAlias analysis
; ============================

(relation NoAlias (Expr Expr))

; Push NoAlias into if
(rule ((= if (If pred inputs thn els))
       (= (Get inputs i) inputs-i)
       (= (Get inputs j) inputs-j)
       (NoAlias inputs-i inputs-j)
       (= arg-i (Get (Arg ty (InIf which pred inputs)) i))
       (= arg-j (Get (Arg ty (InIf which pred inputs)) j)))
      ((NoAlias arg-i arg-j))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (lo-bound i) (IntB lo))
       (> lo 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((Bop (PtrAdd) e i)
       (= (hi-bound i) (IntB hi))
       (< hi 0))
      ((NoAlias e (Bop (PtrAdd) e i)))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Add) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (lo-bound diff) (IntB lo))
       (> lo 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((= p1 (Bop (PtrAdd) p i))
       (= p2 (Bop (PtrAdd) p (Bop (Sub) i diff)))
       (= (hi-bound diff) (IntB hi))
       (< hi 0))
      ((NoAlias p1 p2))
      :ruleset mem-simple)

(rule ((NoAlias x y))
      ((NoAlias y x))
      :ruleset mem-simple)

; ============================
; Memory optimizations
; ============================

(relation DidMemOptimization (String))

; A write then a load to different addresses can be swapped
(rule ((NoAlias write-addr load-addr)
       (= write (Top (Write) write-addr write-val state))
       (= load (Bop (Load) load-addr write)))
      ((let new-load (Bop (Load) load-addr state))
       (union
          (Get load 1)
          (Top (Write) write-addr write-val (Get new-load 1)))
       (union (Get load 0) (Get new-load 0))
       (DidMemOptimization "commute write then load")
      )
      :ruleset mem-simple)

; A load then a write to different addresses can be swapped
; Actually, does this break WeaklyLinear if the stored value depends on the
; loaded value? Commenting this out for now.
; (rule ((NoAlias load-addr write-addr)
;        (= load (Bop (Load) load-addr state))
;        (= write (Top (Write) write-addr write-val (Get load 1))))
;       ((let new-write (Top (Write) write-addr write-val state))
;        (let new-load (Bop (Load) load-addr new-write))
;        (union write (Get new-load 1))
;        (union (Get load 0) (Get new-load 0))
;        (DidMemOptimization "commute load then write")
;        )
;       :ruleset mem-simple)

; Two loads to the same address can be compressed
(rule ((= first-load (Bop (Load) addr state))
       (= second-load (Bop (Load) addr first-load)))
      ((union (Get first-load 0) (Get second-load 0))
       (union (Get first-load 1) (Get second-load 1))
       (DidMemOptimization "duplicate load")
       )
      :ruleset mem-simple)

; A write and a load to the same address can be forwarded
(rule ((= write (Top (Write) addr write-val state))
       (= load (Bop (Load) addr write)))
      ((union (Get load 0) write-val)
       (union (Get load 1) write)
       (DidMemOptimization "store forward")
       )
      :ruleset mem-simple)

; Two writes of the same value to the same address can be compressed
(rule ((= first-write (Top (Write) addr write-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union first-write second-write)
       (DidMemOptimization "duplicate write"))
      :ruleset mem-simple)

; A write shadows a previous write to the same address
(rule ((= first-write (Top (Write) addr shadowed-val state))
       (= second-write (Top (Write) addr write-val first-write)))
      ((union second-write (Top (Write) addr write-val state))
       (DidMemOptimization "shadowed write"))
      :ruleset mem-simple)

; A load doesn't change the state
; TODO: why does this break weaklylinear?
; (rule ((= load (Bop (Load) addr state)))
;       ((union (Get load 1) state))
;       :ruleset mem-simple)

; (rule ((DidMemOptimization _))
;       ((panic "DidMemOptimization"))
;       :ruleset mem-simple)

;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)


(function hoisted-loop (Expr Expr) bool :merge (or old new) )
(rule ((= loop (DoWhile in pred_out)))
      ((set (hoisted-loop in pred_out) false)) :ruleset always-run)

(constructor InExtendedLoop (Expr Expr Expr) Assumption)

;; mock function
(ruleset loop-inv-motion)

(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in pred_out))
       ;; the outter assumption of the loop 
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= false (hoisted-loop in pred_out))
       (= len (tuple-length in)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))

       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (InExtendedLoop in pred_out new_input))
       (let new_out_branch (Get (Arg new_input_type assum) len))

       ;; this two subst only change arg to arg with new type
       (let substed_pred_out
         (Subst assum
               (SubTuple (Arg new_input_type assum) 0 len) pred_out))
       (let inv_in_new_loop
            (Subst assum (SubTuple (Arg new_input_type assum) 0 len) inv))
       (let new_pred_out (Concat substed_pred_out (Single new_out_branch)))
       
       (let new_loop (DoWhile new_input new_pred_out))
       (union assum (InLoop new_input new_pred_out))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in pred_out)) 
       ;; don't hoist same loop again
       (set (hoisted-loop in pred_out) true)
      )
       :ruleset loop-inv-motion)


(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Const _n _ty _ctx)))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get (Arg ty ctx) i)) 
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out (+ i 1)))) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Function _name _tyin _tyout _out))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Top _op _x _y _z))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) (= true (is-inv-Expr loop _z)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Bop _op _x _y)) (BinaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Uop _op _x)) (UnaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get _tup _i))  
       (= true (is-inv-Expr loop _tup)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Concat _x _y))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Single _x))  
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Switch _pred _inputs _branches))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _inputs)) (= true (is-inv-ListExpr loop _branches)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (If _pred _input _then _else))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _input)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (DoWhile _in _pred-and-output))  
       (= true (is-inv-Expr loop _in)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Call _func _arg))  
       (= true (is-inv-Expr loop _arg)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Empty _ty _ctx))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Top _op _x _y _z)) 
       (= expr1 _z)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Bop _op _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Uop _op _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Concat _x _y)) 
       (= expr1 _y)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Single _x)) 
       (= expr1 _x)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Switch _pred _inputs _branches)) 
       (= expr1 _inputs)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _pred)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (If _pred _input _then _else)) 
       (= expr1 _input)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (DoWhile _in _pred-and-output)) 
       (= expr1 _in)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Call _func _arg)) 
       (= expr1 _arg)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)


(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _e)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1)) 
       (= false (is-inv-Expr loop expr2)) 
       (= expr2 (Alloc _id _e _state _ty)) 
       (= expr1 _state)) 
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty ctx)
  (Concat (Single (Const (Bool false) ty ctx2))
    (Single (Const constant ty ctx2))))
 (Single (Const constant ty ctx))
 :ruleset loop-simplify)
;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)

;;                      inputs, outputs -> number of iterations
;; The minimum possible guess is 1 because of do-while loops
;; TODO: dead loop deletion can turn loops with a false condition to a body
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset loop-iters-analysis)

;; For a loop that is false, its num iters is 1
(rule 
  ((= loop (DoWhile inputs outputs))
   (= (Const (Bool false) ty ctx) (Get outputs 0)))
  ((set (LoopNumItersGuess inputs outputs) 1))
:ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated before checking pred
;; TODO: we could make it work for decrementing loops
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by some constant each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while next_counter less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (/ (- end_constant start_const) increment))
  )
  :ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated after checking pred
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   (= body-arg (Get (Arg _ty _ctx) counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by a constant each loop
   (= next_counter (Bop (Add) body-arg
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while this counter less than end_constant
   (= pred (Bop (LessThan) body-arg
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (+ (/ (- end_constant start_const) increment) 1))
  )
  :ruleset loop-iters-analysis)

;; loop peeling rule
;; Only peel loops that we know iterate < 3 times
(constructor LoopPeeledPlaceholder (Expr) Assumption :unextractable)
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs))
  (< old_cost 3)
  )
 (
  (let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))

  (let new-loop-arg
    (Arg inputs-ty then-ctx))
  (let new-loop-body
    (Subst (LoopPeeledPlaceholder lhs) new-loop-arg outputs))
  (union (InLoop new-loop-arg new-loop-body) (LoopPeeledPlaceholder lhs))

  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
      executed-once-body ;; inputs are the body executed once
      (DoWhile new-loop-arg new-loop-body)
      (Arg inputs-ty else-ctx)))

  (set (LoopNumItersGuess new-loop-arg new-loop-body) (- old_cost 1))
  )
 :ruleset loop-peel)

(constructor TmpCtxUnroll (Expr Expr) Assumption)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let tmp-ctx (TmpCtxUnroll inputs outputs))
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst tmp-ctx one-iter
          (Subst tmp-ctx one-iter
            (Subst tmp-ctx one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union tmp-ctx actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
  )
  :ruleset loop-unroll)



(ruleset swap-if)

;; swaps the order of the then and else branches
;; in an if using Not

(rule
  ((= lhs (If pred inputs then else)))
  (
    (union lhs (If (Uop (Not) pred) inputs else then))
  )
  :ruleset swap-if)


;; for if statements with two outputs, swaps the order
;; of the outputs
(rule
  ((= lhs (If pred inputs then else))
   (= (tuple-length then) 2)
   (= (tuple-length else) 2))
  (
    (union
      (Concat (Single (Get lhs 1)) (Single (Get lhs 0)))
      (If pred inputs
          (Concat (Single (Get then 1)) (Single (Get then 0)))
          (Concat (Single (Get else 1)) (Single (Get else 0)))))
  )
  :ruleset swap-if)
;; this ruleset depends on swap_if running twice
;; swap_if un-permutes the outputs of the function and the if so this rule can match
(ruleset rec-to-loop)



;; this rule finds a recursive functions
;; with a base case and a tail-recursive call
;; transforms them into a loop
;; transforming functions that look like this:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start));
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;      } while (start[0]);
;;    }
;;    ret base_case(start);
;; }
;; for example, printBinary sums the results of recursive calls

(constructor TmpCtxRecToLoop (String Type Type Expr) Assumption)
(rule
  ((Function name in out body)
   (= body (If pred always-runs (Call name rec_case) base-case))
   (HasType always-runs start-ty)
   (HasType body func-ty))
  ((let tmp-ctx (TmpCtxRecToLoop name in out body))
   (let loop-inputs (Arg start-ty (InIf true pred always-runs)))
   (let loop-outputs
     (Concat
         (Single (Subst tmp-ctx rec_case pred))
         (Subst tmp-ctx rec_case always-runs)))
   (union tmp-ctx (InLoop loop-inputs loop-outputs))

   (let loop
     (DoWhile loop-inputs loop-outputs))
    
    
  ;; initial start value
   (let outer-if
     (If pred always-runs
         loop
         (Arg start-ty (InIf false pred always-runs))))
   (union body (Subst (InFunc name) outer-if base-case)))
  :ruleset rec-to-loop)


;; Stores information about how to use a binary
;; operator to accumulate values
;; (bop start-val base-case-op)
(relation Accum-Bop (BinaryOp i64 BinaryOp))

;; addition is easy, it starts at 0 and adds the result of the recursive call
(Accum-Bop (Add) 0 (Add))

;; subtraction starts at zero, but adds the base case at the end
(Accum-Bop (Sub) 0 (Add))

;; multiplication starts at 1, and multiplies the result of the recursive call
(Accum-Bop (Mul) 1 (Mul))

;; It seems like integers have these properties based on: https://stackoverflow.com/questions/69480173/which-arithmetic-properties-do-twos-complement-integers-have


;; same as above rule, but with an accumulator
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    if (pred) {
;;       ret name(rec_case(start)) + f(start);
;;    } else {
;;       ret base_case(start);
;;    }
;; }
;; into:
;; function name(inputs) {
;;    let start = always_runs(inputs);
;;    let acc = 0;
;;    if (start[0]) {
;;      do {
;;         start = always_runs(rec_case(start));
;;         acc = acc + extra(start);
;;      } while (start[0]);
;;    }
;;    ret base_case(start) + acc;
;; }
(constructor TmpCtxRecToLoop2 (String Expr Expr Expr) Assumption)
(rule
  ((Function name in out body)
   (= body (If pred always-runs then-case base-case))
   (= call (Call name rec-case))
   (= then-case
      (Concat (Single (Bop acc-op (Get call 0) extra))
              (Single (Get call 1))))
   (Accum-Bop acc-op initial-int base-case-op)
   (HasType always-runs start-ty)
   (= always-runs-len (tuple-length always-runs))
   (= start-ty (TupleT start-ty-list))
   (HasType body func-ty))
  ((let tmp-ctx (TmpCtxRecToLoop2 name pred then-case base-case))
   (let loop-ty
     (TupleT (TLConcat start-ty-list (TCons (IntT) (TNil)))))
   ;; recursive case in the loop
   (let new-rec-case
    (Subst tmp-ctx
           (SubTuple (Arg loop-ty tmp-ctx) 0 always-runs-len) rec-case))
   ;; extra computation in the loop
   (let new-extra
    (Subst tmp-ctx
           (SubTuple (Arg loop-ty tmp-ctx) 0 always-runs-len) extra))
   ;; acc starts at 0
   (let loop-inputs
     (Concat (Arg start-ty (InIf true pred always-runs)) (Single (Const (Int initial-int) start-ty (InIf true pred always-runs)))))
   (let loop-outputs
     (Concat
         (Single (Subst tmp-ctx new-rec-case pred))
         (Concat
           (Subst tmp-ctx new-rec-case always-runs)
           ;; add extra to acc
           (Single (Bop acc-op (Get (Arg loop-ty tmp-ctx) always-runs-len) new-extra)))))
   ;; loop starts at zero, adds extra each iteration
   (let loop
     (DoWhile loop-inputs loop-outputs))
   ;; union tmpctx
   (union tmp-ctx (InLoop loop-inputs loop-outputs))
  
   (let outer-if
     (If pred always-runs
         loop
         (Concat
           (Arg start-ty (InIf false pred always-runs))
           ;; otherwise acc is 0
           (Single (Const (Int 0) start-ty (InIf false pred always-runs))))))
   ;; base case over latest start value
   (let new-base-case
     (Subst (InFunc name) (SubTuple outer-if 0 always-runs-len) base-case))
   ;; add base case to acc
   (let res
     (Concat
      (Single (Bop base-case-op (Get new-base-case 0) (Get outer-if always-runs-len)))
      (Single (Get new-base-case 1))))
   (union body res))
  :ruleset rec-to-loop)

(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union lhs passed-through))
      :ruleset passthrough)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset passthrough)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(ruleset state-edge-passthrough)

(rule ((= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg arg_ty then_ctx) j))
       (= (Get else_ i) (Get (Arg arg_ty else_ctx) j))

       (HasType (Get then_ i) (Base (StateT))))

      ((let lhs (Get outputs i))
       (let new_inputs (TupleRemoveAt inputs j))

       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let old_then (TupleRemoveAt then_ i))
       (let old_else (TupleRemoveAt else_ i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleRemoveAt outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs (Get inputs j))
       ;; Be careful not to subsume the original if statement immediately,
       ;;  since TupleRemoveAt still needs to match on it
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset state-edge-passthrough)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) pred)
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; Pass through inverted if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool false) _ _thenctx))
       (= (Get else_ i) (Const (Bool true) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) (Uop (Not) pred))
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(ruleset loop-strength-reduction)

; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs
;; Get the input and output value of an invariant, or constant int, within the loop
;;             loop in   out
(relation lsr-inv (Expr Expr Expr))

; TODO: there may be a bug with finding the invariant, or it just may not be extracted.
; Can make this work on loop_with_mul_by_inv and a rust test later.
; (rule (
;     (= loop (DoWhile inputs pred-and-body))
;     (= (Get outputs (+ i 1)) (Get (Arg arg-type assm) i)))
;     ((inv loop (Get inputs i) (Get (Arg arg-type assm) i))) :ruleset always-run)
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf inputs loop-input-ctx)
    (ContextOf pred-and-body loop-output-ctx)
    (= constant (Const c out-type loop-output-ctx))
    (HasArgType inputs in-type)
    )
    ((lsr-inv loop (Const c in-type loop-input-ctx) constant)) :ruleset always-run)
(constructor TmpCtxLSR (Expr Expr) Assumption)
(rule 
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))
        (ContextOf pred-and-outputs loop-ctx)

        ; Find loop variable (argument that gets incremented with an invariant)
        (lsr-inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type assm) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (lsr-inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type assm) i)))
        (ContextOf old-mul loop-ctx)

        (= arg-type (TupleT ty-list))
        ; n is index of our new, temporary variable d
        (= n (tuple-length inputs))
    )
    (
        (let tmp-ctx (TmpCtxLSR inputs pred-and-outputs))
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Construct optimized theta
        ; new-inputs already has the correct context
        (let new-inputs (Concat inputs (Single d-init)))

        ; We need to create a new type, with one more input
        (let new-arg-ty (TupleT (TLConcat ty-list (TCons (IntT) (TNil)))))
        (let replace-arg (SubTuple (Arg new-arg-ty tmp-ctx) 0 n))

        ; Value of d in loop. Add context to addend
        (let d-out (Bop (Add) (Get (Arg new-arg-ty tmp-ctx) n)
                   (Subst tmp-ctx replace-arg addend)))

        ; build the old body, making sure to set the correct arg type and context
        (let new-body
          (Concat
            (Subst tmp-ctx replace-arg pred-and-outputs)
            (Single d-out)))

        (let new-loop (DoWhile new-inputs new-body))

        (let new-c (Subst tmp-ctx replace-arg c-out))

        ; Now that we have the new loop, union the temporary context with the actual ctx
        (union tmp-ctx (InLoop new-inputs new-body))

        ; Substitute d for the *i expression
        (let new-mul
            (Bop (Mul) new-c (Get replace-arg i)))
        (union (Get (Arg new-arg-ty tmp-ctx) n) new-mul)

        ; Subsume the multiplication in the new loop to prevent
        ; from firing loop strength reduction again on the new loop
        ; Workaround of egglog issue: https://github.com/egraphs-good/egglog/issues/462
        ; add the expression we are about to subsume
        (let before
          (Bop (Mul) new-c (Get replace-arg i)))
        ; now subsume it
        (subsume
          (Bop (Mul) new-c (Get replace-arg i)))

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
    )
    :ruleset loop-strength-reduction
)
(relation IVTNewInputsAnalysisDemand (Expr))

(ruleset ivt-analysis)

(sort IVTRes)
;;                              perm passthrough-perm passthrough-type passthrough-type-len
(constructor IVTAnalysisRes (Expr Expr             TypeList         i64) IVTRes)
(constructor IVTMin (IVTRes IVTRes) IVTRes)

(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (<= len1 len2))
      ((union lhs (IVTAnalysisRes _a _b _c len1)))
        :ruleset ivt-analysis)
(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (> len1 len2))
      ((union lhs (IVTAnalysisRes _d _e _f len2)))
        :ruleset ivt-analysis)


;; use an analysis to avoid exploring all combinations of passthrough vs not passed through values. Always prefer not passed through
;;                                  expr1 curr  if  result
(function IVTNewInputsAnalysisImpl (Expr  Expr  Node) IVTRes :merge (IVTMin old new))

;; IVTNewInputsAnalysis computes a permutation perm which corresponds to accessing elements of an if region.
;; It also makes accesses of passthrough arguments access new indices after the length of the if region.
;; For example, if expr1 is: [get(if, 1), get(arg, 1), get(if, 0), get(arg, 3)]
;; It produces a new permutation: [get(arg, 1), get(arg, 2), get(arg, 0), get(arg, 3)]
;; The accesses of the if statement remain unchanged, and the accesses of the passthrough arguments are moved to the end.
;; This new permutation is intended to be used with a substitution argument (Concat if-statement passthrough-args)
;; Also produced is a passthrough-perm, which selects all of the passthrough arguments and puts them in a single tuple
;;                              expr1 if result
(function IVTNewInputsAnalysis (Expr  Node) IVTRes :merge (IVTMin old new))


(rule (
    (DoWhile inpW outW)
) (
    (IVTNewInputsAnalysisDemand outW)
) :ruleset ivt-analysis)

(rule (
    (IVTNewInputsAnalysisDemand loop-body)
    ;; first input is a predicate
    (= loop-body (Concat (Single pred) rest))
    ;; another input is an if statement with shared predicate
    (= if-eclass (If pred inputs thn else))
    (= (Get loop-body i) (Get if-eclass j))
    (!= i 0)
) (
    (let perm (Empty (TmpType) (InFunc "no-ctx")))
    (set
     (IVTNewInputsAnalysisImpl loop-body rest (IfNode if-eclass pred inputs thn else))
     (IVTAnalysisRes perm perm (TNil) 0))
) :ruleset ivt-analysis)

;; recursive case for accessing the if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get if-eclass ith)) rest))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm  pperm passthrough-tys len))
) :ruleset ivt-analysis)

;; recursive case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Concat (Single (Get (Arg ty ctx) ith)) rest))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysisImpl loop-body rest ifnode)
         (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)

; base case for accessing if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body (Single last) ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= last (Get if-eclass ith))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm pperm passthrough-tys len))
) :ruleset ivt-analysis)

; base case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr ifnode) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= ifnode (IfNode if-eclass pred inputs then else))
    (= curr (Single (Get (Arg ty ctx) ith)))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= (tuple-length if-eclass) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (InFunc "no-ctx")) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (InFunc "no-ctx")) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysis loop-body ifnode) (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)


(ruleset loop-inversion)

(constructor TmpCtxLoopInversion (Expr Expr) Assumption)
(rule (
    (= loop (DoWhile inpW outW))
    (= (IVTNewInputsAnalysis outW ifnode) (IVTAnalysisRes perm pperm passthrough-tys _len))
    (= ifnode (IfNode if if-cond if-inputs then else))
    (= if-inputs-len (tuple-length if-inputs))
    (= passthrough-len (TypeList-length passthrough-tys))

    (ContextOf inpW outer-ctx)
    (ContextOf if-inputs if-ctx)
    (HasType if-inputs inputs-ty)
    (= inputs-ty (TupleT inputs-ty-list))
) (
    (let tmp-ctx (TmpCtxLoopInversion inpW outW))
    ;; new peeled condition, checks the if's condition before the first iteration
    (let new-if-cond (Subst outer-ctx inpW if-cond))

    ;; new inputs to the if are 1) the inputs run once unconditionally concatted with
    ;; 2) the passthrough values
    (let new-if-inp
        (Concat (Subst outer-ctx inpW if-inputs)
                (Subst outer-ctx inpW pperm)))
    ;; if contexts
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-arg-ty (TupleT (TLConcat inputs-ty-list passthrough-tys)))
    (let new-loop-arg (Arg new-loop-arg-ty tmp-ctx))
    (let new-loop-context tmp-ctx)

    ;; body
    ;; loop begins by running the then branch of the if statement, which uses the first if-inputs-length elements of arg
    (let then-arg (SubTuple new-loop-arg 0 if-inputs-len))
    (let new-then-branch
        (Subst new-loop-context then-arg then))
    ;; the inputs are then run on the combination of
    ;; the then branch and the passthrough values
    (let then-branch-and-passthrough
      (Concat new-then-branch (SubTuple new-loop-arg if-inputs-len passthrough-len)))
    ;; permute them to move passthrough and if outputs back
    ;; to where if-inputs and if-cond expect them to be
    (let permuted-then-branch-and-passthrough
      (Subst new-loop-context then-branch-and-passthrough perm))
    ;; substitute into inputs and condi
    (let new-inputs-after-then-branch 
        (Subst new-loop-context permuted-then-branch-and-passthrough
            (Concat (Single if-cond) if-inputs)))
    (let new-loop-outputs
        (Concat new-inputs-after-then-branch
           (SubTuple new-loop-arg if-inputs-len passthrough-len)))

    (let new-loop (DoWhile (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg new-loop-arg-ty new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let final-if-inputs
       (SubTuple new-if 0 if-inputs-len))
    (let else-branch-end
        (Subst outer-ctx final-if-inputs else))
    (let else-branch-end-and-passthrough
        (Concat else-branch-end
               (SubTuple new-if if-inputs-len passthrough-len)))
    (let final-permuted
        (Subst outer-ctx else-branch-end-and-passthrough perm))

    (union final-permuted loop)
    (union new-loop-context (InLoop (Arg new-loop-arg-ty new-if-true-ctx) new-loop-outputs))

    (subsume (DoWhile inpW outW))
) :ruleset loop-inversion)

(ruleset cicm)
(ruleset cicm-index)

(relation InvCodeMotionCandidate (Expr Expr))

(rule (
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (= (TCPair t1 c2) (ExtractedExpr e2))
        (ContextOf e1 (InIf true pred1 orig_ins3))
        (ContextOf e2 (InIf false pred2 orig_ins4))
        (!= e1 e2)
     )
     ((InvCodeMotionCandidate e1 e2))
     :ruleset cicm-index)


(rule (
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (= e1 (Uop o x))
        (HasType e1 (Base ty))
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (ContextOf e1 (InIf true pred orig_ins))

        (= e2 (Uop o y))
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)
        (ContextOf e2 (InIf false pred orig_ins))

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Uop o (Subst if_tr st_tr x))
        (Uop o (Subst if_fa st_fa y))
        ; Now subsume:
        (subsume (Uop o (Subst if_tr st_tr x)))
        (subsume (Uop o (Subst if_fa st_fa y)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)

       

(rule (
        (InvCodeMotionCandidate e1 e2)
        (= if_e (If pred orig_ins thn els))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (ContextOf if_e outer_ctx)

        (ContextOf e1 (InIf true pred orig_ins))
        (ContextOf e2 (InIf false pred orig_ins))
        (= e1 (Bop o x1 y1))
        
        (= e2 (Bop o x2 y2))
        
        (= (TCPair t1 c1) (ExtractedExpr e1))
        (> 10 (Expr-size e1))
        (ExprIsPure e1)
        (HasType e1 (Base ty))
        

        
        (HasType e2 (Base ty))
        (= (TCPair t2 c2) (ExtractedExpr e2))
        (> 10 (Expr-size e2))
        (ExprIsPure e2)

        (= t1 t2)
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; pull the term out to the outer context
        (let new_term (TermSubst outer_ctx orig_ins t1)) 
        
        ; Add it as an input to the new if
        (let new_ins (Concat orig_ins (Single new_term)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; SubTuple- this is the sublist of the new inputs that corresponds
        ; to the original inputs (without the pulled-out input)
        (let st_tr (SubTuple (Arg new_ins_ty if_tr) 0 orig_ins_len))
        (let st_fa (SubTuple (Arg new_ins_ty if_fa) 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))
        
        ; Union the new arg with the original expr in each branch
        (union (Get (Arg new_ins_ty if_tr) orig_ins_len) (Subst if_tr st_tr e1))
        (union (Get (Arg new_ins_ty if_fa) orig_ins_len) (Subst if_fa st_fa e2))
        
        ; Subsume the original exprs now that the new arg is there
        ; Doing this prevents us from pulling the same exprs out of the new if
        ; Can only subsume an e-node (not an e-class), and we don't want to
        ; subsume the Subst node directly, since it won't have a chance to do
        ; the actual substitution, so manually compute the first round of
        ; substitution so that we can subsume the Uop e-nodes.
        ; First construct the Uop, so that it exists in the e-graph, because
        ; you can't subsume things that don't exist in the e-graph already.
        (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1))
        (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2))
        ; Now subsume:
        (subsume (Bop o (Subst if_tr st_tr x1) (Subst if_tr st_tr y1)))
        (subsume (Bop o (Subst if_fa st_fa x2) (Subst if_fa st_fa y2)))

        ; Create new if and union it with the original
        (union if_e (If pred new_ins new_thn new_els))
      )
    :ruleset cicm)


(ruleset push-in)

; new version of the rule where one side of bop is constant
(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o (Const c ty outer_ctx) x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(c, x) in the new regions
        (union (Get arg_tr i) (Bop o (Const c new_ins_ty if_tr) (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Bop o (Const c new_ins_ty if_fa) (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Bop o x (Const c ty outer_ctx)) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Bop(x, c) in the new regions
        (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Const c new_ins_ty if_tr)))
        (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Const c new_ins_ty if_fa)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

(rule (
        (= if_e (If pred orig_inputs thn els))
        (ContextOf if_e outer_ctx)
        (= (Uop o x) (Get orig_inputs i))
        (HasArgType thn (TupleT tylist))
        (HasArgType els (TupleT tylist))
        (HasType x (Base x_ty))
        (= orig_ins_len (TypeList-length tylist))
      )
      (
        ; New inputs
        (let new_ins (Concat orig_inputs (Single x)))
        (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TNil)))))

        ; New contexts
        (let if_tr (InIf true  pred new_ins))
        (let if_fa (InIf false pred new_ins))

        ; New args
        (let arg_tr (Arg new_ins_ty if_tr))
        (let arg_fa (Arg new_ins_ty if_fa))

        ; SubTuple
        (let st_tr (SubTuple arg_tr 0 orig_ins_len))
        (let st_fa (SubTuple arg_fa 0 orig_ins_len))

        ; New regions
        (let new_thn (Subst if_tr st_tr thn))
        (let new_els (Subst if_fa st_fa els))

        ; Union the original input with Uop(x) in the new regions
        (union (Get arg_tr i) (Uop o (Get arg_tr orig_ins_len)))
        (union (Get arg_fa i) (Uop o (Get arg_fa orig_ins_len)))

        ; Union the ifs
        (union if_e (If pred new_ins new_thn new_els))
      )
      :ruleset push-in)

; OLD VERSION - Too slow for now
; ; push bop input into region
; (rule (
;         (= if_e (If pred orig_inputs thn els))
;         (ContextOf if_e outer_ctx)
;         (= (Bop o x y) (Get orig_inputs i))
;         (HasArgType thn (TupleT tylist))
;         (HasArgType els (TupleT tylist))
;         (HasType x (Base x_ty))
;         (HasType y (Base y_ty))
;       )
;       (
;         ; New inputs
;         (let new_ins (Concat orig_inputs (Concat (Single x) (Single y))))
;         (let new_ins_ty (TupleT (TLConcat tylist (TCons x_ty (TCons y_ty (TNil))))))

;         ; New contexts
;         (let if_tr (InIf true  pred new_ins))
;         (let if_fa (InIf false pred new_ins))
        
;         ; New args
;         (let arg_tr (Arg new_ins_ty if_tr))
;         (let arg_fa (Arg new_ins_ty if_fa))

;         ; SubTuple
;         (let orig_ins_len (TypeList-length tylist))
;         (let st_tr (SubTuple arg_tr 0 orig_ins_len))
;         (let st_fa (SubTuple arg_fa 0 orig_ins_len))

;         ; New regions
;         (let new_thn (Subst if_tr st_tr thn))
;         (let new_els (Subst if_fa st_fa els))

;         ; Union the original input with Bop(x, y) in the new regions
;         (union (Get arg_tr i) (Bop o (Get arg_tr orig_ins_len) (Get arg_tr (+ orig_ins_len 1))))
;         (union (Get arg_fa i) (Bop o (Get arg_fa orig_ins_len) (Get arg_fa (+ orig_ins_len 1))))

;         ; Union the ifs
;         (union if_e (If pred new_ins new_thn new_els))
;       )
;       :ruleset push-in)
;; use these rules to clean up the database, removing helpers
;; this makes the visualization easier to read

(ruleset debug-deletes)

(rule ((HasType a b))
      ((delete (HasType a b)))
      :ruleset debug-deletes)

(rule ((BodyContainsExpr a b))
      ((delete (BodyContainsExpr a b)))
      :ruleset debug-deletes)

(rule ((ExprIsPure e))
      ((delete (ExprIsPure e)))
      :ruleset debug-deletes)

(rule ((HasArgType e ty))
      ((delete (HasArgType e ty)))
      :ruleset debug-deletes)

(rule ((is-inv-Expr e ty))
      ((delete (is-inv-Expr e ty)))
      :ruleset debug-deletes)

(rule ((tuple-length e))
      ((delete (tuple-length e)))
      :ruleset debug-deletes)

(rule ((BinaryOpIsPure e))
      ((delete (BinaryOpIsPure e)))
      :ruleset debug-deletes)

(rule ((ContextOf e a))
      ((delete (ContextOf e a)))
      :ruleset debug-deletes)

(rule ((ExprIsResolved e))
      ((delete (ExprIsResolved e)))
      :ruleset debug-deletes)

(rule ((bop->string a b))
      ((delete (bop->string a b)))
      :ruleset debug-deletes)

(rule ((bpred-of-type a b))
      ((delete (bpred-of-type a b)))
      :ruleset debug-deletes)

(rule ((PureType e))
      ((delete (PureType e)))
      :ruleset debug-deletes)

(rule ((PointsToCells a b))
      ((delete (PointsToCells a b)))
      :ruleset debug-deletes)

(rule ((TuplePointsTo e))
      ((delete (TuplePointsTo e)))
      :ruleset debug-deletes)

(rule ((Resolved-List<PtrPointees> e))
      ((delete (Resolved-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((TypeListToList<PtrPointees> e))
      ((delete (TypeListToList<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<PtrPointees> a b))
      ((delete (Cons-List<PtrPointees> a b)))
      :ruleset debug-deletes)

(rule ((Nil-List<PtrPointees>))
      ((delete (Nil-List<PtrPointees>)))
      :ruleset debug-deletes)

(rule ((Length-List<PtrPointees> e))
      ((delete (Length-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((At-List<PtrPointees> a b c))
      ((delete (At-List<PtrPointees> a b c)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<PtrPointees> a))
      ((delete (IsNonEmpty-List<PtrPointees> a)))
      :ruleset debug-deletes)

(rule ((Resolved-List<i64+IntInterval> e))
      ((delete (Resolved-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<i64+IntInterval> a b c))
      ((delete (Cons-List<i64+IntInterval> a b c)))
      :ruleset debug-deletes)

(rule ((Nil-List<i64+IntInterval>))
      ((delete (Nil-List<i64+IntInterval>)))
      :ruleset debug-deletes)

(rule ((Length-List<i64+IntInterval> e))
      ((delete (Length-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((At-List<i64+IntInterval> a b c d))
      ((delete (At-List<i64+IntInterval> a b c d)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<i64+IntInterval> a))
      ((delete (IsNonEmpty-List<i64+IntInterval> a)))
      :ruleset debug-deletes)

(rule ((TypeList-ith a b))
      ((delete (TypeList-ith a b)))
      :ruleset debug-deletes)

(rule ((InIf a b c))
      ((delete (InIf a b c)))
      :ruleset debug-deletes)
(rule ((InLoop a b))
      ((delete (InLoop a b)))
      :ruleset debug-deletes)
(rule ((InFunc a))
      ((delete (InFunc a)))
      :ruleset debug-deletes)

(rule ((TupleT a))
      ((delete (TupleT a)))
      :ruleset debug-deletes)
(rule ((TCons a b))
      ((delete (TCons a b)))
      :ruleset debug-deletes)
(rule ((TNil))
      ((delete (TNil)))
      :ruleset debug-deletes)
(rule ((Base a))
      ((delete (Base a)))
      :ruleset debug-deletes)
(rule ((IntT))
      ((delete (IntT)))
      :ruleset debug-deletes)

;; Hacker's delight optimizations

(ruleset hacker)

;; A simple analysis to identify loops that run exactly #popcount times

;; IsIsEven e x => e is a boolean expression that checks whether x is an even number
(relation IsIsEven (Expr Expr))

(rule (
    (= two (Const (Int 2) ty ctx))
    (= e (Bop (Eq) x (Bop (Mul) (Bop (Div) x two) two)))
) (
    (IsIsEven e x)
) :ruleset hacker)

;; NTZIterations lp n pos => loop lp runs exactly number_of_trailing_zeros(n) times at index pos
(relation NTZIterations (Expr Expr i64))

(rule (
    ;; Grab the outer if
    (= outerif (If cond inputs evenbr oddbr))
    ;; There exists an argument n
    (= n (Get inputs i))
    ;; The condition is on the parity of n
    (IsIsEven cond n)
    ;; In the even/true branch, there is a loop
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    ;; n is passed into to the loop
    (= (Get lp_inputs j) (Get (Arg _ty1 _ctx1) i))
    ;; the loop continues as long as n / 2 is even
    (= two (Const (Int 2) _ty2 _ctx2))
    (= nd2 (Bop (Div) (Get (Arg _ty3 _ctx3) j) two))
    (IsIsEven (Get lp_pred_outputs 0) nd2)
    ;; n is divided by 2 every loop
    (= nd2 (Get lp_pred_outputs (+ j 1)))
    ;; In the odd/false branch, we look for an n
    (= (Get (Arg _ty4 _ctx4) i) (Get oddbr j))
) (
    (NTZIterations outerif n j)
) :ruleset hacker)

;; Identify and optimize lowbit

(rule (
    (NTZIterations outerif n i)
    (= outerif (If cond inputs evenbr oddbr))
    ;; In the even branch, it returns a value that doubles every iter
    (= evenbr (DoWhile lp_inputs lp_pred_outputs))
    (= (Const (Int 1) _ty1 _ctx1) (Get lp_inputs j))
    (= two (Const (Int 2) _ty2 _ctx2))
    (= (Bop (Mul) (Get (Arg _ty3 _ctx3) j) two) (Get lp_pred_outputs (+ j 1)))    
    ;; In the odd branch, it returns an 1
    (= (Const (Int 1) _ty0 _ctx0) (Get oddbr j))
) (
    (let lowbitn (Bop (Bitand) n (Uop (Neg) n)))
    (union (Get outerif j) lowbitn)
    (union (Get outerif i) (Bop (Div) n lowbitn))
) :ruleset hacker)

;; Try to do a state-edge-passthrough for loops
;; NLZIterations guarantees termination for non-zero values
;; lowbit(0) is undefined behavior

(constructor DummyLoopContext (Expr Expr Expr) Assumption)

(rule (
    (NTZIterations anyif n i)
    (= anyif (If cond inputs thenbr elsebr))
    (= thenbr (DoWhile lpinputs pred_outputs))
    (= (Get pred_outputs (+ j 1)) (Get (Arg arg_ty then_ctx) j))
    (HasType (Get pred_outputs (+ j 1)) (Base (StateT)))
) (
    (let newlpinputs (TupleRemoveAt lpinputs j))
    (let newpred_outputs (TupleRemoveAt pred_outputs (+ j 1)))
    
    (let newlpctx (DummyLoopContext newlpinputs newpred_outputs pred_outputs))

    (let newbody (DropAt newlpctx j newpred_outputs))

    (union newlpctx (InLoop newlpinputs newbody))

    (let newlp (DoWhile newlpinputs newbody))
    (let oldlp (TupleRemoveAt thenbr j))

    (union newlp oldlp)

    (union (Get thenbr j) (Get lpinputs j))

) :ruleset hacker)

(unstable-combined-ruleset cheap-optimizations
    hacker
loop-simplify
interval-rewrite
always-switch-rewrite
peepholes
)

(unstable-combined-ruleset all-optimizations
    select_opt
loop-unroll
switch_rewrite
loop-inv-motion
loop-strength-reduction
cicm
push-in
hacker
loop-simplify
interval-rewrite
always-switch-rewrite
peepholes
)
    

; required by function_inlining_unoins
; Function inlining unions
(relation InlinedCall (String Expr))

(ruleset initialization)
(rule () (
    ; Program nodes
    (let __tmp0 (Int 390))
(let __tmp1 (StateT ))
(let __tmp2 (TNil ))
(let __tmp3 (TCons __tmp1 __tmp2))
(let __tmp4 (TupleT __tmp3))
(let __tmp5 (InFunc "main"))
(let __tmp6 (Const __tmp0 __tmp4 __tmp5))
(let __tmp7 (Single __tmp6))
(let __tmp8 (Arg __tmp4 __tmp5))
(let __tmp9 (Concat __tmp7 __tmp8))
(let __tmp10 (Call "vector_new" __tmp9))
(let __tmp11 (Get __tmp9 0))
(let __tmp12 (Get __tmp9 1))
(let __tmp13 (FloatT ))
(let __tmp14 (PointerT __tmp13))
(let __tmp15 (Alloc 0 __tmp11 __tmp12 __tmp14))
(let __tmp16 (Int 410))
(let __tmp17 (Const __tmp16 __tmp4 __tmp5))
(let __tmp18 (Single __tmp17))
(let __tmp19 (Get __tmp10 1))
(let __tmp20 (Single __tmp19))
(let __tmp21 (Concat __tmp18 __tmp20))
(let __tmp22 (Call "vector_new" __tmp21))
(let __tmp23 (Get __tmp21 0))
(let __tmp24 (Get __tmp21 1))
(let __tmp25 (Alloc 0 __tmp23 __tmp24 __tmp14))
(let __tmp26 (Get __tmp22 1))
(let __tmp27 (Single __tmp26))
(let __tmp28 (Concat __tmp7 __tmp27))
(let __tmp29 (Concat __tmp18 __tmp28))
(let __tmp30 (Call "matrix_new" __tmp29))
(let __tmp31 (Mul ))
(let __tmp32 (Get __tmp29 1))
(let __tmp33 (Get __tmp29 0))
(let __tmp34 (Bop __tmp31 __tmp32 __tmp33))
(let __tmp35 (Get __tmp29 2))
(let __tmp36 (Alloc 0 __tmp34 __tmp35 __tmp14))
(let __tmp37 (Get __tmp10 0))
(let __tmp38 (Single __tmp37))
(let __tmp39 (Get __tmp22 0))
(let __tmp40 (Single __tmp39))
(let __tmp41 (Get __tmp30 0))
(let __tmp42 (Single __tmp41))
(let __tmp43 (Float 410.0))
(let __tmp44 (Const __tmp43 __tmp4 __tmp5))
(let __tmp45 (Single __tmp44))
(let __tmp46 (Float 390.0))
(let __tmp47 (Const __tmp46 __tmp4 __tmp5))
(let __tmp48 (Single __tmp47))
(let __tmp49 (Get __tmp30 1))
(let __tmp50 (Single __tmp49))
(let __tmp51 (Concat __tmp48 __tmp50))
(let __tmp52 (Concat __tmp7 __tmp51))
(let __tmp53 (Concat __tmp45 __tmp52))
(let __tmp54 (Concat __tmp18 __tmp53))
(let __tmp55 (Concat __tmp42 __tmp54))
(let __tmp56 (Concat __tmp40 __tmp55))
(let __tmp57 (Concat __tmp38 __tmp56))
(let __tmp58 (Call "init" __tmp57))
(let __tmp59 (LessThan ))
(let __tmp60 (Int 0))
(let __tmp61 (Const __tmp60 __tmp4 __tmp5))
(let __tmp62 (Get __tmp57 5))
(let __tmp63 (Bop __tmp59 __tmp61 __tmp62))
(let __tmp64 (Get __tmp57 7))
(let __tmp65 (Single __tmp64))
(let __tmp66 (Float 0.0))
(let __tmp67 (Const __tmp66 __tmp4 __tmp5))
(let __tmp68 (Single __tmp67))
(let __tmp69 (Float 1.0))
(let __tmp70 (Const __tmp69 __tmp4 __tmp5))
(let __tmp71 (Single __tmp70))
(let __tmp72 (Single __tmp61))
(let __tmp73 (Int 1))
(let __tmp74 (Const __tmp73 __tmp4 __tmp5))
(let __tmp75 (Single __tmp74))
(let __tmp76 (Get __tmp57 2))
(let __tmp77 (Single __tmp76))
(let __tmp78 (Single __tmp62))
(let __tmp79 (Get __tmp57 4))
(let __tmp80 (Single __tmp79))
(let __tmp81 (Get __tmp57 3))
(let __tmp82 (Single __tmp81))
(let __tmp83 (Get __tmp57 1))
(let __tmp84 (Single __tmp83))
(let __tmp85 (Get __tmp57 0))
(let __tmp86 (Single __tmp85))
(let __tmp87 (Get __tmp57 6))
(let __tmp88 (Single __tmp87))
(let __tmp89 (Concat __tmp86 __tmp88))
(let __tmp90 (Concat __tmp84 __tmp89))
(let __tmp91 (Concat __tmp82 __tmp90))
(let __tmp92 (Concat __tmp80 __tmp91))
(let __tmp93 (Concat __tmp78 __tmp92))
(let __tmp94 (Concat __tmp77 __tmp93))
(let __tmp95 (Concat __tmp75 __tmp94))
(let __tmp96 (Concat __tmp72 __tmp95))
(let __tmp97 (Concat __tmp71 __tmp96))
(let __tmp98 (Concat __tmp68 __tmp97))
(let __tmp99 (Concat __tmp65 __tmp98))
(let __tmp100 (IntT ))
(let __tmp101 (TCons __tmp13 __tmp2))
(let __tmp102 (TCons __tmp14 __tmp101))
(let __tmp103 (TCons __tmp14 __tmp102))
(let __tmp104 (TCons __tmp100 __tmp103))
(let __tmp105 (TCons __tmp13 __tmp104))
(let __tmp106 (TCons __tmp100 __tmp105))
(let __tmp107 (TCons __tmp14 __tmp106))
(let __tmp108 (TCons __tmp100 __tmp107))
(let __tmp109 (TCons __tmp100 __tmp108))
(let __tmp110 (TCons __tmp13 __tmp109))
(let __tmp111 (TCons __tmp13 __tmp110))
(let __tmp112 (TCons __tmp1 __tmp111))
(let __tmp113 (TupleT __tmp112))
(let __tmp114 (InIf true __tmp63 __tmp99))
(let __tmp115 (Arg __tmp113 __tmp114))
(let __tmp116 (InFunc " loop_ctx_10"))
(let __tmp117 (Arg __tmp113 __tmp116))
(let __tmp118 (Get __tmp117 10))
(let __tmp119 (Single __tmp118))
(let __tmp120 (Get __tmp117 3))
(let __tmp121 (Single __tmp120))
(let __tmp122 (FDiv ))
(let __tmp123 (Get __tmp117 1))
(let __tmp124 (Single __tmp123))
(let __tmp125 (Get __tmp117 11))
(let __tmp126 (Single __tmp125))
(let __tmp127 (Get __tmp117 0))
(let __tmp128 (Single __tmp127))
(let __tmp129 (Concat __tmp126 __tmp128))
(let __tmp130 (Concat __tmp124 __tmp129))
(let __tmp131 (Call "fmod" __tmp130))
(let __tmp132 (Get __tmp131 0))
(let __tmp133 (Bop __tmp122 __tmp132 __tmp125))
(let __tmp134 (Single __tmp133))
(let __tmp135 (Get __tmp131 1))
(let __tmp136 (Single __tmp135))
(let __tmp137 (Concat __tmp134 __tmp136))
(let __tmp138 (Concat __tmp121 __tmp137))
(let __tmp139 (Concat __tmp119 __tmp138))
(let __tmp140 (Call "vector_set" __tmp139))
(let __tmp141 (FAdd ))
(let __tmp142 (Get __tmp117 2))
(let __tmp143 (Bop __tmp141 __tmp123 __tmp142))
(let __tmp144 (Single __tmp143))
(let __tmp145 (Single __tmp142))
(let __tmp146 (Add ))
(let __tmp147 (Get __tmp117 4))
(let __tmp148 (Bop __tmp146 __tmp147 __tmp120))
(let __tmp149 (Single __tmp148))
(let __tmp150 (Single __tmp147))
(let __tmp151 (Get __tmp117 5))
(let __tmp152 (Single __tmp151))
(let __tmp153 (Get __tmp117 6))
(let __tmp154 (Single __tmp153))
(let __tmp155 (Get __tmp117 7))
(let __tmp156 (Single __tmp155))
(let __tmp157 (Get __tmp117 8))
(let __tmp158 (Single __tmp157))
(let __tmp159 (Get __tmp117 9))
(let __tmp160 (Single __tmp159))
(let __tmp161 (Concat __tmp158 __tmp160))
(let __tmp162 (Concat __tmp156 __tmp161))
(let __tmp163 (Concat __tmp154 __tmp162))
(let __tmp164 (Concat __tmp119 __tmp126))
(let __tmp165 (Concat __tmp163 __tmp164))
(let __tmp166 (Concat __tmp152 __tmp165))
(let __tmp167 (Concat __tmp150 __tmp166))
(let __tmp168 (Concat __tmp149 __tmp167))
(let __tmp169 (Concat __tmp145 __tmp168))
(let __tmp170 (Concat __tmp144 __tmp169))
(let __tmp171 (Concat __tmp140 __tmp170))
(let __tmp172 (Get __tmp171 3))
(let __tmp173 (Get __tmp171 6))
(let __tmp174 (Bop __tmp59 __tmp172 __tmp173))
(let __tmp175 (Single __tmp174))
(let __tmp176 (Concat __tmp175 __tmp171))
(let __tmp177 (DoWhile __tmp115 __tmp176))
(let __tmp178 (InIf false __tmp63 __tmp99))
(let __tmp179 (Arg __tmp113 __tmp178))
(let __tmp180 (If __tmp63 __tmp99 __tmp177 __tmp179))
(let __tmp181 (Get __tmp180 0))
(let __tmp182 (Single __tmp181))
(let __tmp183 (Get __tmp180 2))
(let __tmp184 (Single __tmp183))
(let __tmp185 (Get __tmp180 5))
(let __tmp186 (Single __tmp185))
(let __tmp187 (Get __tmp180 7))
(let __tmp188 (Single __tmp187))
(let __tmp189 (Get __tmp180 9))
(let __tmp190 (Single __tmp189))
(let __tmp191 (Concat __tmp82 __tmp190))
(let __tmp192 (Concat __tmp188 __tmp191))
(let __tmp193 (Concat __tmp78 __tmp192))
(let __tmp194 (Concat __tmp186 __tmp193))
(let __tmp195 (Concat __tmp75 __tmp194))
(let __tmp196 (Concat __tmp72 __tmp195))
(let __tmp197 (Concat __tmp184 __tmp196))
(let __tmp198 (Concat __tmp68 __tmp197))
(let __tmp199 (Concat __tmp182 __tmp198))
(let __tmp200 (TCons __tmp14 __tmp2))
(let __tmp201 (TCons __tmp100 __tmp200))
(let __tmp202 (TCons __tmp13 __tmp201))
(let __tmp203 (TCons __tmp100 __tmp202))
(let __tmp204 (TCons __tmp14 __tmp203))
(let __tmp205 (TCons __tmp100 __tmp204))
(let __tmp206 (TCons __tmp100 __tmp205))
(let __tmp207 (TCons __tmp13 __tmp206))
(let __tmp208 (TCons __tmp13 __tmp207))
(let __tmp209 (TCons __tmp1 __tmp208))
(let __tmp210 (TupleT __tmp209))
(let __tmp211 (InFunc " loop_ctx_9"))
(let __tmp212 (Arg __tmp210 __tmp211))
(let __tmp213 (Get __tmp212 3))
(let __tmp214 (Get __tmp212 8))
(let __tmp215 (Bop __tmp59 __tmp213 __tmp214))
(let __tmp216 (Single __tmp215))
(let __tmp217 (InIf true __tmp215 __tmp212))
(let __tmp218 (Arg __tmp210 __tmp217))
(let __tmp219 (Get __tmp218 9))
(let __tmp220 (Single __tmp219))
(let __tmp221 (Get __tmp218 3))
(let __tmp222 (Single __tmp221))
(let __tmp223 (Get __tmp218 1))
(let __tmp224 (Single __tmp223))
(let __tmp225 (Get __tmp218 7))
(let __tmp226 (Single __tmp225))
(let __tmp227 (Get __tmp218 0))
(let __tmp228 (Single __tmp227))
(let __tmp229 (Concat __tmp226 __tmp228))
(let __tmp230 (Concat __tmp224 __tmp229))
(let __tmp231 (Call "fmod" __tmp230))
(let __tmp232 (Get __tmp231 0))
(let __tmp233 (Bop __tmp122 __tmp232 __tmp225))
(let __tmp234 (Single __tmp233))
(let __tmp235 (Get __tmp231 1))
(let __tmp236 (Single __tmp235))
(let __tmp237 (Concat __tmp234 __tmp236))
(let __tmp238 (Concat __tmp222 __tmp237))
(let __tmp239 (Concat __tmp220 __tmp238))
(let __tmp240 (Call "vector_set" __tmp239))
(let __tmp241 (Get __tmp218 2))
(let __tmp242 (Single __tmp241))
(let __tmp243 (Get __tmp218 4))
(let __tmp244 (Single __tmp243))
(let __tmp245 (Const __tmp66 __tmp210 __tmp217))
(let __tmp246 (Single __tmp245))
(let __tmp247 (Const __tmp60 __tmp210 __tmp217))
(let __tmp248 (Single __tmp247))
(let __tmp249 (Get __tmp218 5))
(let __tmp250 (Single __tmp249))
(let __tmp251 (Get __tmp218 6))
(let __tmp252 (Single __tmp251))
(let __tmp253 (Get __tmp218 8))
(let __tmp254 (Single __tmp253))
(let __tmp255 (Concat __tmp254 __tmp220))
(let __tmp256 (Concat __tmp226 __tmp255))
(let __tmp257 (Concat __tmp252 __tmp256))
(let __tmp258 (Concat __tmp250 __tmp257))
(let __tmp259 (Concat __tmp248 __tmp258))
(let __tmp260 (Concat __tmp246 __tmp259))
(let __tmp261 (Concat __tmp244 __tmp260))
(let __tmp262 (Concat __tmp222 __tmp261))
(let __tmp263 (Concat __tmp242 __tmp262))
(let __tmp264 (Concat __tmp224 __tmp263))
(let __tmp265 (Concat __tmp240 __tmp264))
(let __tmp266 (Get __tmp265 6))
(let __tmp267 (Get __tmp265 10))
(let __tmp268 (Bop __tmp59 __tmp266 __tmp267))
(let __tmp269 (TCons __tmp13 __tmp205))
(let __tmp270 (TCons __tmp100 __tmp269))
(let __tmp271 (TCons __tmp100 __tmp270))
(let __tmp272 (TCons __tmp13 __tmp271))
(let __tmp273 (TCons __tmp13 __tmp272))
(let __tmp274 (TCons __tmp1 __tmp273))
(let __tmp275 (TupleT __tmp274))
(let __tmp276 (InIf true __tmp268 __tmp265))
(let __tmp277 (Arg __tmp275 __tmp276))
(let __tmp278 (InFunc " loop_ctx_11"))
(let __tmp279 (Arg __tmp275 __tmp278))
(let __tmp280 (Get __tmp279 7))
(let __tmp281 (Single __tmp280))
(let __tmp282 (Get __tmp279 3))
(let __tmp283 (Single __tmp282))
(let __tmp284 (Get __tmp279 6))
(let __tmp285 (Single __tmp284))
(let __tmp286 (Get __tmp279 8))
(let __tmp287 (Single __tmp286))
(let __tmp288 (FMul ))
(let __tmp289 (Get __tmp279 5))
(let __tmp290 (Get __tmp279 2))
(let __tmp291 (Bop __tmp141 __tmp289 __tmp290))
(let __tmp292 (Get __tmp279 1))
(let __tmp293 (Bop __tmp288 __tmp291 __tmp292))
(let __tmp294 (Single __tmp293))
(let __tmp295 (Get __tmp279 9))
(let __tmp296 (Single __tmp295))
(let __tmp297 (Get __tmp279 0))
(let __tmp298 (Single __tmp297))
(let __tmp299 (Concat __tmp296 __tmp298))
(let __tmp300 (Concat __tmp294 __tmp299))
(let __tmp301 (Call "fmod" __tmp300))
(let __tmp302 (Get __tmp301 0))
(let __tmp303 (Bop __tmp122 __tmp302 __tmp295))
(let __tmp304 (Single __tmp303))
(let __tmp305 (Get __tmp301 1))
(let __tmp306 (Single __tmp305))
(let __tmp307 (Concat __tmp304 __tmp306))
(let __tmp308 (Concat __tmp287 __tmp307))
(let __tmp309 (Concat __tmp285 __tmp308))
(let __tmp310 (Concat __tmp283 __tmp309))
(let __tmp311 (Concat __tmp281 __tmp310))
(let __tmp312 (Call "matrix_set" __tmp311))
(let __tmp313 (Single __tmp292))
(let __tmp314 (Single __tmp290))
(let __tmp315 (Get __tmp279 4))
(let __tmp316 (Single __tmp315))
(let __tmp317 (Single __tmp291))
(let __tmp318 (Bop __tmp146 __tmp315 __tmp284))
(let __tmp319 (Single __tmp318))
(let __tmp320 (Get __tmp279 10))
(let __tmp321 (Single __tmp320))
(let __tmp322 (Get __tmp279 11))
(let __tmp323 (Single __tmp322))
(let __tmp324 (Concat __tmp321 __tmp323))
(let __tmp325 (Concat __tmp296 __tmp324))
(let __tmp326 (Concat __tmp287 __tmp325))
(let __tmp327 (Concat __tmp281 __tmp326))
(let __tmp328 (Concat __tmp319 __tmp327))
(let __tmp329 (Concat __tmp317 __tmp328))
(let __tmp330 (Concat __tmp316 __tmp329))
(let __tmp331 (Concat __tmp283 __tmp330))
(let __tmp332 (Concat __tmp314 __tmp331))
(let __tmp333 (Concat __tmp313 __tmp332))
(let __tmp334 (Concat __tmp312 __tmp333))
(let __tmp335 (Get __tmp334 6))
(let __tmp336 (Get __tmp334 10))
(let __tmp337 (Bop __tmp59 __tmp335 __tmp336))
(let __tmp338 (Single __tmp337))
(let __tmp339 (Concat __tmp338 __tmp334))
(let __tmp340 (DoWhile __tmp277 __tmp339))
(let __tmp341 (InIf false __tmp268 __tmp265))
(let __tmp342 (Arg __tmp275 __tmp341))
(let __tmp343 (If __tmp268 __tmp265 __tmp340 __tmp342))
(let __tmp344 (Get __tmp343 0))
(let __tmp345 (Single __tmp344))
(let __tmp346 (Get __tmp343 1))
(let __tmp347 (Get __tmp343 2))
(let __tmp348 (Bop __tmp141 __tmp346 __tmp347))
(let __tmp349 (Single __tmp348))
(let __tmp350 (Single __tmp347))
(let __tmp351 (Bop __tmp146 __tmp243 __tmp221))
(let __tmp352 (Single __tmp351))
(let __tmp353 (Get __tmp343 7))
(let __tmp354 (Single __tmp353))
(let __tmp355 (Get __tmp343 9))
(let __tmp356 (Single __tmp355))
(let __tmp357 (Get __tmp343 11))
(let __tmp358 (Single __tmp357))
(let __tmp359 (Concat __tmp254 __tmp358))
(let __tmp360 (Concat __tmp356 __tmp359))
(let __tmp361 (Concat __tmp252 __tmp360))
(let __tmp362 (Concat __tmp354 __tmp361))
(let __tmp363 (Concat __tmp244 __tmp362))
(let __tmp364 (Concat __tmp352 __tmp363))
(let __tmp365 (Concat __tmp350 __tmp364))
(let __tmp366 (Concat __tmp349 __tmp365))
(let __tmp367 (Concat __tmp345 __tmp366))
(let __tmp368 (InIf false __tmp215 __tmp212))
(let __tmp369 (Arg __tmp210 __tmp368))
(let __tmp370 (If __tmp215 __tmp212 __tmp367 __tmp369))
(let __tmp371 (Concat __tmp216 __tmp370))
(let __tmp372 (DoWhile __tmp199 __tmp371))
(let __tmp373 (Get __tmp372 0))
(let __tmp374 (Single __tmp373))
(let __tmp375 (Concat __tmp7 __tmp58))
(let __tmp376 (Call "vector_new" __tmp375))
(let __tmp377 (Get __tmp375 0))
(let __tmp378 (Get __tmp375 1))
(let __tmp379 (Alloc 0 __tmp377 __tmp378 __tmp14))
(let __tmp380 (Get __tmp376 1))
(let __tmp381 (Single __tmp380))
(let __tmp382 (Concat __tmp18 __tmp381))
(let __tmp383 (Call "vector_new" __tmp382))
(let __tmp384 (Get __tmp382 0))
(let __tmp385 (Get __tmp382 1))
(let __tmp386 (Alloc 0 __tmp384 __tmp385 __tmp14))
(let __tmp387 (TCons __tmp100 __tmp101))
(let __tmp388 (TCons __tmp100 __tmp387))
(let __tmp389 (TCons __tmp100 __tmp388))
(let __tmp390 (TCons __tmp100 __tmp389))
(let __tmp391 (TCons __tmp14 __tmp390))
(let __tmp392 (TCons __tmp14 __tmp391))
(let __tmp393 (TCons __tmp14 __tmp392))
(let __tmp394 (TCons __tmp14 __tmp393))
(let __tmp395 (TCons __tmp14 __tmp394))
(let __tmp396 (TCons __tmp1 __tmp395))
(let __tmp397 (TupleT __tmp396))
(let __tmp398 (InFunc " loop_ctx_1"))
(let __tmp399 (Arg __tmp397 __tmp398))
(let __tmp400 (Get __tmp399 4))
(let __tmp401 (Single __tmp400))
(let __tmp402 (Get __tmp399 8))
(let __tmp403 (Single __tmp402))
(let __tmp404 (Get __tmp399 10))
(let __tmp405 (Single __tmp404))
(let __tmp406 (Get __tmp399 0))
(let __tmp407 (Single __tmp406))
(let __tmp408 (Concat __tmp405 __tmp407))
(let __tmp409 (Concat __tmp403 __tmp408))
(let __tmp410 (Concat __tmp401 __tmp409))
(let __tmp411 (Call "vector_set" __tmp410))
(let __tmp412 (Write ))
(let __tmp413 (PtrAdd ))
(let __tmp414 (Get __tmp410 0))
(let __tmp415 (Get __tmp410 1))
(let __tmp416 (Bop __tmp413 __tmp414 __tmp415))
(let __tmp417 (Get __tmp410 2))
(let __tmp418 (Get __tmp410 3))
(let __tmp419 (Top __tmp412 __tmp416 __tmp417 __tmp418))
(let __tmp420 (Single __tmp419))
(let __tmp421 (InFunc " loop_ctx_0"))
(let __tmp422 (Arg __tmp397 __tmp421))
(let __tmp423 (Get __tmp422 8))
(let __tmp424 (Get __tmp422 6))
(let __tmp425 (Bop __tmp59 __tmp423 __tmp424))
(let __tmp426 (InIf true __tmp425 __tmp422))
(let __tmp427 (Arg __tmp397 __tmp426))
(let __tmp428 (Get __tmp427 3))
(let __tmp429 (Single __tmp428))
(let __tmp430 (Get __tmp427 8))
(let __tmp431 (Single __tmp430))
(let __tmp432 (Get __tmp427 10))
(let __tmp433 (Single __tmp432))
(let __tmp434 (Get __tmp427 0))
(let __tmp435 (Single __tmp434))
(let __tmp436 (Concat __tmp433 __tmp435))
(let __tmp437 (Concat __tmp431 __tmp436))
(let __tmp438 (Concat __tmp429 __tmp437))
(let __tmp439 (Call "vector_set" __tmp438))
(let __tmp440 (Get __tmp438 0))
(let __tmp441 (Get __tmp438 1))
(let __tmp442 (Bop __tmp413 __tmp440 __tmp441))
(let __tmp443 (Get __tmp438 2))
(let __tmp444 (Get __tmp438 3))
(let __tmp445 (Top __tmp412 __tmp442 __tmp443 __tmp444))
(let __tmp446 (Single __tmp445))
(let __tmp447 (TCons __tmp100 __tmp390))
(let __tmp448 (TCons __tmp14 __tmp447))
(let __tmp449 (TCons __tmp14 __tmp448))
(let __tmp450 (TCons __tmp14 __tmp449))
(let __tmp451 (TCons __tmp14 __tmp450))
(let __tmp452 (TCons __tmp14 __tmp451))
(let __tmp453 (TCons __tmp1 __tmp452))
(let __tmp454 (TupleT __tmp453))
(let __tmp455 (InFunc " loop_ctx_2"))
(let __tmp456 (Arg __tmp454 __tmp455))
(let __tmp457 (Get __tmp456 1))
(let __tmp458 (Single __tmp457))
(let __tmp459 (Get __tmp456 8))
(let __tmp460 (Single __tmp459))
(let __tmp461 (Get __tmp456 0))
(let __tmp462 (Single __tmp461))
(let __tmp463 (Concat __tmp460 __tmp462))
(let __tmp464 (Concat __tmp458 __tmp463))
(let __tmp465 (Call "vector_get" __tmp464))
(let __tmp466 (Load ))
(let __tmp467 (Get __tmp464 0))
(let __tmp468 (Get __tmp464 1))
(let __tmp469 (Bop __tmp413 __tmp467 __tmp468))
(let __tmp470 (Get __tmp464 2))
(let __tmp471 (Bop __tmp466 __tmp469 __tmp470))
(let __tmp472 (Get __tmp456 5))
(let __tmp473 (Single __tmp472))
(let __tmp474 (Get __tmp456 10))
(let __tmp475 (Single __tmp474))
(let __tmp476 (Get __tmp456 7))
(let __tmp477 (Single __tmp476))
(let __tmp478 (Get __tmp465 1))
(let __tmp479 (Single __tmp478))
(let __tmp480 (Concat __tmp477 __tmp479))
(let __tmp481 (Concat __tmp475 __tmp480))
(let __tmp482 (Concat __tmp460 __tmp481))
(let __tmp483 (Concat __tmp473 __tmp482))
(let __tmp484 (Call "matrix_get" __tmp483))
(let __tmp485 (Call "matrix_loc" __tmp483))
(let __tmp486 (Get __tmp485 0))
(let __tmp487 (Get __tmp485 1))
(let __tmp488 (Bop __tmp466 __tmp486 __tmp487))
(let __tmp489 (Get __tmp456 4))
(let __tmp490 (Single __tmp489))
(let __tmp491 (Get __tmp484 1))
(let __tmp492 (Single __tmp491))
(let __tmp493 (Concat __tmp475 __tmp492))
(let __tmp494 (Concat __tmp490 __tmp493))
(let __tmp495 (Call "vector_get" __tmp494))
(let __tmp496 (Get __tmp494 0))
(let __tmp497 (Get __tmp494 1))
(let __tmp498 (Bop __tmp413 __tmp496 __tmp497))
(let __tmp499 (Get __tmp494 2))
(let __tmp500 (Bop __tmp466 __tmp498 __tmp499))
(let __tmp501 (Get __tmp495 0))
(let __tmp502 (Get __tmp465 0))
(let __tmp503 (Get __tmp484 0))
(let __tmp504 (Bop __tmp288 __tmp502 __tmp503))
(let __tmp505 (Bop __tmp141 __tmp501 __tmp504))
(let __tmp506 (Single __tmp505))
(let __tmp507 (Get __tmp495 1))
(let __tmp508 (Single __tmp507))
(let __tmp509 (Concat __tmp506 __tmp508))
(let __tmp510 (Concat __tmp475 __tmp509))
(let __tmp511 (Concat __tmp490 __tmp510))
(let __tmp512 (Call "vector_set" __tmp511))
(let __tmp513 (Get __tmp511 0))
(let __tmp514 (Get __tmp511 1))
(let __tmp515 (Bop __tmp413 __tmp513 __tmp514))
(let __tmp516 (Get __tmp511 2))
(let __tmp517 (Get __tmp511 3))
(let __tmp518 (Top __tmp412 __tmp515 __tmp516 __tmp517))
(let __tmp519 (Single __tmp518))
(let __tmp520 (Concat __tmp477 __tmp512))
(let __tmp521 (Concat __tmp475 __tmp520))
(let __tmp522 (Concat __tmp460 __tmp521))
(let __tmp523 (Concat __tmp473 __tmp522))
(let __tmp524 (Call "matrix_get" __tmp523))
(let __tmp525 (Call "matrix_loc" __tmp523))
(let __tmp526 (Get __tmp525 0))
(let __tmp527 (Get __tmp525 1))
(let __tmp528 (Bop __tmp466 __tmp526 __tmp527))
(let __tmp529 (Get __tmp456 2))
(let __tmp530 (Single __tmp529))
(let __tmp531 (Get __tmp524 1))
(let __tmp532 (Single __tmp531))
(let __tmp533 (Concat __tmp475 __tmp532))
(let __tmp534 (Concat __tmp530 __tmp533))
(let __tmp535 (Call "vector_get" __tmp534))
(let __tmp536 (Get __tmp534 0))
(let __tmp537 (Get __tmp534 1))
(let __tmp538 (Bop __tmp413 __tmp536 __tmp537))
(let __tmp539 (Get __tmp534 2))
(let __tmp540 (Bop __tmp466 __tmp538 __tmp539))
(let __tmp541 (Get __tmp456 3))
(let __tmp542 (Single __tmp541))
(let __tmp543 (Get __tmp535 1))
(let __tmp544 (Single __tmp543))
(let __tmp545 (Concat __tmp460 __tmp544))
(let __tmp546 (Concat __tmp542 __tmp545))
(let __tmp547 (Call "vector_get" __tmp546))
(let __tmp548 (Get __tmp546 0))
(let __tmp549 (Get __tmp546 1))
(let __tmp550 (Bop __tmp413 __tmp548 __tmp549))
(let __tmp551 (Get __tmp546 2))
(let __tmp552 (Bop __tmp466 __tmp550 __tmp551))
(let __tmp553 (Get __tmp547 0))
(let __tmp554 (Get __tmp524 0))
(let __tmp555 (Get __tmp535 0))
(let __tmp556 (Bop __tmp288 __tmp554 __tmp555))
(let __tmp557 (Bop __tmp141 __tmp553 __tmp556))
(let __tmp558 (Single __tmp557))
(let __tmp559 (Get __tmp547 1))
(let __tmp560 (Single __tmp559))
(let __tmp561 (Concat __tmp558 __tmp560))
(let __tmp562 (Concat __tmp460 __tmp561))
(let __tmp563 (Concat __tmp542 __tmp562))
(let __tmp564 (Call "vector_set" __tmp563))
(let __tmp565 (Get __tmp563 0))
(let __tmp566 (Get __tmp563 1))
(let __tmp567 (Bop __tmp413 __tmp565 __tmp566))
(let __tmp568 (Get __tmp563 2))
(let __tmp569 (Get __tmp563 3))
(let __tmp570 (Top __tmp412 __tmp567 __tmp568 __tmp569))
(let __tmp571 (Single __tmp570))
(let __tmp572 (Bool true))
(let __tmp573 (Const __tmp572 __tmp4 __tmp5))
(let __tmp574 (Get __tmp383 1))
(let __tmp575 (Single __tmp574))
(let __tmp576 (Get __tmp383 0))
(let __tmp577 (Single __tmp576))
(let __tmp578 (Get __tmp376 0))
(let __tmp579 (Single __tmp578))
(let __tmp580 (Concat __tmp75 __tmp68))
(let __tmp581 (Concat __tmp72 __tmp580))
(let __tmp582 (Concat __tmp7 __tmp581))
(let __tmp583 (Concat __tmp18 __tmp582))
(let __tmp584 (Concat __tmp42 __tmp583))
(let __tmp585 (Concat __tmp579 __tmp584))
(let __tmp586 (Concat __tmp577 __tmp585))
(let __tmp587 (Concat __tmp38 __tmp586))
(let __tmp588 (Concat __tmp40 __tmp587))
(let __tmp589 (Concat __tmp575 __tmp588))
(let __tmp590 (InIf true __tmp573 __tmp589))
(let __tmp591 (Arg __tmp397 __tmp590))
(let __tmp592 (Get __tmp399 1))
(let __tmp593 (Single __tmp592))
(let __tmp594 (Get __tmp399 2))
(let __tmp595 (Single __tmp594))
(let __tmp596 (Get __tmp399 3))
(let __tmp597 (Single __tmp596))
(let __tmp598 (Get __tmp399 5))
(let __tmp599 (Single __tmp598))
(let __tmp600 (Get __tmp399 6))
(let __tmp601 (Single __tmp600))
(let __tmp602 (Get __tmp399 7))
(let __tmp603 (Single __tmp602))
(let __tmp604 (Get __tmp399 9))
(let __tmp605 (Bop __tmp146 __tmp604 __tmp402))
(let __tmp606 (Single __tmp605))
(let __tmp607 (Single __tmp604))
(let __tmp608 (Concat __tmp607 __tmp405))
(let __tmp609 (Concat __tmp606 __tmp608))
(let __tmp610 (Concat __tmp603 __tmp609))
(let __tmp611 (Concat __tmp601 __tmp610))
(let __tmp612 (Concat __tmp599 __tmp611))
(let __tmp613 (Concat __tmp401 __tmp612))
(let __tmp614 (Concat __tmp597 __tmp613))
(let __tmp615 (Concat __tmp595 __tmp614))
(let __tmp616 (Concat __tmp593 __tmp615))
(let __tmp617 (Concat __tmp411 __tmp616))
(let __tmp618 (Get __tmp617 8))
(let __tmp619 (Get __tmp617 7))
(let __tmp620 (Bop __tmp59 __tmp618 __tmp619))
(let __tmp621 (Single __tmp620))
(let __tmp622 (Concat __tmp621 __tmp617))
(let __tmp623 (DoWhile __tmp591 __tmp622))
(let __tmp624 (InIf false __tmp573 __tmp589))
(let __tmp625 (Arg __tmp397 __tmp624))
(let __tmp626 (If __tmp573 __tmp589 __tmp623 __tmp625))
(let __tmp627 (Get __tmp626 0))
(let __tmp628 (Single __tmp627))
(let __tmp629 (Get __tmp626 1))
(let __tmp630 (Single __tmp629))
(let __tmp631 (Get __tmp626 2))
(let __tmp632 (Single __tmp631))
(let __tmp633 (Get __tmp626 3))
(let __tmp634 (Single __tmp633))
(let __tmp635 (Get __tmp626 4))
(let __tmp636 (Single __tmp635))
(let __tmp637 (Get __tmp626 5))
(let __tmp638 (Single __tmp637))
(let __tmp639 (Get __tmp626 10))
(let __tmp640 (Single __tmp639))
(let __tmp641 (Concat __tmp75 __tmp640))
(let __tmp642 (Concat __tmp72 __tmp641))
(let __tmp643 (Concat __tmp7 __tmp642))
(let __tmp644 (Concat __tmp18 __tmp643))
(let __tmp645 (Concat __tmp638 __tmp644))
(let __tmp646 (Concat __tmp636 __tmp645))
(let __tmp647 (Concat __tmp634 __tmp646))
(let __tmp648 (Concat __tmp632 __tmp647))
(let __tmp649 (Concat __tmp630 __tmp648))
(let __tmp650 (Concat __tmp628 __tmp649))
(let __tmp651 (Single __tmp425))
(let __tmp652 (Get __tmp427 1))
(let __tmp653 (Single __tmp652))
(let __tmp654 (Get __tmp427 2))
(let __tmp655 (Single __tmp654))
(let __tmp656 (Get __tmp427 4))
(let __tmp657 (Single __tmp656))
(let __tmp658 (Get __tmp427 5))
(let __tmp659 (Single __tmp658))
(let __tmp660 (Get __tmp427 6))
(let __tmp661 (Single __tmp660))
(let __tmp662 (Get __tmp427 7))
(let __tmp663 (Single __tmp662))
(let __tmp664 (Get __tmp427 9))
(let __tmp665 (Single __tmp664))
(let __tmp666 (Const __tmp60 __tmp397 __tmp426))
(let __tmp667 (Single __tmp666))
(let __tmp668 (Concat __tmp667 __tmp433))
(let __tmp669 (Concat __tmp665 __tmp668))
(let __tmp670 (Concat __tmp431 __tmp669))
(let __tmp671 (Concat __tmp663 __tmp670))
(let __tmp672 (Concat __tmp661 __tmp671))
(let __tmp673 (Concat __tmp659 __tmp672))
(let __tmp674 (Concat __tmp657 __tmp673))
(let __tmp675 (Concat __tmp429 __tmp674))
(let __tmp676 (Concat __tmp655 __tmp675))
(let __tmp677 (Concat __tmp653 __tmp676))
(let __tmp678 (Concat __tmp439 __tmp677))
(let __tmp679 (Get __tmp678 10))
(let __tmp680 (Get __tmp678 7))
(let __tmp681 (Bop __tmp59 __tmp679 __tmp680))
(let __tmp682 (InIf true __tmp681 __tmp678))
(let __tmp683 (Arg __tmp454 __tmp682))
(let __tmp684 (Get __tmp456 6))
(let __tmp685 (Single __tmp684))
(let __tmp686 (Get __tmp456 9))
(let __tmp687 (Single __tmp686))
(let __tmp688 (Concat __tmp460 __tmp687))
(let __tmp689 (Concat __tmp477 __tmp688))
(let __tmp690 (Concat __tmp685 __tmp689))
(let __tmp691 (Concat __tmp473 __tmp690))
(let __tmp692 (Concat __tmp490 __tmp691))
(let __tmp693 (Concat __tmp542 __tmp692))
(let __tmp694 (Concat __tmp530 __tmp693))
(let __tmp695 (Concat __tmp458 __tmp694))
(let __tmp696 (Concat __tmp564 __tmp695))
(let __tmp697 (Bop __tmp146 __tmp686 __tmp474))
(let __tmp698 (Single __tmp697))
(let __tmp699 (Get __tmp456 11))
(let __tmp700 (Single __tmp699))
(let __tmp701 (Concat __tmp698 __tmp700))
(let __tmp702 (Concat __tmp696 __tmp701))
(let __tmp703 (Get __tmp702 10))
(let __tmp704 (Get __tmp702 7))
(let __tmp705 (Bop __tmp59 __tmp703 __tmp704))
(let __tmp706 (Single __tmp705))
(let __tmp707 (Concat __tmp706 __tmp702))
(let __tmp708 (DoWhile __tmp683 __tmp707))
(let __tmp709 (InIf false __tmp681 __tmp678))
(let __tmp710 (Arg __tmp454 __tmp709))
(let __tmp711 (If __tmp681 __tmp678 __tmp708 __tmp710))
(let __tmp712 (Get __tmp711 0))
(let __tmp713 (Single __tmp712))
(let __tmp714 (Get __tmp711 1))
(let __tmp715 (Single __tmp714))
(let __tmp716 (Get __tmp711 2))
(let __tmp717 (Single __tmp716))
(let __tmp718 (Get __tmp711 3))
(let __tmp719 (Single __tmp718))
(let __tmp720 (Get __tmp711 4))
(let __tmp721 (Single __tmp720))
(let __tmp722 (Get __tmp711 5))
(let __tmp723 (Single __tmp722))
(let __tmp724 (Concat __tmp661 __tmp663))
(let __tmp725 (Concat __tmp723 __tmp724))
(let __tmp726 (Concat __tmp721 __tmp725))
(let __tmp727 (Bop __tmp146 __tmp664 __tmp430))
(let __tmp728 (Single __tmp727))
(let __tmp729 (Get __tmp711 11))
(let __tmp730 (Single __tmp729))
(let __tmp731 (Concat __tmp665 __tmp730))
(let __tmp732 (Concat __tmp728 __tmp731))
(let __tmp733 (Concat __tmp726 __tmp732))
(let __tmp734 (Concat __tmp719 __tmp733))
(let __tmp735 (Concat __tmp717 __tmp734))
(let __tmp736 (Concat __tmp715 __tmp735))
(let __tmp737 (Concat __tmp713 __tmp736))
(let __tmp738 (InIf false __tmp425 __tmp422))
(let __tmp739 (Arg __tmp397 __tmp738))
(let __tmp740 (If __tmp425 __tmp422 __tmp737 __tmp739))
(let __tmp741 (Concat __tmp651 __tmp740))
(let __tmp742 (DoWhile __tmp650 __tmp741))
(let __tmp743 (Get __tmp742 4))
(let __tmp744 (Single __tmp743))
(let __tmp745 (Get __tmp742 0))
(let __tmp746 (Single __tmp745))
(let __tmp747 (Concat __tmp7 __tmp746))
(let __tmp748 (Concat __tmp744 __tmp747))
(let __tmp749 (Call "vector_sum" __tmp748))
(let __tmp750 (Get __tmp748 1))
(let __tmp751 (Bop __tmp59 __tmp61 __tmp750))
(let __tmp752 (Get __tmp748 2))
(let __tmp753 (Single __tmp752))
(let __tmp754 (Get __tmp748 0))
(let __tmp755 (Single __tmp754))
(let __tmp756 (Single __tmp750))
(let __tmp757 (Concat __tmp755 __tmp756))
(let __tmp758 (Concat __tmp75 __tmp757))
(let __tmp759 (Concat __tmp72 __tmp758))
(let __tmp760 (Concat __tmp68 __tmp759))
(let __tmp761 (Concat __tmp753 __tmp760))
(let __tmp762 (TCons __tmp100 __tmp2))
(let __tmp763 (TCons __tmp14 __tmp762))
(let __tmp764 (TCons __tmp100 __tmp763))
(let __tmp765 (TCons __tmp100 __tmp764))
(let __tmp766 (TCons __tmp13 __tmp765))
(let __tmp767 (TCons __tmp1 __tmp766))
(let __tmp768 (TupleT __tmp767))
(let __tmp769 (InIf true __tmp751 __tmp761))
(let __tmp770 (Arg __tmp768 __tmp769))
(let __tmp771 (InFunc " loop_ctx_12"))
(let __tmp772 (Arg __tmp768 __tmp771))
(let __tmp773 (Get __tmp772 2))
(let __tmp774 (Get __tmp772 3))
(let __tmp775 (Bop __tmp146 __tmp773 __tmp774))
(let __tmp776 (Get __tmp772 5))
(let __tmp777 (Bop __tmp59 __tmp775 __tmp776))
(let __tmp778 (Single __tmp777))
(let __tmp779 (Get __tmp772 4))
(let __tmp780 (Single __tmp779))
(let __tmp781 (Single __tmp773))
(let __tmp782 (Get __tmp772 0))
(let __tmp783 (Single __tmp782))
(let __tmp784 (Concat __tmp781 __tmp783))
(let __tmp785 (Concat __tmp780 __tmp784))
(let __tmp786 (Call "vector_get" __tmp785))
(let __tmp787 (Get __tmp786 1))
(let __tmp788 (Single __tmp787))
(let __tmp789 (Get __tmp772 1))
(let __tmp790 (Get __tmp786 0))
(let __tmp791 (Bop __tmp141 __tmp789 __tmp790))
(let __tmp792 (Single __tmp791))
(let __tmp793 (Concat __tmp788 __tmp792))
(let __tmp794 (Single __tmp775))
(let __tmp795 (Single __tmp774))
(let __tmp796 (Concat __tmp795 __tmp780))
(let __tmp797 (Single __tmp776))
(let __tmp798 (Concat __tmp796 __tmp797))
(let __tmp799 (Concat __tmp794 __tmp798))
(let __tmp800 (Concat __tmp793 __tmp799))
(let __tmp801 (Concat __tmp778 __tmp800))
(let __tmp802 (DoWhile __tmp770 __tmp801))
(let __tmp803 (InIf false __tmp751 __tmp761))
(let __tmp804 (Arg __tmp768 __tmp803))
(let __tmp805 (If __tmp751 __tmp761 __tmp802 __tmp804))
(let __tmp806 (Get __tmp805 1))
(let __tmp807 (Single __tmp806))
(let __tmp808 (Get __tmp805 0))
(let __tmp809 (Single __tmp808))
(let __tmp810 (Concat __tmp807 __tmp809))
(let __tmp811 (Get __tmp742 3))
(let __tmp812 (Single __tmp811))
(let __tmp813 (Get __tmp749 1))
(let __tmp814 (Single __tmp813))
(let __tmp815 (Concat __tmp18 __tmp814))
(let __tmp816 (Concat __tmp812 __tmp815))
(let __tmp817 (Call "vector_sum" __tmp816))
(let __tmp818 (Get __tmp816 1))
(let __tmp819 (Bop __tmp59 __tmp61 __tmp818))
(let __tmp820 (Get __tmp816 2))
(let __tmp821 (Single __tmp820))
(let __tmp822 (Get __tmp816 0))
(let __tmp823 (Single __tmp822))
(let __tmp824 (Single __tmp818))
(let __tmp825 (Concat __tmp823 __tmp824))
(let __tmp826 (Concat __tmp75 __tmp825))
(let __tmp827 (Concat __tmp72 __tmp826))
(let __tmp828 (Concat __tmp68 __tmp827))
(let __tmp829 (Concat __tmp821 __tmp828))
(let __tmp830 (InIf true __tmp819 __tmp829))
(let __tmp831 (Arg __tmp768 __tmp830))
(let __tmp832 (InFunc " loop_ctx_13"))
(let __tmp833 (Arg __tmp768 __tmp832))
(let __tmp834 (Get __tmp833 2))
(let __tmp835 (Get __tmp833 3))
(let __tmp836 (Bop __tmp146 __tmp834 __tmp835))
(let __tmp837 (Get __tmp833 5))
(let __tmp838 (Bop __tmp59 __tmp836 __tmp837))
(let __tmp839 (Single __tmp838))
(let __tmp840 (Get __tmp833 4))
(let __tmp841 (Single __tmp840))
(let __tmp842 (Single __tmp834))
(let __tmp843 (Get __tmp833 0))
(let __tmp844 (Single __tmp843))
(let __tmp845 (Concat __tmp842 __tmp844))
(let __tmp846 (Concat __tmp841 __tmp845))
(let __tmp847 (Call "vector_get" __tmp846))
(let __tmp848 (Get __tmp847 1))
(let __tmp849 (Single __tmp848))
(let __tmp850 (Get __tmp833 1))
(let __tmp851 (Get __tmp847 0))
(let __tmp852 (Bop __tmp141 __tmp850 __tmp851))
(let __tmp853 (Single __tmp852))
(let __tmp854 (Concat __tmp849 __tmp853))
(let __tmp855 (Single __tmp836))
(let __tmp856 (Single __tmp835))
(let __tmp857 (Concat __tmp856 __tmp841))
(let __tmp858 (Single __tmp837))
(let __tmp859 (Concat __tmp857 __tmp858))
(let __tmp860 (Concat __tmp855 __tmp859))
(let __tmp861 (Concat __tmp854 __tmp860))
(let __tmp862 (Concat __tmp839 __tmp861))
(let __tmp863 (DoWhile __tmp831 __tmp862))
(let __tmp864 (InIf false __tmp819 __tmp829))
(let __tmp865 (Arg __tmp768 __tmp864))
(let __tmp866 (If __tmp819 __tmp829 __tmp863 __tmp865))
(let __tmp867 (Get __tmp866 1))
(let __tmp868 (Single __tmp867))
(let __tmp869 (Get __tmp866 0))
(let __tmp870 (Single __tmp869))
(let __tmp871 (Concat __tmp868 __tmp870))
(let __tmp872 (Get __tmp130 2))
(let __tmp873 (Single __tmp872))
(let __tmp874 (Get __tmp130 0))
(let __tmp875 (Single __tmp874))
(let __tmp876 (Float 2.0))
(let __tmp877 (Const __tmp876 __tmp113 __tmp116))
(let __tmp878 (Single __tmp877))
(let __tmp879 (Const __tmp66 __tmp113 __tmp116))
(let __tmp880 (Single __tmp879))
(let __tmp881 (Get __tmp130 1))
(let __tmp882 (Single __tmp881))
(let __tmp883 (Concat __tmp880 __tmp882))
(let __tmp884 (Concat __tmp878 __tmp883))
(let __tmp885 (Concat __tmp875 __tmp884))
(let __tmp886 (Concat __tmp873 __tmp885))
(let __tmp887 (FGreaterEq ))
(let __tmp888 (TCons __tmp13 __tmp101))
(let __tmp889 (TCons __tmp13 __tmp888))
(let __tmp890 (TCons __tmp13 __tmp889))
(let __tmp891 (TCons __tmp1 __tmp890))
(let __tmp892 (TupleT __tmp891))
(let __tmp893 (InFunc " loop_ctx_14"))
(let __tmp894 (Arg __tmp892 __tmp893))
(let __tmp895 (Get __tmp894 1))
(let __tmp896 (Get __tmp894 4))
(let __tmp897 (Bop __tmp887 __tmp895 __tmp896))
(let __tmp898 (Single __tmp897))
(let __tmp899 (FSub ))
(let __tmp900 (InIf true __tmp897 __tmp894))
(let __tmp901 (Arg __tmp892 __tmp900))
(let __tmp902 (Get __tmp901 1))
(let __tmp903 (Get __tmp901 4))
(let __tmp904 (Bop __tmp899 __tmp902 __tmp903))
(let __tmp905 (Get __tmp901 3))
(let __tmp906 (Bop __tmp887 __tmp904 __tmp905))
(let __tmp907 (Get __tmp901 0))
(let __tmp908 (Single __tmp907))
(let __tmp909 (Single __tmp902))
(let __tmp910 (Single __tmp903))
(let __tmp911 (Get __tmp901 2))
(let __tmp912 (Single __tmp911))
(let __tmp913 (Single __tmp905))
(let __tmp914 (Concat __tmp913 __tmp910))
(let __tmp915 (Concat __tmp912 __tmp914))
(let __tmp916 (Concat __tmp910 __tmp915))
(let __tmp917 (Concat __tmp909 __tmp916))
(let __tmp918 (Concat __tmp908 __tmp917))
(let __tmp919 (TCons __tmp13 __tmp890))
(let __tmp920 (TCons __tmp1 __tmp919))
(let __tmp921 (TupleT __tmp920))
(let __tmp922 (InIf true __tmp906 __tmp918))
(let __tmp923 (Arg __tmp921 __tmp922))
(let __tmp924 (InFunc " loop_ctx_15"))
(let __tmp925 (Arg __tmp921 __tmp924))
(let __tmp926 (Get __tmp925 1))
(let __tmp927 (Get __tmp925 2))
(let __tmp928 (Get __tmp925 3))
(let __tmp929 (Bop __tmp288 __tmp927 __tmp928))
(let __tmp930 (Bop __tmp899 __tmp926 __tmp929))
(let __tmp931 (Get __tmp925 4))
(let __tmp932 (Bop __tmp887 __tmp930 __tmp931))
(let __tmp933 (Single __tmp932))
(let __tmp934 (Get __tmp925 0))
(let __tmp935 (Single __tmp934))
(let __tmp936 (Single __tmp926))
(let __tmp937 (Concat __tmp935 __tmp936))
(let __tmp938 (Single __tmp929))
(let __tmp939 (Single __tmp928))
(let __tmp940 (Concat __tmp938 __tmp939))
(let __tmp941 (Single __tmp931))
(let __tmp942 (Concat __tmp940 __tmp941))
(let __tmp943 (Get __tmp925 5))
(let __tmp944 (Single __tmp943))
(let __tmp945 (Concat __tmp942 __tmp944))
(let __tmp946 (Concat __tmp937 __tmp945))
(let __tmp947 (Concat __tmp933 __tmp946))
(let __tmp948 (DoWhile __tmp923 __tmp947))
(let __tmp949 (InIf false __tmp906 __tmp918))
(let __tmp950 (Arg __tmp921 __tmp949))
(let __tmp951 (If __tmp906 __tmp918 __tmp948 __tmp950))
(let __tmp952 (Get __tmp951 0))
(let __tmp953 (Single __tmp952))
(let __tmp954 (Get __tmp951 1))
(let __tmp955 (Get __tmp951 2))
(let __tmp956 (Get __tmp951 3))
(let __tmp957 (Bop __tmp122 __tmp955 __tmp956))
(let __tmp958 (Bop __tmp899 __tmp954 __tmp957))
(let __tmp959 (Single __tmp958))
(let __tmp960 (Single __tmp956))
(let __tmp961 (Get __tmp951 4))
(let __tmp962 (Single __tmp961))
(let __tmp963 (Concat __tmp960 __tmp962))
(let __tmp964 (Get __tmp951 5))
(let __tmp965 (Single __tmp964))
(let __tmp966 (Concat __tmp963 __tmp965))
(let __tmp967 (Concat __tmp959 __tmp966))
(let __tmp968 (Concat __tmp953 __tmp967))
(let __tmp969 (InIf false __tmp897 __tmp894))
(let __tmp970 (Arg __tmp892 __tmp969))
(let __tmp971 (If __tmp897 __tmp894 __tmp968 __tmp970))
(let __tmp972 (Concat __tmp898 __tmp971))
(let __tmp973 (DoWhile __tmp886 __tmp972))
(let __tmp974 (Get __tmp973 1))
(let __tmp975 (Single __tmp974))
(let __tmp976 (Get __tmp973 0))
(let __tmp977 (Single __tmp976))
(let __tmp978 (Concat __tmp975 __tmp977))
(let __tmp979 (Get __tmp139 0))
(let __tmp980 (Get __tmp139 1))
(let __tmp981 (Bop __tmp413 __tmp979 __tmp980))
(let __tmp982 (Get __tmp139 2))
(let __tmp983 (Get __tmp139 3))
(let __tmp984 (Top __tmp412 __tmp981 __tmp982 __tmp983))
(let __tmp985 (Single __tmp984))
(let __tmp986 (Get __tmp230 2))
(let __tmp987 (Single __tmp986))
(let __tmp988 (Get __tmp230 0))
(let __tmp989 (Single __tmp988))
(let __tmp990 (Const __tmp876 __tmp210 __tmp217))
(let __tmp991 (Single __tmp990))
(let __tmp992 (Get __tmp230 1))
(let __tmp993 (Single __tmp992))
(let __tmp994 (Concat __tmp246 __tmp993))
(let __tmp995 (Concat __tmp991 __tmp994))
(let __tmp996 (Concat __tmp989 __tmp995))
(let __tmp997 (Concat __tmp987 __tmp996))
(let __tmp998 (InFunc " loop_ctx_16"))
(let __tmp999 (Arg __tmp892 __tmp998))
(let __tmp1000 (Get __tmp999 1))
(let __tmp1001 (Get __tmp999 4))
(let __tmp1002 (Bop __tmp887 __tmp1000 __tmp1001))
(let __tmp1003 (Single __tmp1002))
(let __tmp1004 (InIf true __tmp1002 __tmp999))
(let __tmp1005 (Arg __tmp892 __tmp1004))
(let __tmp1006 (Get __tmp1005 1))
(let __tmp1007 (Get __tmp1005 4))
(let __tmp1008 (Bop __tmp899 __tmp1006 __tmp1007))
(let __tmp1009 (Get __tmp1005 3))
(let __tmp1010 (Bop __tmp887 __tmp1008 __tmp1009))
(let __tmp1011 (Get __tmp1005 0))
(let __tmp1012 (Single __tmp1011))
(let __tmp1013 (Single __tmp1006))
(let __tmp1014 (Single __tmp1007))
(let __tmp1015 (Get __tmp1005 2))
(let __tmp1016 (Single __tmp1015))
(let __tmp1017 (Single __tmp1009))
(let __tmp1018 (Concat __tmp1017 __tmp1014))
(let __tmp1019 (Concat __tmp1016 __tmp1018))
(let __tmp1020 (Concat __tmp1014 __tmp1019))
(let __tmp1021 (Concat __tmp1013 __tmp1020))
(let __tmp1022 (Concat __tmp1012 __tmp1021))
(let __tmp1023 (InIf true __tmp1010 __tmp1022))
(let __tmp1024 (Arg __tmp921 __tmp1023))
(let __tmp1025 (InFunc " loop_ctx_17"))
(let __tmp1026 (Arg __tmp921 __tmp1025))
(let __tmp1027 (Get __tmp1026 1))
(let __tmp1028 (Get __tmp1026 2))
(let __tmp1029 (Get __tmp1026 3))
(let __tmp1030 (Bop __tmp288 __tmp1028 __tmp1029))
(let __tmp1031 (Bop __tmp899 __tmp1027 __tmp1030))
(let __tmp1032 (Get __tmp1026 4))
(let __tmp1033 (Bop __tmp887 __tmp1031 __tmp1032))
(let __tmp1034 (Single __tmp1033))
(let __tmp1035 (Get __tmp1026 0))
(let __tmp1036 (Single __tmp1035))
(let __tmp1037 (Single __tmp1027))
(let __tmp1038 (Concat __tmp1036 __tmp1037))
(let __tmp1039 (Single __tmp1030))
(let __tmp1040 (Single __tmp1029))
(let __tmp1041 (Concat __tmp1039 __tmp1040))
(let __tmp1042 (Single __tmp1032))
(let __tmp1043 (Concat __tmp1041 __tmp1042))
(let __tmp1044 (Get __tmp1026 5))
(let __tmp1045 (Single __tmp1044))
(let __tmp1046 (Concat __tmp1043 __tmp1045))
(let __tmp1047 (Concat __tmp1038 __tmp1046))
(let __tmp1048 (Concat __tmp1034 __tmp1047))
(let __tmp1049 (DoWhile __tmp1024 __tmp1048))
(let __tmp1050 (InIf false __tmp1010 __tmp1022))
(let __tmp1051 (Arg __tmp921 __tmp1050))
(let __tmp1052 (If __tmp1010 __tmp1022 __tmp1049 __tmp1051))
(let __tmp1053 (Get __tmp1052 0))
(let __tmp1054 (Single __tmp1053))
(let __tmp1055 (Get __tmp1052 1))
(let __tmp1056 (Get __tmp1052 2))
(let __tmp1057 (Get __tmp1052 3))
(let __tmp1058 (Bop __tmp122 __tmp1056 __tmp1057))
(let __tmp1059 (Bop __tmp899 __tmp1055 __tmp1058))
(let __tmp1060 (Single __tmp1059))
(let __tmp1061 (Single __tmp1057))
(let __tmp1062 (Get __tmp1052 4))
(let __tmp1063 (Single __tmp1062))
(let __tmp1064 (Concat __tmp1061 __tmp1063))
(let __tmp1065 (Get __tmp1052 5))
(let __tmp1066 (Single __tmp1065))
(let __tmp1067 (Concat __tmp1064 __tmp1066))
(let __tmp1068 (Concat __tmp1060 __tmp1067))
(let __tmp1069 (Concat __tmp1054 __tmp1068))
(let __tmp1070 (InIf false __tmp1002 __tmp999))
(let __tmp1071 (Arg __tmp892 __tmp1070))
(let __tmp1072 (If __tmp1002 __tmp999 __tmp1069 __tmp1071))
(let __tmp1073 (Concat __tmp1003 __tmp1072))
(let __tmp1074 (DoWhile __tmp997 __tmp1073))
(let __tmp1075 (Get __tmp1074 1))
(let __tmp1076 (Single __tmp1075))
(let __tmp1077 (Get __tmp1074 0))
(let __tmp1078 (Single __tmp1077))
(let __tmp1079 (Concat __tmp1076 __tmp1078))
(let __tmp1080 (Get __tmp239 0))
(let __tmp1081 (Get __tmp239 1))
(let __tmp1082 (Bop __tmp413 __tmp1080 __tmp1081))
(let __tmp1083 (Get __tmp239 2))
(let __tmp1084 (Get __tmp239 3))
(let __tmp1085 (Top __tmp412 __tmp1082 __tmp1083 __tmp1084))
(let __tmp1086 (Single __tmp1085))
(let __tmp1087 (Get __tmp300 2))
(let __tmp1088 (Single __tmp1087))
(let __tmp1089 (Get __tmp300 0))
(let __tmp1090 (Single __tmp1089))
(let __tmp1091 (Const __tmp876 __tmp275 __tmp278))
(let __tmp1092 (Single __tmp1091))
(let __tmp1093 (Const __tmp66 __tmp275 __tmp278))
(let __tmp1094 (Single __tmp1093))
(let __tmp1095 (Get __tmp300 1))
(let __tmp1096 (Single __tmp1095))
(let __tmp1097 (Concat __tmp1094 __tmp1096))
(let __tmp1098 (Concat __tmp1092 __tmp1097))
(let __tmp1099 (Concat __tmp1090 __tmp1098))
(let __tmp1100 (Concat __tmp1088 __tmp1099))
(let __tmp1101 (InFunc " loop_ctx_18"))
(let __tmp1102 (Arg __tmp892 __tmp1101))
(let __tmp1103 (Get __tmp1102 1))
(let __tmp1104 (Get __tmp1102 4))
(let __tmp1105 (Bop __tmp887 __tmp1103 __tmp1104))
(let __tmp1106 (Single __tmp1105))
(let __tmp1107 (InIf true __tmp1105 __tmp1102))
(let __tmp1108 (Arg __tmp892 __tmp1107))
(let __tmp1109 (Get __tmp1108 1))
(let __tmp1110 (Get __tmp1108 4))
(let __tmp1111 (Bop __tmp899 __tmp1109 __tmp1110))
(let __tmp1112 (Get __tmp1108 3))
(let __tmp1113 (Bop __tmp887 __tmp1111 __tmp1112))
(let __tmp1114 (Get __tmp1108 0))
(let __tmp1115 (Single __tmp1114))
(let __tmp1116 (Single __tmp1109))
(let __tmp1117 (Single __tmp1110))
(let __tmp1118 (Get __tmp1108 2))
(let __tmp1119 (Single __tmp1118))
(let __tmp1120 (Single __tmp1112))
(let __tmp1121 (Concat __tmp1120 __tmp1117))
(let __tmp1122 (Concat __tmp1119 __tmp1121))
(let __tmp1123 (Concat __tmp1117 __tmp1122))
(let __tmp1124 (Concat __tmp1116 __tmp1123))
(let __tmp1125 (Concat __tmp1115 __tmp1124))
(let __tmp1126 (InIf true __tmp1113 __tmp1125))
(let __tmp1127 (Arg __tmp921 __tmp1126))
(let __tmp1128 (InFunc " loop_ctx_19"))
(let __tmp1129 (Arg __tmp921 __tmp1128))
(let __tmp1130 (Get __tmp1129 1))
(let __tmp1131 (Get __tmp1129 2))
(let __tmp1132 (Get __tmp1129 3))
(let __tmp1133 (Bop __tmp288 __tmp1131 __tmp1132))
(let __tmp1134 (Bop __tmp899 __tmp1130 __tmp1133))
(let __tmp1135 (Get __tmp1129 4))
(let __tmp1136 (Bop __tmp887 __tmp1134 __tmp1135))
(let __tmp1137 (Single __tmp1136))
(let __tmp1138 (Get __tmp1129 0))
(let __tmp1139 (Single __tmp1138))
(let __tmp1140 (Single __tmp1130))
(let __tmp1141 (Concat __tmp1139 __tmp1140))
(let __tmp1142 (Single __tmp1133))
(let __tmp1143 (Single __tmp1132))
(let __tmp1144 (Concat __tmp1142 __tmp1143))
(let __tmp1145 (Single __tmp1135))
(let __tmp1146 (Concat __tmp1144 __tmp1145))
(let __tmp1147 (Get __tmp1129 5))
(let __tmp1148 (Single __tmp1147))
(let __tmp1149 (Concat __tmp1146 __tmp1148))
(let __tmp1150 (Concat __tmp1141 __tmp1149))
(let __tmp1151 (Concat __tmp1137 __tmp1150))
(let __tmp1152 (DoWhile __tmp1127 __tmp1151))
(let __tmp1153 (InIf false __tmp1113 __tmp1125))
(let __tmp1154 (Arg __tmp921 __tmp1153))
(let __tmp1155 (If __tmp1113 __tmp1125 __tmp1152 __tmp1154))
(let __tmp1156 (Get __tmp1155 0))
(let __tmp1157 (Single __tmp1156))
(let __tmp1158 (Get __tmp1155 1))
(let __tmp1159 (Get __tmp1155 2))
(let __tmp1160 (Get __tmp1155 3))
(let __tmp1161 (Bop __tmp122 __tmp1159 __tmp1160))
(let __tmp1162 (Bop __tmp899 __tmp1158 __tmp1161))
(let __tmp1163 (Single __tmp1162))
(let __tmp1164 (Single __tmp1160))
(let __tmp1165 (Get __tmp1155 4))
(let __tmp1166 (Single __tmp1165))
(let __tmp1167 (Concat __tmp1164 __tmp1166))
(let __tmp1168 (Get __tmp1155 5))
(let __tmp1169 (Single __tmp1168))
(let __tmp1170 (Concat __tmp1167 __tmp1169))
(let __tmp1171 (Concat __tmp1163 __tmp1170))
(let __tmp1172 (Concat __tmp1157 __tmp1171))
(let __tmp1173 (InIf false __tmp1105 __tmp1102))
(let __tmp1174 (Arg __tmp892 __tmp1173))
(let __tmp1175 (If __tmp1105 __tmp1102 __tmp1172 __tmp1174))
(let __tmp1176 (Concat __tmp1106 __tmp1175))
(let __tmp1177 (DoWhile __tmp1100 __tmp1176))
(let __tmp1178 (Get __tmp1177 1))
(let __tmp1179 (Single __tmp1178))
(let __tmp1180 (Get __tmp1177 0))
(let __tmp1181 (Single __tmp1180))
(let __tmp1182 (Concat __tmp1179 __tmp1181))
(let __tmp1183 (Get __tmp311 0))
(let __tmp1184 (Single __tmp1183))
(let __tmp1185 (Get __tmp311 1))
(let __tmp1186 (Single __tmp1185))
(let __tmp1187 (Get __tmp311 2))
(let __tmp1188 (Single __tmp1187))
(let __tmp1189 (Get __tmp311 3))
(let __tmp1190 (Single __tmp1189))
(let __tmp1191 (Get __tmp311 5))
(let __tmp1192 (Single __tmp1191))
(let __tmp1193 (Concat __tmp1190 __tmp1192))
(let __tmp1194 (Concat __tmp1188 __tmp1193))
(let __tmp1195 (Concat __tmp1186 __tmp1194))
(let __tmp1196 (Concat __tmp1184 __tmp1195))
(let __tmp1197 (Call "matrix_loc" __tmp1196))
(let __tmp1198 (Get __tmp1197 0))
(let __tmp1199 (Get __tmp311 4))
(let __tmp1200 (Get __tmp1197 1))
(let __tmp1201 (Top __tmp412 __tmp1198 __tmp1199 __tmp1200))
(let __tmp1202 (Single __tmp1201))
(let __tmp1203 (Get __tmp483 0))
(let __tmp1204 (Get __tmp483 1))
(let __tmp1205 (Get __tmp483 3))
(let __tmp1206 (Bop __tmp31 __tmp1204 __tmp1205))
(let __tmp1207 (Get __tmp483 2))
(let __tmp1208 (Bop __tmp146 __tmp1206 __tmp1207))
(let __tmp1209 (Bop __tmp413 __tmp1203 __tmp1208))
(let __tmp1210 (Single __tmp1209))
(let __tmp1211 (Get __tmp483 4))
(let __tmp1212 (Single __tmp1211))
(let __tmp1213 (Concat __tmp1210 __tmp1212))
(let __tmp1214 (Get __tmp523 0))
(let __tmp1215 (Get __tmp523 1))
(let __tmp1216 (Get __tmp523 3))
(let __tmp1217 (Bop __tmp31 __tmp1215 __tmp1216))
(let __tmp1218 (Get __tmp523 2))
(let __tmp1219 (Bop __tmp146 __tmp1217 __tmp1218))
(let __tmp1220 (Bop __tmp413 __tmp1214 __tmp1219))
(let __tmp1221 (Single __tmp1220))
(let __tmp1222 (Get __tmp523 4))
(let __tmp1223 (Single __tmp1222))
(let __tmp1224 (Concat __tmp1221 __tmp1223))
(let __tmp1225 (Get __tmp785 0))
(let __tmp1226 (Get __tmp785 1))
(let __tmp1227 (Bop __tmp413 __tmp1225 __tmp1226))
(let __tmp1228 (Get __tmp785 2))
(let __tmp1229 (Bop __tmp466 __tmp1227 __tmp1228))
(let __tmp1230 (Get __tmp846 0))
(let __tmp1231 (Get __tmp846 1))
(let __tmp1232 (Bop __tmp413 __tmp1230 __tmp1231))
(let __tmp1233 (Get __tmp846 2))
(let __tmp1234 (Bop __tmp466 __tmp1232 __tmp1233))
(let __tmp1235 (InFunc " loop_ctx_4"))
(let __tmp1236 (Arg __tmp113 __tmp1235))
(let __tmp1237 (Get __tmp1236 1))
(let __tmp1238 (Single __tmp1237))
(let __tmp1239 (Get __tmp1236 11))
(let __tmp1240 (Single __tmp1239))
(let __tmp1241 (Get __tmp1236 0))
(let __tmp1242 (Single __tmp1241))
(let __tmp1243 (Concat __tmp1240 __tmp1242))
(let __tmp1244 (Concat __tmp1238 __tmp1243))
(let __tmp1245 (Call "fmod" __tmp1244))
(let __tmp1246 (Get __tmp1244 2))
(let __tmp1247 (Single __tmp1246))
(let __tmp1248 (Get __tmp1244 0))
(let __tmp1249 (Single __tmp1248))
(let __tmp1250 (Const __tmp876 __tmp113 __tmp1235))
(let __tmp1251 (Single __tmp1250))
(let __tmp1252 (Const __tmp66 __tmp113 __tmp1235))
(let __tmp1253 (Single __tmp1252))
(let __tmp1254 (Get __tmp1244 1))
(let __tmp1255 (Single __tmp1254))
(let __tmp1256 (Concat __tmp1253 __tmp1255))
(let __tmp1257 (Concat __tmp1251 __tmp1256))
(let __tmp1258 (Concat __tmp1249 __tmp1257))
(let __tmp1259 (Concat __tmp1247 __tmp1258))
(let __tmp1260 (InFunc " loop_ctx_20"))
(let __tmp1261 (Arg __tmp892 __tmp1260))
(let __tmp1262 (Get __tmp1261 1))
(let __tmp1263 (Get __tmp1261 4))
(let __tmp1264 (Bop __tmp887 __tmp1262 __tmp1263))
(let __tmp1265 (Single __tmp1264))
(let __tmp1266 (InIf true __tmp1264 __tmp1261))
(let __tmp1267 (Arg __tmp892 __tmp1266))
(let __tmp1268 (Get __tmp1267 1))
(let __tmp1269 (Get __tmp1267 4))
(let __tmp1270 (Bop __tmp899 __tmp1268 __tmp1269))
(let __tmp1271 (Get __tmp1267 3))
(let __tmp1272 (Bop __tmp887 __tmp1270 __tmp1271))
(let __tmp1273 (Get __tmp1267 0))
(let __tmp1274 (Single __tmp1273))
(let __tmp1275 (Single __tmp1268))
(let __tmp1276 (Single __tmp1269))
(let __tmp1277 (Get __tmp1267 2))
(let __tmp1278 (Single __tmp1277))
(let __tmp1279 (Single __tmp1271))
(let __tmp1280 (Concat __tmp1279 __tmp1276))
(let __tmp1281 (Concat __tmp1278 __tmp1280))
(let __tmp1282 (Concat __tmp1276 __tmp1281))
(let __tmp1283 (Concat __tmp1275 __tmp1282))
(let __tmp1284 (Concat __tmp1274 __tmp1283))
(let __tmp1285 (InIf true __tmp1272 __tmp1284))
(let __tmp1286 (Arg __tmp921 __tmp1285))
(let __tmp1287 (InFunc " loop_ctx_21"))
(let __tmp1288 (Arg __tmp921 __tmp1287))
(let __tmp1289 (Get __tmp1288 1))
(let __tmp1290 (Get __tmp1288 2))
(let __tmp1291 (Get __tmp1288 3))
(let __tmp1292 (Bop __tmp288 __tmp1290 __tmp1291))
(let __tmp1293 (Bop __tmp899 __tmp1289 __tmp1292))
(let __tmp1294 (Get __tmp1288 4))
(let __tmp1295 (Bop __tmp887 __tmp1293 __tmp1294))
(let __tmp1296 (Single __tmp1295))
(let __tmp1297 (Get __tmp1288 0))
(let __tmp1298 (Single __tmp1297))
(let __tmp1299 (Single __tmp1289))
(let __tmp1300 (Concat __tmp1298 __tmp1299))
(let __tmp1301 (Single __tmp1292))
(let __tmp1302 (Single __tmp1291))
(let __tmp1303 (Concat __tmp1301 __tmp1302))
(let __tmp1304 (Single __tmp1294))
(let __tmp1305 (Concat __tmp1303 __tmp1304))
(let __tmp1306 (Get __tmp1288 5))
(let __tmp1307 (Single __tmp1306))
(let __tmp1308 (Concat __tmp1305 __tmp1307))
(let __tmp1309 (Concat __tmp1300 __tmp1308))
(let __tmp1310 (Concat __tmp1296 __tmp1309))
(let __tmp1311 (DoWhile __tmp1286 __tmp1310))
(let __tmp1312 (InIf false __tmp1272 __tmp1284))
(let __tmp1313 (Arg __tmp921 __tmp1312))
(let __tmp1314 (If __tmp1272 __tmp1284 __tmp1311 __tmp1313))
(let __tmp1315 (Get __tmp1314 0))
(let __tmp1316 (Single __tmp1315))
(let __tmp1317 (Get __tmp1314 1))
(let __tmp1318 (Get __tmp1314 2))
(let __tmp1319 (Get __tmp1314 3))
(let __tmp1320 (Bop __tmp122 __tmp1318 __tmp1319))
(let __tmp1321 (Bop __tmp899 __tmp1317 __tmp1320))
(let __tmp1322 (Single __tmp1321))
(let __tmp1323 (Single __tmp1319))
(let __tmp1324 (Get __tmp1314 4))
(let __tmp1325 (Single __tmp1324))
(let __tmp1326 (Concat __tmp1323 __tmp1325))
(let __tmp1327 (Get __tmp1314 5))
(let __tmp1328 (Single __tmp1327))
(let __tmp1329 (Concat __tmp1326 __tmp1328))
(let __tmp1330 (Concat __tmp1322 __tmp1329))
(let __tmp1331 (Concat __tmp1316 __tmp1330))
(let __tmp1332 (InIf false __tmp1264 __tmp1261))
(let __tmp1333 (Arg __tmp892 __tmp1332))
(let __tmp1334 (If __tmp1264 __tmp1261 __tmp1331 __tmp1333))
(let __tmp1335 (Concat __tmp1265 __tmp1334))
(let __tmp1336 (DoWhile __tmp1259 __tmp1335))
(let __tmp1337 (Get __tmp1336 1))
(let __tmp1338 (Single __tmp1337))
(let __tmp1339 (Get __tmp1336 0))
(let __tmp1340 (Single __tmp1339))
(let __tmp1341 (Concat __tmp1338 __tmp1340))
(let __tmp1342 (Get __tmp1236 10))
(let __tmp1343 (Single __tmp1342))
(let __tmp1344 (Get __tmp1236 3))
(let __tmp1345 (Single __tmp1344))
(let __tmp1346 (Get __tmp1245 0))
(let __tmp1347 (Bop __tmp122 __tmp1346 __tmp1239))
(let __tmp1348 (Single __tmp1347))
(let __tmp1349 (Get __tmp1245 1))
(let __tmp1350 (Single __tmp1349))
(let __tmp1351 (Concat __tmp1348 __tmp1350))
(let __tmp1352 (Concat __tmp1345 __tmp1351))
(let __tmp1353 (Concat __tmp1343 __tmp1352))
(let __tmp1354 (Call "vector_set" __tmp1353))
(let __tmp1355 (Get __tmp1353 0))
(let __tmp1356 (Get __tmp1353 1))
(let __tmp1357 (Bop __tmp413 __tmp1355 __tmp1356))
(let __tmp1358 (Get __tmp1353 2))
(let __tmp1359 (Get __tmp1353 3))
(let __tmp1360 (Top __tmp412 __tmp1357 __tmp1358 __tmp1359))
(let __tmp1361 (Single __tmp1360))
(let __tmp1362 (InFunc " loop_ctx_3"))
(let __tmp1363 (Arg __tmp210 __tmp1362))
(let __tmp1364 (Get __tmp1363 3))
(let __tmp1365 (Get __tmp1363 8))
(let __tmp1366 (Bop __tmp59 __tmp1364 __tmp1365))
(let __tmp1367 (InIf true __tmp1366 __tmp1363))
(let __tmp1368 (Arg __tmp210 __tmp1367))
(let __tmp1369 (Get __tmp1368 1))
(let __tmp1370 (Single __tmp1369))
(let __tmp1371 (Get __tmp1368 7))
(let __tmp1372 (Single __tmp1371))
(let __tmp1373 (Get __tmp1368 0))
(let __tmp1374 (Single __tmp1373))
(let __tmp1375 (Concat __tmp1372 __tmp1374))
(let __tmp1376 (Concat __tmp1370 __tmp1375))
(let __tmp1377 (Call "fmod" __tmp1376))
(let __tmp1378 (Get __tmp1376 2))
(let __tmp1379 (Single __tmp1378))
(let __tmp1380 (Get __tmp1376 0))
(let __tmp1381 (Single __tmp1380))
(let __tmp1382 (Const __tmp876 __tmp210 __tmp1367))
(let __tmp1383 (Single __tmp1382))
(let __tmp1384 (Const __tmp66 __tmp210 __tmp1367))
(let __tmp1385 (Single __tmp1384))
(let __tmp1386 (Get __tmp1376 1))
(let __tmp1387 (Single __tmp1386))
(let __tmp1388 (Concat __tmp1385 __tmp1387))
(let __tmp1389 (Concat __tmp1383 __tmp1388))
(let __tmp1390 (Concat __tmp1381 __tmp1389))
(let __tmp1391 (Concat __tmp1379 __tmp1390))
(let __tmp1392 (InFunc " loop_ctx_22"))
(let __tmp1393 (Arg __tmp892 __tmp1392))
(let __tmp1394 (Get __tmp1393 1))
(let __tmp1395 (Get __tmp1393 4))
(let __tmp1396 (Bop __tmp887 __tmp1394 __tmp1395))
(let __tmp1397 (Single __tmp1396))
(let __tmp1398 (InIf true __tmp1396 __tmp1393))
(let __tmp1399 (Arg __tmp892 __tmp1398))
(let __tmp1400 (Get __tmp1399 1))
(let __tmp1401 (Get __tmp1399 4))
(let __tmp1402 (Bop __tmp899 __tmp1400 __tmp1401))
(let __tmp1403 (Get __tmp1399 3))
(let __tmp1404 (Bop __tmp887 __tmp1402 __tmp1403))
(let __tmp1405 (Get __tmp1399 0))
(let __tmp1406 (Single __tmp1405))
(let __tmp1407 (Single __tmp1400))
(let __tmp1408 (Single __tmp1401))
(let __tmp1409 (Get __tmp1399 2))
(let __tmp1410 (Single __tmp1409))
(let __tmp1411 (Single __tmp1403))
(let __tmp1412 (Concat __tmp1411 __tmp1408))
(let __tmp1413 (Concat __tmp1410 __tmp1412))
(let __tmp1414 (Concat __tmp1408 __tmp1413))
(let __tmp1415 (Concat __tmp1407 __tmp1414))
(let __tmp1416 (Concat __tmp1406 __tmp1415))
(let __tmp1417 (InIf true __tmp1404 __tmp1416))
(let __tmp1418 (Arg __tmp921 __tmp1417))
(let __tmp1419 (InFunc " loop_ctx_23"))
(let __tmp1420 (Arg __tmp921 __tmp1419))
(let __tmp1421 (Get __tmp1420 1))
(let __tmp1422 (Get __tmp1420 2))
(let __tmp1423 (Get __tmp1420 3))
(let __tmp1424 (Bop __tmp288 __tmp1422 __tmp1423))
(let __tmp1425 (Bop __tmp899 __tmp1421 __tmp1424))
(let __tmp1426 (Get __tmp1420 4))
(let __tmp1427 (Bop __tmp887 __tmp1425 __tmp1426))
(let __tmp1428 (Single __tmp1427))
(let __tmp1429 (Get __tmp1420 0))
(let __tmp1430 (Single __tmp1429))
(let __tmp1431 (Single __tmp1421))
(let __tmp1432 (Concat __tmp1430 __tmp1431))
(let __tmp1433 (Single __tmp1424))
(let __tmp1434 (Single __tmp1423))
(let __tmp1435 (Concat __tmp1433 __tmp1434))
(let __tmp1436 (Single __tmp1426))
(let __tmp1437 (Concat __tmp1435 __tmp1436))
(let __tmp1438 (Get __tmp1420 5))
(let __tmp1439 (Single __tmp1438))
(let __tmp1440 (Concat __tmp1437 __tmp1439))
(let __tmp1441 (Concat __tmp1432 __tmp1440))
(let __tmp1442 (Concat __tmp1428 __tmp1441))
(let __tmp1443 (DoWhile __tmp1418 __tmp1442))
(let __tmp1444 (InIf false __tmp1404 __tmp1416))
(let __tmp1445 (Arg __tmp921 __tmp1444))
(let __tmp1446 (If __tmp1404 __tmp1416 __tmp1443 __tmp1445))
(let __tmp1447 (Get __tmp1446 0))
(let __tmp1448 (Single __tmp1447))
(let __tmp1449 (Get __tmp1446 1))
(let __tmp1450 (Get __tmp1446 2))
(let __tmp1451 (Get __tmp1446 3))
(let __tmp1452 (Bop __tmp122 __tmp1450 __tmp1451))
(let __tmp1453 (Bop __tmp899 __tmp1449 __tmp1452))
(let __tmp1454 (Single __tmp1453))
(let __tmp1455 (Single __tmp1451))
(let __tmp1456 (Get __tmp1446 4))
(let __tmp1457 (Single __tmp1456))
(let __tmp1458 (Concat __tmp1455 __tmp1457))
(let __tmp1459 (Get __tmp1446 5))
(let __tmp1460 (Single __tmp1459))
(let __tmp1461 (Concat __tmp1458 __tmp1460))
(let __tmp1462 (Concat __tmp1454 __tmp1461))
(let __tmp1463 (Concat __tmp1448 __tmp1462))
(let __tmp1464 (InIf false __tmp1396 __tmp1393))
(let __tmp1465 (Arg __tmp892 __tmp1464))
(let __tmp1466 (If __tmp1396 __tmp1393 __tmp1463 __tmp1465))
(let __tmp1467 (Concat __tmp1397 __tmp1466))
(let __tmp1468 (DoWhile __tmp1391 __tmp1467))
(let __tmp1469 (Get __tmp1468 1))
(let __tmp1470 (Single __tmp1469))
(let __tmp1471 (Get __tmp1468 0))
(let __tmp1472 (Single __tmp1471))
(let __tmp1473 (Concat __tmp1470 __tmp1472))
(let __tmp1474 (Get __tmp1368 9))
(let __tmp1475 (Single __tmp1474))
(let __tmp1476 (Get __tmp1368 3))
(let __tmp1477 (Single __tmp1476))
(let __tmp1478 (Get __tmp1377 0))
(let __tmp1479 (Bop __tmp122 __tmp1478 __tmp1371))
(let __tmp1480 (Single __tmp1479))
(let __tmp1481 (Get __tmp1377 1))
(let __tmp1482 (Single __tmp1481))
(let __tmp1483 (Concat __tmp1480 __tmp1482))
(let __tmp1484 (Concat __tmp1477 __tmp1483))
(let __tmp1485 (Concat __tmp1475 __tmp1484))
(let __tmp1486 (Call "vector_set" __tmp1485))
(let __tmp1487 (Get __tmp1485 0))
(let __tmp1488 (Get __tmp1485 1))
(let __tmp1489 (Bop __tmp413 __tmp1487 __tmp1488))
(let __tmp1490 (Get __tmp1485 2))
(let __tmp1491 (Get __tmp1485 3))
(let __tmp1492 (Top __tmp412 __tmp1489 __tmp1490 __tmp1491))
(let __tmp1493 (Single __tmp1492))
(let __tmp1494 (InFunc " loop_ctx_5"))
(let __tmp1495 (Arg __tmp275 __tmp1494))
(let __tmp1496 (Get __tmp1495 5))
(let __tmp1497 (Get __tmp1495 2))
(let __tmp1498 (Bop __tmp141 __tmp1496 __tmp1497))
(let __tmp1499 (Get __tmp1495 1))
(let __tmp1500 (Bop __tmp288 __tmp1498 __tmp1499))
(let __tmp1501 (Single __tmp1500))
(let __tmp1502 (Get __tmp1495 9))
(let __tmp1503 (Single __tmp1502))
(let __tmp1504 (Get __tmp1495 0))
(let __tmp1505 (Single __tmp1504))
(let __tmp1506 (Concat __tmp1503 __tmp1505))
(let __tmp1507 (Concat __tmp1501 __tmp1506))
(let __tmp1508 (Call "fmod" __tmp1507))
(let __tmp1509 (Get __tmp1507 2))
(let __tmp1510 (Single __tmp1509))
(let __tmp1511 (Get __tmp1507 0))
(let __tmp1512 (Single __tmp1511))
(let __tmp1513 (Const __tmp876 __tmp275 __tmp1494))
(let __tmp1514 (Single __tmp1513))
(let __tmp1515 (Const __tmp66 __tmp275 __tmp1494))
(let __tmp1516 (Single __tmp1515))
(let __tmp1517 (Get __tmp1507 1))
(let __tmp1518 (Single __tmp1517))
(let __tmp1519 (Concat __tmp1516 __tmp1518))
(let __tmp1520 (Concat __tmp1514 __tmp1519))
(let __tmp1521 (Concat __tmp1512 __tmp1520))
(let __tmp1522 (Concat __tmp1510 __tmp1521))
(let __tmp1523 (InFunc " loop_ctx_24"))
(let __tmp1524 (Arg __tmp892 __tmp1523))
(let __tmp1525 (Get __tmp1524 1))
(let __tmp1526 (Get __tmp1524 4))
(let __tmp1527 (Bop __tmp887 __tmp1525 __tmp1526))
(let __tmp1528 (Single __tmp1527))
(let __tmp1529 (InIf true __tmp1527 __tmp1524))
(let __tmp1530 (Arg __tmp892 __tmp1529))
(let __tmp1531 (Get __tmp1530 1))
(let __tmp1532 (Get __tmp1530 4))
(let __tmp1533 (Bop __tmp899 __tmp1531 __tmp1532))
(let __tmp1534 (Get __tmp1530 3))
(let __tmp1535 (Bop __tmp887 __tmp1533 __tmp1534))
(let __tmp1536 (Get __tmp1530 0))
(let __tmp1537 (Single __tmp1536))
(let __tmp1538 (Single __tmp1531))
(let __tmp1539 (Single __tmp1532))
(let __tmp1540 (Get __tmp1530 2))
(let __tmp1541 (Single __tmp1540))
(let __tmp1542 (Single __tmp1534))
(let __tmp1543 (Concat __tmp1542 __tmp1539))
(let __tmp1544 (Concat __tmp1541 __tmp1543))
(let __tmp1545 (Concat __tmp1539 __tmp1544))
(let __tmp1546 (Concat __tmp1538 __tmp1545))
(let __tmp1547 (Concat __tmp1537 __tmp1546))
(let __tmp1548 (InIf true __tmp1535 __tmp1547))
(let __tmp1549 (Arg __tmp921 __tmp1548))
(let __tmp1550 (InFunc " loop_ctx_25"))
(let __tmp1551 (Arg __tmp921 __tmp1550))
(let __tmp1552 (Get __tmp1551 1))
(let __tmp1553 (Get __tmp1551 2))
(let __tmp1554 (Get __tmp1551 3))
(let __tmp1555 (Bop __tmp288 __tmp1553 __tmp1554))
(let __tmp1556 (Bop __tmp899 __tmp1552 __tmp1555))
(let __tmp1557 (Get __tmp1551 4))
(let __tmp1558 (Bop __tmp887 __tmp1556 __tmp1557))
(let __tmp1559 (Single __tmp1558))
(let __tmp1560 (Get __tmp1551 0))
(let __tmp1561 (Single __tmp1560))
(let __tmp1562 (Single __tmp1552))
(let __tmp1563 (Concat __tmp1561 __tmp1562))
(let __tmp1564 (Single __tmp1555))
(let __tmp1565 (Single __tmp1554))
(let __tmp1566 (Concat __tmp1564 __tmp1565))
(let __tmp1567 (Single __tmp1557))
(let __tmp1568 (Concat __tmp1566 __tmp1567))
(let __tmp1569 (Get __tmp1551 5))
(let __tmp1570 (Single __tmp1569))
(let __tmp1571 (Concat __tmp1568 __tmp1570))
(let __tmp1572 (Concat __tmp1563 __tmp1571))
(let __tmp1573 (Concat __tmp1559 __tmp1572))
(let __tmp1574 (DoWhile __tmp1549 __tmp1573))
(let __tmp1575 (InIf false __tmp1535 __tmp1547))
(let __tmp1576 (Arg __tmp921 __tmp1575))
(let __tmp1577 (If __tmp1535 __tmp1547 __tmp1574 __tmp1576))
(let __tmp1578 (Get __tmp1577 0))
(let __tmp1579 (Single __tmp1578))
(let __tmp1580 (Get __tmp1577 1))
(let __tmp1581 (Get __tmp1577 2))
(let __tmp1582 (Get __tmp1577 3))
(let __tmp1583 (Bop __tmp122 __tmp1581 __tmp1582))
(let __tmp1584 (Bop __tmp899 __tmp1580 __tmp1583))
(let __tmp1585 (Single __tmp1584))
(let __tmp1586 (Single __tmp1582))
(let __tmp1587 (Get __tmp1577 4))
(let __tmp1588 (Single __tmp1587))
(let __tmp1589 (Concat __tmp1586 __tmp1588))
(let __tmp1590 (Get __tmp1577 5))
(let __tmp1591 (Single __tmp1590))
(let __tmp1592 (Concat __tmp1589 __tmp1591))
(let __tmp1593 (Concat __tmp1585 __tmp1592))
(let __tmp1594 (Concat __tmp1579 __tmp1593))
(let __tmp1595 (InIf false __tmp1527 __tmp1524))
(let __tmp1596 (Arg __tmp892 __tmp1595))
(let __tmp1597 (If __tmp1527 __tmp1524 __tmp1594 __tmp1596))
(let __tmp1598 (Concat __tmp1528 __tmp1597))
(let __tmp1599 (DoWhile __tmp1522 __tmp1598))
(let __tmp1600 (Get __tmp1599 1))
(let __tmp1601 (Single __tmp1600))
(let __tmp1602 (Get __tmp1599 0))
(let __tmp1603 (Single __tmp1602))
(let __tmp1604 (Concat __tmp1601 __tmp1603))
(let __tmp1605 (Get __tmp1495 7))
(let __tmp1606 (Single __tmp1605))
(let __tmp1607 (Get __tmp1495 3))
(let __tmp1608 (Single __tmp1607))
(let __tmp1609 (Get __tmp1495 6))
(let __tmp1610 (Single __tmp1609))
(let __tmp1611 (Get __tmp1495 8))
(let __tmp1612 (Single __tmp1611))
(let __tmp1613 (Get __tmp1508 0))
(let __tmp1614 (Bop __tmp122 __tmp1613 __tmp1502))
(let __tmp1615 (Single __tmp1614))
(let __tmp1616 (Get __tmp1508 1))
(let __tmp1617 (Single __tmp1616))
(let __tmp1618 (Concat __tmp1615 __tmp1617))
(let __tmp1619 (Concat __tmp1612 __tmp1618))
(let __tmp1620 (Concat __tmp1610 __tmp1619))
(let __tmp1621 (Concat __tmp1608 __tmp1620))
(let __tmp1622 (Concat __tmp1606 __tmp1621))
(let __tmp1623 (Call "matrix_set" __tmp1622))
(let __tmp1624 (Get __tmp1622 0))
(let __tmp1625 (Single __tmp1624))
(let __tmp1626 (Get __tmp1622 1))
(let __tmp1627 (Single __tmp1626))
(let __tmp1628 (Get __tmp1622 2))
(let __tmp1629 (Single __tmp1628))
(let __tmp1630 (Get __tmp1622 3))
(let __tmp1631 (Single __tmp1630))
(let __tmp1632 (Get __tmp1622 5))
(let __tmp1633 (Single __tmp1632))
(let __tmp1634 (Concat __tmp1631 __tmp1633))
(let __tmp1635 (Concat __tmp1629 __tmp1634))
(let __tmp1636 (Concat __tmp1627 __tmp1635))
(let __tmp1637 (Concat __tmp1625 __tmp1636))
(let __tmp1638 (Call "matrix_loc" __tmp1637))
(let __tmp1639 (Get __tmp1638 0))
(let __tmp1640 (Get __tmp1622 4))
(let __tmp1641 (Get __tmp1638 1))
(let __tmp1642 (Top __tmp412 __tmp1639 __tmp1640 __tmp1641))
(let __tmp1643 (Single __tmp1642))
(let __tmp1644 (Get __tmp1637 0))
(let __tmp1645 (Get __tmp1637 1))
(let __tmp1646 (Get __tmp1637 3))
(let __tmp1647 (Bop __tmp31 __tmp1645 __tmp1646))
(let __tmp1648 (Get __tmp1637 2))
(let __tmp1649 (Bop __tmp146 __tmp1647 __tmp1648))
(let __tmp1650 (Bop __tmp413 __tmp1644 __tmp1649))
(let __tmp1651 (Single __tmp1650))
(let __tmp1652 (Get __tmp1637 4))
(let __tmp1653 (Single __tmp1652))
(let __tmp1654 (Concat __tmp1651 __tmp1653))
(let __tmp1655 (TCons __tmp100 __tmp3))
(let __tmp1656 (TCons __tmp100 __tmp1655))
(let __tmp1657 (TCons __tmp100 __tmp1656))
(let __tmp1658 (TCons __tmp14 __tmp1657))
(let __tmp1659 (TupleT __tmp1658))
(let __tmp1660 (InFunc "matrix_get"))
(let __tmp1661 (Arg __tmp1659 __tmp1660))
(let __tmp1662 (Call "matrix_loc" __tmp1661))
(let __tmp1663 (Get __tmp1661 0))
(let __tmp1664 (Get __tmp1661 1))
(let __tmp1665 (Get __tmp1661 3))
(let __tmp1666 (Bop __tmp31 __tmp1664 __tmp1665))
(let __tmp1667 (Get __tmp1661 2))
(let __tmp1668 (Bop __tmp146 __tmp1666 __tmp1667))
(let __tmp1669 (Bop __tmp413 __tmp1663 __tmp1668))
(let __tmp1670 (Single __tmp1669))
(let __tmp1671 (Get __tmp1661 4))
(let __tmp1672 (Single __tmp1671))
(let __tmp1673 (Concat __tmp1670 __tmp1672))
(let __tmp1674 (TCons __tmp13 __tmp3))
(let __tmp1675 (TCons __tmp100 __tmp1674))
(let __tmp1676 (TCons __tmp100 __tmp1675))
(let __tmp1677 (TCons __tmp100 __tmp1676))
(let __tmp1678 (TCons __tmp14 __tmp1677))
(let __tmp1679 (TupleT __tmp1678))
(let __tmp1680 (InFunc "matrix_set"))
(let __tmp1681 (Arg __tmp1679 __tmp1680))
(let __tmp1682 (Get __tmp1681 0))
(let __tmp1683 (Single __tmp1682))
(let __tmp1684 (Get __tmp1681 1))
(let __tmp1685 (Single __tmp1684))
(let __tmp1686 (Get __tmp1681 2))
(let __tmp1687 (Single __tmp1686))
(let __tmp1688 (Get __tmp1681 3))
(let __tmp1689 (Single __tmp1688))
(let __tmp1690 (Get __tmp1681 5))
(let __tmp1691 (Single __tmp1690))
(let __tmp1692 (Concat __tmp1689 __tmp1691))
(let __tmp1693 (Concat __tmp1687 __tmp1692))
(let __tmp1694 (Concat __tmp1685 __tmp1693))
(let __tmp1695 (Concat __tmp1683 __tmp1694))
(let __tmp1696 (Call "matrix_loc" __tmp1695))
(let __tmp1697 (Get __tmp1695 0))
(let __tmp1698 (Get __tmp1695 1))
(let __tmp1699 (Get __tmp1695 3))
(let __tmp1700 (Bop __tmp31 __tmp1698 __tmp1699))
(let __tmp1701 (Get __tmp1695 2))
(let __tmp1702 (Bop __tmp146 __tmp1700 __tmp1701))
(let __tmp1703 (Bop __tmp413 __tmp1697 __tmp1702))
(let __tmp1704 (Single __tmp1703))
(let __tmp1705 (Get __tmp1695 4))
(let __tmp1706 (Single __tmp1705))
(let __tmp1707 (Concat __tmp1704 __tmp1706))
(let __tmp1708 (InFunc " loop_ctx_6"))
(let __tmp1709 (Arg __tmp768 __tmp1708))
(let __tmp1710 (Get __tmp1709 4))
(let __tmp1711 (Single __tmp1710))
(let __tmp1712 (Get __tmp1709 2))
(let __tmp1713 (Single __tmp1712))
(let __tmp1714 (Get __tmp1709 0))
(let __tmp1715 (Single __tmp1714))
(let __tmp1716 (Concat __tmp1713 __tmp1715))
(let __tmp1717 (Concat __tmp1711 __tmp1716))
(let __tmp1718 (Call "vector_get" __tmp1717))
(let __tmp1719 (Get __tmp1717 0))
(let __tmp1720 (Get __tmp1717 1))
(let __tmp1721 (Bop __tmp413 __tmp1719 __tmp1720))
(let __tmp1722 (Get __tmp1717 2))
(let __tmp1723 (Bop __tmp466 __tmp1721 __tmp1722))
(let __tmp1724 (Print ))
(let __tmp1725 (Get __tmp749 0))
(let __tmp1726 (Get __tmp817 0))
(let __tmp1727 (Bop __tmp141 __tmp1725 __tmp1726))
(let __tmp1728 (Free ))
(let __tmp1729 (Get __tmp742 1))
(let __tmp1730 (Get __tmp742 2))
(let __tmp1731 (Get __tmp742 5))
(let __tmp1732 (Get __tmp817 1))
(let __tmp1733 (Bop __tmp1728 __tmp1731 __tmp1732))
(let __tmp1734 (Bop __tmp1728 __tmp743 __tmp1733))
(let __tmp1735 (Bop __tmp1728 __tmp811 __tmp1734))
(let __tmp1736 (Bop __tmp1728 __tmp1730 __tmp1735))
(let __tmp1737 (Bop __tmp1728 __tmp1729 __tmp1736))
(let __tmp1738 (Bop __tmp1724 __tmp1727 __tmp1737))
(let __tmp1739 (Single __tmp1738))
(let __tmp1740 (Function "main" __tmp4 __tmp4 __tmp1739))
(let __tmp1741 (TCons __tmp13 __tmp1675))
(let __tmp1742 (TCons __tmp100 __tmp1741))
(let __tmp1743 (TCons __tmp14 __tmp1742))
(let __tmp1744 (TCons __tmp14 __tmp1743))
(let __tmp1745 (TCons __tmp14 __tmp1744))
(let __tmp1746 (TupleT __tmp1745))
(let __tmp1747 (InFunc "init"))
(let __tmp1748 (Const __tmp60 __tmp1746 __tmp1747))
(let __tmp1749 (Arg __tmp1746 __tmp1747))
(let __tmp1750 (Get __tmp1749 5))
(let __tmp1751 (Bop __tmp59 __tmp1748 __tmp1750))
(let __tmp1752 (Get __tmp1749 7))
(let __tmp1753 (Single __tmp1752))
(let __tmp1754 (Const __tmp66 __tmp1746 __tmp1747))
(let __tmp1755 (Single __tmp1754))
(let __tmp1756 (Const __tmp69 __tmp1746 __tmp1747))
(let __tmp1757 (Single __tmp1756))
(let __tmp1758 (Single __tmp1748))
(let __tmp1759 (Const __tmp73 __tmp1746 __tmp1747))
(let __tmp1760 (Single __tmp1759))
(let __tmp1761 (Get __tmp1749 2))
(let __tmp1762 (Single __tmp1761))
(let __tmp1763 (Single __tmp1750))
(let __tmp1764 (Get __tmp1749 4))
(let __tmp1765 (Single __tmp1764))
(let __tmp1766 (Get __tmp1749 3))
(let __tmp1767 (Single __tmp1766))
(let __tmp1768 (Get __tmp1749 1))
(let __tmp1769 (Single __tmp1768))
(let __tmp1770 (Get __tmp1749 0))
(let __tmp1771 (Single __tmp1770))
(let __tmp1772 (Get __tmp1749 6))
(let __tmp1773 (Single __tmp1772))
(let __tmp1774 (Concat __tmp1771 __tmp1773))
(let __tmp1775 (Concat __tmp1769 __tmp1774))
(let __tmp1776 (Concat __tmp1767 __tmp1775))
(let __tmp1777 (Concat __tmp1765 __tmp1776))
(let __tmp1778 (Concat __tmp1763 __tmp1777))
(let __tmp1779 (Concat __tmp1762 __tmp1778))
(let __tmp1780 (Concat __tmp1760 __tmp1779))
(let __tmp1781 (Concat __tmp1758 __tmp1780))
(let __tmp1782 (Concat __tmp1757 __tmp1781))
(let __tmp1783 (Concat __tmp1755 __tmp1782))
(let __tmp1784 (Concat __tmp1753 __tmp1783))
(let __tmp1785 (InIf true __tmp1751 __tmp1784))
(let __tmp1786 (Arg __tmp113 __tmp1785))
(let __tmp1787 (Get __tmp1236 2))
(let __tmp1788 (Bop __tmp141 __tmp1237 __tmp1787))
(let __tmp1789 (Single __tmp1788))
(let __tmp1790 (Single __tmp1787))
(let __tmp1791 (Get __tmp1236 4))
(let __tmp1792 (Bop __tmp146 __tmp1791 __tmp1344))
(let __tmp1793 (Single __tmp1792))
(let __tmp1794 (Single __tmp1791))
(let __tmp1795 (Get __tmp1236 5))
(let __tmp1796 (Single __tmp1795))
(let __tmp1797 (Get __tmp1236 6))
(let __tmp1798 (Single __tmp1797))
(let __tmp1799 (Get __tmp1236 7))
(let __tmp1800 (Single __tmp1799))
(let __tmp1801 (Get __tmp1236 8))
(let __tmp1802 (Single __tmp1801))
(let __tmp1803 (Get __tmp1236 9))
(let __tmp1804 (Single __tmp1803))
(let __tmp1805 (Concat __tmp1802 __tmp1804))
(let __tmp1806 (Concat __tmp1800 __tmp1805))
(let __tmp1807 (Concat __tmp1798 __tmp1806))
(let __tmp1808 (Concat __tmp1343 __tmp1240))
(let __tmp1809 (Concat __tmp1807 __tmp1808))
(let __tmp1810 (Concat __tmp1796 __tmp1809))
(let __tmp1811 (Concat __tmp1794 __tmp1810))
(let __tmp1812 (Concat __tmp1793 __tmp1811))
(let __tmp1813 (Concat __tmp1790 __tmp1812))
(let __tmp1814 (Concat __tmp1789 __tmp1813))
(let __tmp1815 (Concat __tmp1354 __tmp1814))
(let __tmp1816 (Get __tmp1815 3))
(let __tmp1817 (Get __tmp1815 6))
(let __tmp1818 (Bop __tmp59 __tmp1816 __tmp1817))
(let __tmp1819 (Single __tmp1818))
(let __tmp1820 (Concat __tmp1819 __tmp1815))
(let __tmp1821 (DoWhile __tmp1786 __tmp1820))
(let __tmp1822 (InIf false __tmp1751 __tmp1784))
(let __tmp1823 (Arg __tmp113 __tmp1822))
(let __tmp1824 (If __tmp1751 __tmp1784 __tmp1821 __tmp1823))
(let __tmp1825 (Get __tmp1824 0))
(let __tmp1826 (Single __tmp1825))
(let __tmp1827 (Get __tmp1824 2))
(let __tmp1828 (Single __tmp1827))
(let __tmp1829 (Get __tmp1824 5))
(let __tmp1830 (Single __tmp1829))
(let __tmp1831 (Get __tmp1824 7))
(let __tmp1832 (Single __tmp1831))
(let __tmp1833 (Get __tmp1824 9))
(let __tmp1834 (Single __tmp1833))
(let __tmp1835 (Concat __tmp1767 __tmp1834))
(let __tmp1836 (Concat __tmp1832 __tmp1835))
(let __tmp1837 (Concat __tmp1763 __tmp1836))
(let __tmp1838 (Concat __tmp1830 __tmp1837))
(let __tmp1839 (Concat __tmp1760 __tmp1838))
(let __tmp1840 (Concat __tmp1758 __tmp1839))
(let __tmp1841 (Concat __tmp1828 __tmp1840))
(let __tmp1842 (Concat __tmp1755 __tmp1841))
(let __tmp1843 (Concat __tmp1826 __tmp1842))
(let __tmp1844 (Single __tmp1366))
(let __tmp1845 (Get __tmp1368 2))
(let __tmp1846 (Single __tmp1845))
(let __tmp1847 (Get __tmp1368 4))
(let __tmp1848 (Single __tmp1847))
(let __tmp1849 (Const __tmp60 __tmp210 __tmp1367))
(let __tmp1850 (Single __tmp1849))
(let __tmp1851 (Get __tmp1368 5))
(let __tmp1852 (Single __tmp1851))
(let __tmp1853 (Get __tmp1368 6))
(let __tmp1854 (Single __tmp1853))
(let __tmp1855 (Get __tmp1368 8))
(let __tmp1856 (Single __tmp1855))
(let __tmp1857 (Concat __tmp1856 __tmp1475))
(let __tmp1858 (Concat __tmp1372 __tmp1857))
(let __tmp1859 (Concat __tmp1854 __tmp1858))
(let __tmp1860 (Concat __tmp1852 __tmp1859))
(let __tmp1861 (Concat __tmp1850 __tmp1860))
(let __tmp1862 (Concat __tmp1385 __tmp1861))
(let __tmp1863 (Concat __tmp1848 __tmp1862))
(let __tmp1864 (Concat __tmp1477 __tmp1863))
(let __tmp1865 (Concat __tmp1846 __tmp1864))
(let __tmp1866 (Concat __tmp1370 __tmp1865))
(let __tmp1867 (Concat __tmp1486 __tmp1866))
(let __tmp1868 (Get __tmp1867 6))
(let __tmp1869 (Get __tmp1867 10))
(let __tmp1870 (Bop __tmp59 __tmp1868 __tmp1869))
(let __tmp1871 (InIf true __tmp1870 __tmp1867))
(let __tmp1872 (Arg __tmp275 __tmp1871))
(let __tmp1873 (Single __tmp1499))
(let __tmp1874 (Single __tmp1497))
(let __tmp1875 (Get __tmp1495 4))
(let __tmp1876 (Single __tmp1875))
(let __tmp1877 (Single __tmp1498))
(let __tmp1878 (Bop __tmp146 __tmp1875 __tmp1609))
(let __tmp1879 (Single __tmp1878))
(let __tmp1880 (Get __tmp1495 10))
(let __tmp1881 (Single __tmp1880))
(let __tmp1882 (Get __tmp1495 11))
(let __tmp1883 (Single __tmp1882))
(let __tmp1884 (Concat __tmp1881 __tmp1883))
(let __tmp1885 (Concat __tmp1503 __tmp1884))
(let __tmp1886 (Concat __tmp1612 __tmp1885))
(let __tmp1887 (Concat __tmp1606 __tmp1886))
(let __tmp1888 (Concat __tmp1879 __tmp1887))
(let __tmp1889 (Concat __tmp1877 __tmp1888))
(let __tmp1890 (Concat __tmp1876 __tmp1889))
(let __tmp1891 (Concat __tmp1608 __tmp1890))
(let __tmp1892 (Concat __tmp1874 __tmp1891))
(let __tmp1893 (Concat __tmp1873 __tmp1892))
(let __tmp1894 (Concat __tmp1623 __tmp1893))
(let __tmp1895 (Get __tmp1894 6))
(let __tmp1896 (Get __tmp1894 10))
(let __tmp1897 (Bop __tmp59 __tmp1895 __tmp1896))
(let __tmp1898 (Single __tmp1897))
(let __tmp1899 (Concat __tmp1898 __tmp1894))
(let __tmp1900 (DoWhile __tmp1872 __tmp1899))
(let __tmp1901 (InIf false __tmp1870 __tmp1867))
(let __tmp1902 (Arg __tmp275 __tmp1901))
(let __tmp1903 (If __tmp1870 __tmp1867 __tmp1900 __tmp1902))
(let __tmp1904 (Get __tmp1903 0))
(let __tmp1905 (Single __tmp1904))
(let __tmp1906 (Get __tmp1903 1))
(let __tmp1907 (Get __tmp1903 2))
(let __tmp1908 (Bop __tmp141 __tmp1906 __tmp1907))
(let __tmp1909 (Single __tmp1908))
(let __tmp1910 (Single __tmp1907))
(let __tmp1911 (Bop __tmp146 __tmp1847 __tmp1476))
(let __tmp1912 (Single __tmp1911))
(let __tmp1913 (Get __tmp1903 7))
(let __tmp1914 (Single __tmp1913))
(let __tmp1915 (Get __tmp1903 9))
(let __tmp1916 (Single __tmp1915))
(let __tmp1917 (Get __tmp1903 11))
(let __tmp1918 (Single __tmp1917))
(let __tmp1919 (Concat __tmp1856 __tmp1918))
(let __tmp1920 (Concat __tmp1916 __tmp1919))
(let __tmp1921 (Concat __tmp1854 __tmp1920))
(let __tmp1922 (Concat __tmp1914 __tmp1921))
(let __tmp1923 (Concat __tmp1848 __tmp1922))
(let __tmp1924 (Concat __tmp1912 __tmp1923))
(let __tmp1925 (Concat __tmp1910 __tmp1924))
(let __tmp1926 (Concat __tmp1909 __tmp1925))
(let __tmp1927 (Concat __tmp1905 __tmp1926))
(let __tmp1928 (InIf false __tmp1366 __tmp1363))
(let __tmp1929 (Arg __tmp210 __tmp1928))
(let __tmp1930 (If __tmp1366 __tmp1363 __tmp1927 __tmp1929))
(let __tmp1931 (Concat __tmp1844 __tmp1930))
(let __tmp1932 (DoWhile __tmp1843 __tmp1931))
(let __tmp1933 (Get __tmp1932 0))
(let __tmp1934 (Single __tmp1933))
(let __tmp1935 (Function "init" __tmp1746 __tmp4 __tmp1934))
(let __tmp1936 (TupleT __tmp1656))
(let __tmp1937 (TCons __tmp14 __tmp3))
(let __tmp1938 (TupleT __tmp1937))
(let __tmp1939 (InFunc "matrix_new"))
(let __tmp1940 (Arg __tmp1936 __tmp1939))
(let __tmp1941 (Get __tmp1940 1))
(let __tmp1942 (Get __tmp1940 0))
(let __tmp1943 (Bop __tmp31 __tmp1941 __tmp1942))
(let __tmp1944 (Get __tmp1940 2))
(let __tmp1945 (Alloc 0 __tmp1943 __tmp1944 __tmp14))
(let __tmp1946 (Function "matrix_new" __tmp1936 __tmp1938 __tmp1945))
(let __tmp1947 (InFunc "matrix_loc"))
(let __tmp1948 (Arg __tmp1659 __tmp1947))
(let __tmp1949 (Get __tmp1948 0))
(let __tmp1950 (Get __tmp1948 1))
(let __tmp1951 (Get __tmp1948 3))
(let __tmp1952 (Bop __tmp31 __tmp1950 __tmp1951))
(let __tmp1953 (Get __tmp1948 2))
(let __tmp1954 (Bop __tmp146 __tmp1952 __tmp1953))
(let __tmp1955 (Bop __tmp413 __tmp1949 __tmp1954))
(let __tmp1956 (Single __tmp1955))
(let __tmp1957 (Get __tmp1948 4))
(let __tmp1958 (Single __tmp1957))
(let __tmp1959 (Concat __tmp1956 __tmp1958))
(let __tmp1960 (Function "matrix_loc" __tmp1659 __tmp1938 __tmp1959))
(let __tmp1961 (TupleT __tmp1674))
(let __tmp1962 (Get __tmp1662 0))
(let __tmp1963 (Get __tmp1662 1))
(let __tmp1964 (Bop __tmp466 __tmp1962 __tmp1963))
(let __tmp1965 (Function "matrix_get" __tmp1659 __tmp1961 __tmp1964))
(let __tmp1966 (Get __tmp1696 0))
(let __tmp1967 (Get __tmp1681 4))
(let __tmp1968 (Get __tmp1696 1))
(let __tmp1969 (Top __tmp412 __tmp1966 __tmp1967 __tmp1968))
(let __tmp1970 (Single __tmp1969))
(let __tmp1971 (Function "matrix_set" __tmp1679 __tmp4 __tmp1970))
(let __tmp1972 (TupleT __tmp1655))
(let __tmp1973 (InFunc "vector_new"))
(let __tmp1974 (Arg __tmp1972 __tmp1973))
(let __tmp1975 (Get __tmp1974 0))
(let __tmp1976 (Get __tmp1974 1))
(let __tmp1977 (Alloc 0 __tmp1975 __tmp1976 __tmp14))
(let __tmp1978 (Function "vector_new" __tmp1972 __tmp1938 __tmp1977))
(let __tmp1979 (TCons __tmp14 __tmp1655))
(let __tmp1980 (TupleT __tmp1979))
(let __tmp1981 (InFunc "vector_get"))
(let __tmp1982 (Arg __tmp1980 __tmp1981))
(let __tmp1983 (Get __tmp1982 0))
(let __tmp1984 (Get __tmp1982 1))
(let __tmp1985 (Bop __tmp413 __tmp1983 __tmp1984))
(let __tmp1986 (Get __tmp1982 2))
(let __tmp1987 (Bop __tmp466 __tmp1985 __tmp1986))
(let __tmp1988 (Function "vector_get" __tmp1980 __tmp1961 __tmp1987))
(let __tmp1989 (TCons __tmp14 __tmp1675))
(let __tmp1990 (TupleT __tmp1989))
(let __tmp1991 (InFunc "vector_set"))
(let __tmp1992 (Arg __tmp1990 __tmp1991))
(let __tmp1993 (Get __tmp1992 0))
(let __tmp1994 (Get __tmp1992 1))
(let __tmp1995 (Bop __tmp413 __tmp1993 __tmp1994))
(let __tmp1996 (Get __tmp1992 2))
(let __tmp1997 (Get __tmp1992 3))
(let __tmp1998 (Top __tmp412 __tmp1995 __tmp1996 __tmp1997))
(let __tmp1999 (Single __tmp1998))
(let __tmp2000 (Function "vector_set" __tmp1990 __tmp4 __tmp1999))
(let __tmp2001 (InFunc "vector_sum"))
(let __tmp2002 (Const __tmp60 __tmp1980 __tmp2001))
(let __tmp2003 (Arg __tmp1980 __tmp2001))
(let __tmp2004 (Get __tmp2003 1))
(let __tmp2005 (Bop __tmp59 __tmp2002 __tmp2004))
(let __tmp2006 (Get __tmp2003 2))
(let __tmp2007 (Single __tmp2006))
(let __tmp2008 (Const __tmp66 __tmp1980 __tmp2001))
(let __tmp2009 (Single __tmp2008))
(let __tmp2010 (Single __tmp2002))
(let __tmp2011 (Const __tmp73 __tmp1980 __tmp2001))
(let __tmp2012 (Single __tmp2011))
(let __tmp2013 (Get __tmp2003 0))
(let __tmp2014 (Single __tmp2013))
(let __tmp2015 (Single __tmp2004))
(let __tmp2016 (Concat __tmp2014 __tmp2015))
(let __tmp2017 (Concat __tmp2012 __tmp2016))
(let __tmp2018 (Concat __tmp2010 __tmp2017))
(let __tmp2019 (Concat __tmp2009 __tmp2018))
(let __tmp2020 (Concat __tmp2007 __tmp2019))
(let __tmp2021 (InIf true __tmp2005 __tmp2020))
(let __tmp2022 (Arg __tmp768 __tmp2021))
(let __tmp2023 (Get __tmp1709 3))
(let __tmp2024 (Bop __tmp146 __tmp1712 __tmp2023))
(let __tmp2025 (Get __tmp1709 5))
(let __tmp2026 (Bop __tmp59 __tmp2024 __tmp2025))
(let __tmp2027 (Single __tmp2026))
(let __tmp2028 (Get __tmp1718 1))
(let __tmp2029 (Single __tmp2028))
(let __tmp2030 (Get __tmp1709 1))
(let __tmp2031 (Get __tmp1718 0))
(let __tmp2032 (Bop __tmp141 __tmp2030 __tmp2031))
(let __tmp2033 (Single __tmp2032))
(let __tmp2034 (Concat __tmp2029 __tmp2033))
(let __tmp2035 (Single __tmp2024))
(let __tmp2036 (Single __tmp2023))
(let __tmp2037 (Concat __tmp2036 __tmp1711))
(let __tmp2038 (Single __tmp2025))
(let __tmp2039 (Concat __tmp2037 __tmp2038))
(let __tmp2040 (Concat __tmp2035 __tmp2039))
(let __tmp2041 (Concat __tmp2034 __tmp2040))
(let __tmp2042 (Concat __tmp2027 __tmp2041))
(let __tmp2043 (DoWhile __tmp2022 __tmp2042))
(let __tmp2044 (InIf false __tmp2005 __tmp2020))
(let __tmp2045 (Arg __tmp768 __tmp2044))
(let __tmp2046 (If __tmp2005 __tmp2020 __tmp2043 __tmp2045))
(let __tmp2047 (Get __tmp2046 1))
(let __tmp2048 (Single __tmp2047))
(let __tmp2049 (Get __tmp2046 0))
(let __tmp2050 (Single __tmp2049))
(let __tmp2051 (Concat __tmp2048 __tmp2050))
(let __tmp2052 (Function "vector_sum" __tmp1980 __tmp1961 __tmp2051))
(let __tmp2053 (TCons __tmp13 __tmp1674))
(let __tmp2054 (TupleT __tmp2053))
(let __tmp2055 (InFunc "fmod"))
(let __tmp2056 (Arg __tmp2054 __tmp2055))
(let __tmp2057 (Get __tmp2056 2))
(let __tmp2058 (Single __tmp2057))
(let __tmp2059 (Get __tmp2056 0))
(let __tmp2060 (Single __tmp2059))
(let __tmp2061 (Const __tmp876 __tmp2054 __tmp2055))
(let __tmp2062 (Single __tmp2061))
(let __tmp2063 (Const __tmp66 __tmp2054 __tmp2055))
(let __tmp2064 (Single __tmp2063))
(let __tmp2065 (Get __tmp2056 1))
(let __tmp2066 (Single __tmp2065))
(let __tmp2067 (Concat __tmp2064 __tmp2066))
(let __tmp2068 (Concat __tmp2062 __tmp2067))
(let __tmp2069 (Concat __tmp2060 __tmp2068))
(let __tmp2070 (Concat __tmp2058 __tmp2069))
(let __tmp2071 (InFunc " loop_ctx_7"))
(let __tmp2072 (Arg __tmp892 __tmp2071))
(let __tmp2073 (Get __tmp2072 1))
(let __tmp2074 (Get __tmp2072 4))
(let __tmp2075 (Bop __tmp887 __tmp2073 __tmp2074))
(let __tmp2076 (Single __tmp2075))
(let __tmp2077 (InIf true __tmp2075 __tmp2072))
(let __tmp2078 (Arg __tmp892 __tmp2077))
(let __tmp2079 (Get __tmp2078 1))
(let __tmp2080 (Get __tmp2078 4))
(let __tmp2081 (Bop __tmp899 __tmp2079 __tmp2080))
(let __tmp2082 (Get __tmp2078 3))
(let __tmp2083 (Bop __tmp887 __tmp2081 __tmp2082))
(let __tmp2084 (Get __tmp2078 0))
(let __tmp2085 (Single __tmp2084))
(let __tmp2086 (Single __tmp2079))
(let __tmp2087 (Single __tmp2080))
(let __tmp2088 (Get __tmp2078 2))
(let __tmp2089 (Single __tmp2088))
(let __tmp2090 (Single __tmp2082))
(let __tmp2091 (Concat __tmp2090 __tmp2087))
(let __tmp2092 (Concat __tmp2089 __tmp2091))
(let __tmp2093 (Concat __tmp2087 __tmp2092))
(let __tmp2094 (Concat __tmp2086 __tmp2093))
(let __tmp2095 (Concat __tmp2085 __tmp2094))
(let __tmp2096 (InIf true __tmp2083 __tmp2095))
(let __tmp2097 (Arg __tmp921 __tmp2096))
(let __tmp2098 (InFunc " loop_ctx_8"))
(let __tmp2099 (Arg __tmp921 __tmp2098))
(let __tmp2100 (Get __tmp2099 1))
(let __tmp2101 (Get __tmp2099 2))
(let __tmp2102 (Get __tmp2099 3))
(let __tmp2103 (Bop __tmp288 __tmp2101 __tmp2102))
(let __tmp2104 (Bop __tmp899 __tmp2100 __tmp2103))
(let __tmp2105 (Get __tmp2099 4))
(let __tmp2106 (Bop __tmp887 __tmp2104 __tmp2105))
(let __tmp2107 (Single __tmp2106))
(let __tmp2108 (Get __tmp2099 0))
(let __tmp2109 (Single __tmp2108))
(let __tmp2110 (Single __tmp2100))
(let __tmp2111 (Concat __tmp2109 __tmp2110))
(let __tmp2112 (Single __tmp2103))
(let __tmp2113 (Single __tmp2102))
(let __tmp2114 (Concat __tmp2112 __tmp2113))
(let __tmp2115 (Single __tmp2105))
(let __tmp2116 (Concat __tmp2114 __tmp2115))
(let __tmp2117 (Get __tmp2099 5))
(let __tmp2118 (Single __tmp2117))
(let __tmp2119 (Concat __tmp2116 __tmp2118))
(let __tmp2120 (Concat __tmp2111 __tmp2119))
(let __tmp2121 (Concat __tmp2107 __tmp2120))
(let __tmp2122 (DoWhile __tmp2097 __tmp2121))
(let __tmp2123 (InIf false __tmp2083 __tmp2095))
(let __tmp2124 (Arg __tmp921 __tmp2123))
(let __tmp2125 (If __tmp2083 __tmp2095 __tmp2122 __tmp2124))
(let __tmp2126 (Get __tmp2125 0))
(let __tmp2127 (Single __tmp2126))
(let __tmp2128 (Get __tmp2125 1))
(let __tmp2129 (Get __tmp2125 2))
(let __tmp2130 (Get __tmp2125 3))
(let __tmp2131 (Bop __tmp122 __tmp2129 __tmp2130))
(let __tmp2132 (Bop __tmp899 __tmp2128 __tmp2131))
(let __tmp2133 (Single __tmp2132))
(let __tmp2134 (Single __tmp2130))
(let __tmp2135 (Get __tmp2125 4))
(let __tmp2136 (Single __tmp2135))
(let __tmp2137 (Concat __tmp2134 __tmp2136))
(let __tmp2138 (Get __tmp2125 5))
(let __tmp2139 (Single __tmp2138))
(let __tmp2140 (Concat __tmp2137 __tmp2139))
(let __tmp2141 (Concat __tmp2133 __tmp2140))
(let __tmp2142 (Concat __tmp2127 __tmp2141))
(let __tmp2143 (InIf false __tmp2075 __tmp2072))
(let __tmp2144 (Arg __tmp892 __tmp2143))
(let __tmp2145 (If __tmp2075 __tmp2072 __tmp2142 __tmp2144))
(let __tmp2146 (Concat __tmp2076 __tmp2145))
(let __tmp2147 (DoWhile __tmp2070 __tmp2146))
(let __tmp2148 (Get __tmp2147 1))
(let __tmp2149 (Single __tmp2148))
(let __tmp2150 (Get __tmp2147 0))
(let __tmp2151 (Single __tmp2150))
(let __tmp2152 (Concat __tmp2149 __tmp2151))
(let __tmp2153 (Function "fmod" __tmp2054 __tmp1961 __tmp2152))
(let __tmp2154 (InLoop __tmp591 __tmp622))
(let __tmp2155 (InLoop __tmp683 __tmp707))
(let __tmp2156 (InLoop __tmp650 __tmp741))
(let __tmp2157 (InLoop __tmp1786 __tmp1820))
(let __tmp2158 (InLoop __tmp1872 __tmp1899))
(let __tmp2159 (InLoop __tmp1843 __tmp1931))
(let __tmp2160 (InLoop __tmp2022 __tmp2042))
(let __tmp2161 (InLoop __tmp2097 __tmp2121))
(let __tmp2162 (InLoop __tmp2070 __tmp2146))
(let __tmp2163 (InLoop __tmp115 __tmp176))
(let __tmp2164 (InLoop __tmp277 __tmp339))
(let __tmp2165 (InLoop __tmp199 __tmp371))
(let __tmp2166 (InLoop __tmp770 __tmp801))
(let __tmp2167 (InLoop __tmp831 __tmp862))
(let __tmp2168 (InLoop __tmp923 __tmp947))
(let __tmp2169 (InLoop __tmp886 __tmp972))
(let __tmp2170 (InLoop __tmp1024 __tmp1048))
(let __tmp2171 (InLoop __tmp997 __tmp1073))
(let __tmp2172 (InLoop __tmp1127 __tmp1151))
(let __tmp2173 (InLoop __tmp1100 __tmp1176))
(let __tmp2174 (InLoop __tmp1286 __tmp1310))
(let __tmp2175 (InLoop __tmp1259 __tmp1335))
(let __tmp2176 (InLoop __tmp1418 __tmp1442))
(let __tmp2177 (InLoop __tmp1391 __tmp1467))
(let __tmp2178 (InLoop __tmp1549 __tmp1573))
(let __tmp2179 (InLoop __tmp1522 __tmp1598))
(FunctionHasType "main" (TupleT (TCons (StateT) (TNil))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "init" (TupleT (TCons (PointerT (FloatT)) (TCons (PointerT (FloatT)) (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (FloatT) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil)))))))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "matrix_new" (TupleT (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))) (TupleT (TCons (PointerT (FloatT)) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_loc" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))))) (TupleT (TCons (PointerT (FloatT)) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_get" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (StateT) (TNil))))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))
(FunctionHasType "matrix_set" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (IntT) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil)))))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "vector_new" (TupleT (TCons (IntT) (TCons (StateT) (TNil)))) (TupleT (TCons (PointerT (FloatT)) (TCons (StateT) (TNil)))))
(FunctionHasType "vector_get" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (StateT) (TNil))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))
(FunctionHasType "vector_set" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (FloatT) (TCons (StateT) (TNil)))))) (TupleT (TCons (StateT) (TNil))))
(FunctionHasType "vector_sum" (TupleT (TCons (PointerT (FloatT)) (TCons (IntT) (TCons (StateT) (TNil))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))
(FunctionHasType "fmod" (TupleT (TCons (FloatT) (TCons (FloatT) (TCons (StateT) (TNil))))) (TupleT (TCons (FloatT) (TCons (StateT) (TNil)))))


    ; Loop context unions
    (union __tmp398 __tmp2154)
(union __tmp455 __tmp2155)
(union __tmp421 __tmp2156)
(union __tmp1235 __tmp2157)
(union __tmp1494 __tmp2158)
(union __tmp1362 __tmp2159)
(union __tmp1708 __tmp2160)
(union __tmp2098 __tmp2161)
(union __tmp2071 __tmp2162)
(union __tmp116 __tmp2163)
(union __tmp278 __tmp2164)
(union __tmp211 __tmp2165)
(union __tmp771 __tmp2166)
(union __tmp832 __tmp2167)
(union __tmp924 __tmp2168)
(union __tmp893 __tmp2169)
(union __tmp1025 __tmp2170)
(union __tmp998 __tmp2171)
(union __tmp1128 __tmp2172)
(union __tmp1101 __tmp2173)
(union __tmp1287 __tmp2174)
(union __tmp1260 __tmp2175)
(union __tmp1419 __tmp2176)
(union __tmp1392 __tmp2177)
(union __tmp1550 __tmp2178)
(union __tmp1523 __tmp2179)

    ; Function inlining unions
     
(union __tmp10 __tmp15)
(InlinedCall "vector_new" __tmp9)
(subsume (Call "vector_new" __tmp9))


(union __tmp22 __tmp25)
(InlinedCall "vector_new" __tmp21)
(subsume (Call "vector_new" __tmp21))


(union __tmp30 __tmp36)
(InlinedCall "matrix_new" __tmp29)
(subsume (Call "matrix_new" __tmp29))


(union __tmp58 __tmp374)
(InlinedCall "init" __tmp57)
(subsume (Call "init" __tmp57))


(union __tmp376 __tmp379)
(InlinedCall "vector_new" __tmp375)
(subsume (Call "vector_new" __tmp375))


(union __tmp383 __tmp386)
(InlinedCall "vector_new" __tmp382)
(subsume (Call "vector_new" __tmp382))


(union __tmp411 __tmp420)
(InlinedCall "vector_set" __tmp410)
(subsume (Call "vector_set" __tmp410))


(union __tmp439 __tmp446)
(InlinedCall "vector_set" __tmp438)
(subsume (Call "vector_set" __tmp438))


(union __tmp465 __tmp471)
(InlinedCall "vector_get" __tmp464)
(subsume (Call "vector_get" __tmp464))


(union __tmp484 __tmp488)
(InlinedCall "matrix_get" __tmp483)
(subsume (Call "matrix_get" __tmp483))


(union __tmp495 __tmp500)
(InlinedCall "vector_get" __tmp494)
(subsume (Call "vector_get" __tmp494))


(union __tmp512 __tmp519)
(InlinedCall "vector_set" __tmp511)
(subsume (Call "vector_set" __tmp511))


(union __tmp524 __tmp528)
(InlinedCall "matrix_get" __tmp523)
(subsume (Call "matrix_get" __tmp523))


(union __tmp535 __tmp540)
(InlinedCall "vector_get" __tmp534)
(subsume (Call "vector_get" __tmp534))


(union __tmp547 __tmp552)
(InlinedCall "vector_get" __tmp546)
(subsume (Call "vector_get" __tmp546))


(union __tmp564 __tmp571)
(InlinedCall "vector_set" __tmp563)
(subsume (Call "vector_set" __tmp563))


(union __tmp749 __tmp810)
(InlinedCall "vector_sum" __tmp748)
(subsume (Call "vector_sum" __tmp748))


(union __tmp817 __tmp871)
(InlinedCall "vector_sum" __tmp816)
(subsume (Call "vector_sum" __tmp816))


(union __tmp131 __tmp978)
(InlinedCall "fmod" __tmp130)
(subsume (Call "fmod" __tmp130))


(union __tmp140 __tmp985)
(InlinedCall "vector_set" __tmp139)
(subsume (Call "vector_set" __tmp139))


(union __tmp231 __tmp1079)
(InlinedCall "fmod" __tmp230)
(subsume (Call "fmod" __tmp230))


(union __tmp240 __tmp1086)
(InlinedCall "vector_set" __tmp239)
(subsume (Call "vector_set" __tmp239))


(union __tmp301 __tmp1182)
(InlinedCall "fmod" __tmp300)
(subsume (Call "fmod" __tmp300))


(union __tmp312 __tmp1202)
(InlinedCall "matrix_set" __tmp311)
(subsume (Call "matrix_set" __tmp311))


(union __tmp485 __tmp1213)
(InlinedCall "matrix_loc" __tmp483)
(subsume (Call "matrix_loc" __tmp483))


(union __tmp525 __tmp1224)
(InlinedCall "matrix_loc" __tmp523)
(subsume (Call "matrix_loc" __tmp523))


(union __tmp786 __tmp1229)
(InlinedCall "vector_get" __tmp785)
(subsume (Call "vector_get" __tmp785))


(union __tmp847 __tmp1234)
(InlinedCall "vector_get" __tmp846)
(subsume (Call "vector_get" __tmp846))


(union __tmp1245 __tmp1341)
(InlinedCall "fmod" __tmp1244)
(subsume (Call "fmod" __tmp1244))


(union __tmp1354 __tmp1361)
(InlinedCall "vector_set" __tmp1353)
(subsume (Call "vector_set" __tmp1353))


(union __tmp1377 __tmp1473)
(InlinedCall "fmod" __tmp1376)
(subsume (Call "fmod" __tmp1376))


(union __tmp1486 __tmp1493)
(InlinedCall "vector_set" __tmp1485)
(subsume (Call "vector_set" __tmp1485))


(union __tmp1508 __tmp1604)
(InlinedCall "fmod" __tmp1507)
(subsume (Call "fmod" __tmp1507))


(union __tmp1623 __tmp1643)
(InlinedCall "matrix_set" __tmp1622)
(subsume (Call "matrix_set" __tmp1622))


(union __tmp1638 __tmp1654)
(InlinedCall "matrix_loc" __tmp1637)
(subsume (Call "matrix_loc" __tmp1637))


(union __tmp1662 __tmp1673)
(InlinedCall "matrix_loc" __tmp1661)
(subsume (Call "matrix_loc" __tmp1661))


(union __tmp1696 __tmp1707)
(InlinedCall "matrix_loc" __tmp1695)
(subsume (Call "matrix_loc" __tmp1695))


(union __tmp1718 __tmp1723)
(InlinedCall "vector_get" __tmp1717)
(subsume (Call "vector_get" __tmp1717))

) :ruleset initialization)
(run initialization 1) 

; Schedule

(run-schedule
    (saturate
      
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

      passthrough
      state-edge-passthrough)
    (repeat 2
        
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

        all-optimizations
    )

    (repeat 4
        
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

        cheap-optimizations
    )

    (saturate
      
    ;; first, run substitution and drop to saturation
    ;; these depend on type analysis, always-run, and context

    ;; first, saturate always run
    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)
        (saturate 
            (saturate type-helpers)
            always-run)
        error-checking)

    (saturate
        (saturate 
            (saturate type-helpers)
            type-analysis)

        ;; first, check which eclasses are resolved
        (saturate is-resolved)
        (saturate term-subst)
        ;; do substutition for one round, subsuming as we go
        (saturate subst)
        ;; apply the equalities found
        apply-subst-unions

        ;; add context
        (saturate context)
        (saturate drop)
        apply-drop-unions
        cleanup-drop
    )

    (saturate canon)
    (saturate interval-analysis)
    (saturate
     terms
     (saturate
       terms-helpers
       (saturate terms-helpers-helpers)))
    (saturate mem-simple)

    ;; cicm index
    cicm-index

    ;; memory-helpers TODO run memory helpers for memory optimizations

    ;; finally, subsume now that helpers are done
    subsume-after-helpers

    ;; do a boundary analysis for loop invariant code motion
    boundary-analysis

    loop-iters-analysis

      passthrough
      state-edge-passthrough)
    add-to-debug-expr
)

(print-size)

